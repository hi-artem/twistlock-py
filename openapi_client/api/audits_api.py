# coding: utf-8

"""
    Prisma Cloud Compute API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)  # noqa: E501

    The version of the OpenAPI document: 21.04.439
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from openapi_client.api_client import ApiClient
from openapi_client.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class AuditsApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def api_v1_audits_access_download_get(self, **kwargs):  # noqa: E501
        """api_v1_audits_access_download_get  # noqa: E501

        DownloadAccessAudits downloads the access audits according to the specified query   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_access_download_get(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param type: Type is the audit type. 
        :type type: str
        :param rule_name: RuleNames are the rules names to filter by. 
        :type rule_name: list[str]
        :param api: APIs are apis to filter by. 
        :type api: list[str]
        :param hostname: Hosts are hosts to filter by. 
        :type hostname: list[str]
        :param user: Users are users to filter by. 
        :type user: list[str]
        :param allow: Allow indicated whether allowed requests should be shown. 
        :type allow: str
        :param cluster: Clusters is the cluster filter. 
        :type cluster: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_access_download_get_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_access_download_get_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_access_download_get  # noqa: E501

        DownloadAccessAudits downloads the access audits according to the specified query   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_access_download_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param type: Type is the audit type. 
        :type type: str
        :param rule_name: RuleNames are the rules names to filter by. 
        :type rule_name: list[str]
        :param api: APIs are apis to filter by. 
        :type api: list[str]
        :param hostname: Hosts are hosts to filter by. 
        :type hostname: list[str]
        :param user: Users are users to filter by. 
        :type user: list[str]
        :param allow: Allow indicated whether allowed requests should be shown. 
        :type allow: str
        :param cluster: Clusters is the cluster filter. 
        :type cluster: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'offset',
            'limit',
            'search',
            'sort',
            'reverse',
            'collections',
            'account_ids',
            'fields',
            '_from',
            'to',
            'type',
            'rule_name',
            'api',
            'hostname',
            'user',
            'allow',
            'cluster'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_access_download_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'reverse' in local_var_params and local_var_params['reverse'] is not None:  # noqa: E501
            query_params.append(('reverse', local_var_params['reverse']))  # noqa: E501
        if 'collections' in local_var_params and local_var_params['collections'] is not None:  # noqa: E501
            query_params.append(('collections', local_var_params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'account_ids' in local_var_params and local_var_params['account_ids'] is not None:  # noqa: E501
            query_params.append(('accountIDs', local_var_params['account_ids']))  # noqa: E501
            collection_formats['accountIDs'] = 'multi'  # noqa: E501
        if 'fields' in local_var_params and local_var_params['fields'] is not None:  # noqa: E501
            query_params.append(('fields', local_var_params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if '_from' in local_var_params and local_var_params['_from'] is not None:  # noqa: E501
            query_params.append(('from', local_var_params['_from']))  # noqa: E501
        if 'to' in local_var_params and local_var_params['to'] is not None:  # noqa: E501
            query_params.append(('to', local_var_params['to']))  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
        if 'rule_name' in local_var_params and local_var_params['rule_name'] is not None:  # noqa: E501
            query_params.append(('ruleName', local_var_params['rule_name']))  # noqa: E501
            collection_formats['ruleName'] = 'multi'  # noqa: E501
        if 'api' in local_var_params and local_var_params['api'] is not None:  # noqa: E501
            query_params.append(('api', local_var_params['api']))  # noqa: E501
            collection_formats['api'] = 'multi'  # noqa: E501
        if 'hostname' in local_var_params and local_var_params['hostname'] is not None:  # noqa: E501
            query_params.append(('hostname', local_var_params['hostname']))  # noqa: E501
            collection_formats['hostname'] = 'multi'  # noqa: E501
        if 'user' in local_var_params and local_var_params['user'] is not None:  # noqa: E501
            query_params.append(('user', local_var_params['user']))  # noqa: E501
            collection_formats['user'] = 'multi'  # noqa: E501
        if 'allow' in local_var_params and local_var_params['allow'] is not None:  # noqa: E501
            query_params.append(('allow', local_var_params['allow']))  # noqa: E501
        if 'cluster' in local_var_params and local_var_params['cluster'] is not None:  # noqa: E501
            query_params.append(('cluster', local_var_params['cluster']))  # noqa: E501
            collection_formats['cluster'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/audits/access/download', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_access_get(self, **kwargs):  # noqa: E501
        """api_v1_audits_access_get  # noqa: E501

        AccessAudits returns all access audits for the query specification   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_access_get(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param type: Type is the audit type. 
        :type type: str
        :param rule_name: RuleNames are the rules names to filter by. 
        :type rule_name: list[str]
        :param api: APIs are apis to filter by. 
        :type api: list[str]
        :param hostname: Hosts are hosts to filter by. 
        :type hostname: list[str]
        :param user: Users are users to filter by. 
        :type user: list[str]
        :param allow: Allow indicated whether allowed requests should be shown. 
        :type allow: str
        :param cluster: Clusters is the cluster filter. 
        :type cluster: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[SharedAudit]
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_access_get_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_access_get_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_access_get  # noqa: E501

        AccessAudits returns all access audits for the query specification   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_access_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param type: Type is the audit type. 
        :type type: str
        :param rule_name: RuleNames are the rules names to filter by. 
        :type rule_name: list[str]
        :param api: APIs are apis to filter by. 
        :type api: list[str]
        :param hostname: Hosts are hosts to filter by. 
        :type hostname: list[str]
        :param user: Users are users to filter by. 
        :type user: list[str]
        :param allow: Allow indicated whether allowed requests should be shown. 
        :type allow: str
        :param cluster: Clusters is the cluster filter. 
        :type cluster: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[SharedAudit], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'offset',
            'limit',
            'search',
            'sort',
            'reverse',
            'collections',
            'account_ids',
            'fields',
            '_from',
            'to',
            'type',
            'rule_name',
            'api',
            'hostname',
            'user',
            'allow',
            'cluster'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_access_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'reverse' in local_var_params and local_var_params['reverse'] is not None:  # noqa: E501
            query_params.append(('reverse', local_var_params['reverse']))  # noqa: E501
        if 'collections' in local_var_params and local_var_params['collections'] is not None:  # noqa: E501
            query_params.append(('collections', local_var_params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'account_ids' in local_var_params and local_var_params['account_ids'] is not None:  # noqa: E501
            query_params.append(('accountIDs', local_var_params['account_ids']))  # noqa: E501
            collection_formats['accountIDs'] = 'multi'  # noqa: E501
        if 'fields' in local_var_params and local_var_params['fields'] is not None:  # noqa: E501
            query_params.append(('fields', local_var_params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if '_from' in local_var_params and local_var_params['_from'] is not None:  # noqa: E501
            query_params.append(('from', local_var_params['_from']))  # noqa: E501
        if 'to' in local_var_params and local_var_params['to'] is not None:  # noqa: E501
            query_params.append(('to', local_var_params['to']))  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
        if 'rule_name' in local_var_params and local_var_params['rule_name'] is not None:  # noqa: E501
            query_params.append(('ruleName', local_var_params['rule_name']))  # noqa: E501
            collection_formats['ruleName'] = 'multi'  # noqa: E501
        if 'api' in local_var_params and local_var_params['api'] is not None:  # noqa: E501
            query_params.append(('api', local_var_params['api']))  # noqa: E501
            collection_formats['api'] = 'multi'  # noqa: E501
        if 'hostname' in local_var_params and local_var_params['hostname'] is not None:  # noqa: E501
            query_params.append(('hostname', local_var_params['hostname']))  # noqa: E501
            collection_formats['hostname'] = 'multi'  # noqa: E501
        if 'user' in local_var_params and local_var_params['user'] is not None:  # noqa: E501
            query_params.append(('user', local_var_params['user']))  # noqa: E501
            collection_formats['user'] = 'multi'  # noqa: E501
        if 'allow' in local_var_params and local_var_params['allow'] is not None:  # noqa: E501
            query_params.append(('allow', local_var_params['allow']))  # noqa: E501
        if 'cluster' in local_var_params and local_var_params['cluster'] is not None:  # noqa: E501
            query_params.append(('cluster', local_var_params['cluster']))  # noqa: E501
            collection_formats['cluster'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "list[SharedAudit]",
        }

        return self.api_client.call_api(
            '/api/v1/audits/access', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_admission_download_get(self, **kwargs):  # noqa: E501
        """api_v1_audits_admission_download_get  # noqa: E501

        DownloadAdmissionAudits downloads the admission audits according to the specified query   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_admission_download_get(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the activity. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the activity. 
        :type to: datetime
        :param namespace: Namespaces is the list of namespaces to use for filtering. 
        :type namespace: list[str]
        :param operation: Operations is the list of operations to use for filtering. 
        :type operation: list[str]
        :param cluster: Clusters is the cluster filter. 
        :type cluster: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_admission_download_get_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_admission_download_get_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_admission_download_get  # noqa: E501

        DownloadAdmissionAudits downloads the admission audits according to the specified query   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_admission_download_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the activity. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the activity. 
        :type to: datetime
        :param namespace: Namespaces is the list of namespaces to use for filtering. 
        :type namespace: list[str]
        :param operation: Operations is the list of operations to use for filtering. 
        :type operation: list[str]
        :param cluster: Clusters is the cluster filter. 
        :type cluster: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'offset',
            'limit',
            'search',
            'sort',
            'reverse',
            'collections',
            'account_ids',
            'fields',
            '_from',
            'to',
            'namespace',
            'operation',
            'cluster',
            'attack_techniques'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_admission_download_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'reverse' in local_var_params and local_var_params['reverse'] is not None:  # noqa: E501
            query_params.append(('reverse', local_var_params['reverse']))  # noqa: E501
        if 'collections' in local_var_params and local_var_params['collections'] is not None:  # noqa: E501
            query_params.append(('collections', local_var_params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'account_ids' in local_var_params and local_var_params['account_ids'] is not None:  # noqa: E501
            query_params.append(('accountIDs', local_var_params['account_ids']))  # noqa: E501
            collection_formats['accountIDs'] = 'multi'  # noqa: E501
        if 'fields' in local_var_params and local_var_params['fields'] is not None:  # noqa: E501
            query_params.append(('fields', local_var_params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if '_from' in local_var_params and local_var_params['_from'] is not None:  # noqa: E501
            query_params.append(('from', local_var_params['_from']))  # noqa: E501
        if 'to' in local_var_params and local_var_params['to'] is not None:  # noqa: E501
            query_params.append(('to', local_var_params['to']))  # noqa: E501
        if 'namespace' in local_var_params and local_var_params['namespace'] is not None:  # noqa: E501
            query_params.append(('namespace', local_var_params['namespace']))  # noqa: E501
            collection_formats['namespace'] = 'multi'  # noqa: E501
        if 'operation' in local_var_params and local_var_params['operation'] is not None:  # noqa: E501
            query_params.append(('operation', local_var_params['operation']))  # noqa: E501
            collection_formats['operation'] = 'multi'  # noqa: E501
        if 'cluster' in local_var_params and local_var_params['cluster'] is not None:  # noqa: E501
            query_params.append(('cluster', local_var_params['cluster']))  # noqa: E501
            collection_formats['cluster'] = 'multi'  # noqa: E501
        if 'attack_techniques' in local_var_params and local_var_params['attack_techniques'] is not None:  # noqa: E501
            query_params.append(('attackTechniques', local_var_params['attack_techniques']))  # noqa: E501
            collection_formats['attackTechniques'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/audits/admission/download', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_admission_get(self, **kwargs):  # noqa: E501
        """api_v1_audits_admission_get  # noqa: E501

        AdmissionAudits returns all admission audits according to the query specification   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_admission_get(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the activity. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the activity. 
        :type to: datetime
        :param namespace: Namespaces is the list of namespaces to use for filtering. 
        :type namespace: list[str]
        :param operation: Operations is the list of operations to use for filtering. 
        :type operation: list[str]
        :param cluster: Clusters is the cluster filter. 
        :type cluster: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[AdmissionAudit]
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_admission_get_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_admission_get_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_admission_get  # noqa: E501

        AdmissionAudits returns all admission audits according to the query specification   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_admission_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the activity. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the activity. 
        :type to: datetime
        :param namespace: Namespaces is the list of namespaces to use for filtering. 
        :type namespace: list[str]
        :param operation: Operations is the list of operations to use for filtering. 
        :type operation: list[str]
        :param cluster: Clusters is the cluster filter. 
        :type cluster: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[AdmissionAudit], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'offset',
            'limit',
            'search',
            'sort',
            'reverse',
            'collections',
            'account_ids',
            'fields',
            '_from',
            'to',
            'namespace',
            'operation',
            'cluster',
            'attack_techniques'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_admission_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'reverse' in local_var_params and local_var_params['reverse'] is not None:  # noqa: E501
            query_params.append(('reverse', local_var_params['reverse']))  # noqa: E501
        if 'collections' in local_var_params and local_var_params['collections'] is not None:  # noqa: E501
            query_params.append(('collections', local_var_params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'account_ids' in local_var_params and local_var_params['account_ids'] is not None:  # noqa: E501
            query_params.append(('accountIDs', local_var_params['account_ids']))  # noqa: E501
            collection_formats['accountIDs'] = 'multi'  # noqa: E501
        if 'fields' in local_var_params and local_var_params['fields'] is not None:  # noqa: E501
            query_params.append(('fields', local_var_params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if '_from' in local_var_params and local_var_params['_from'] is not None:  # noqa: E501
            query_params.append(('from', local_var_params['_from']))  # noqa: E501
        if 'to' in local_var_params and local_var_params['to'] is not None:  # noqa: E501
            query_params.append(('to', local_var_params['to']))  # noqa: E501
        if 'namespace' in local_var_params and local_var_params['namespace'] is not None:  # noqa: E501
            query_params.append(('namespace', local_var_params['namespace']))  # noqa: E501
            collection_formats['namespace'] = 'multi'  # noqa: E501
        if 'operation' in local_var_params and local_var_params['operation'] is not None:  # noqa: E501
            query_params.append(('operation', local_var_params['operation']))  # noqa: E501
            collection_formats['operation'] = 'multi'  # noqa: E501
        if 'cluster' in local_var_params and local_var_params['cluster'] is not None:  # noqa: E501
            query_params.append(('cluster', local_var_params['cluster']))  # noqa: E501
            collection_formats['cluster'] = 'multi'  # noqa: E501
        if 'attack_techniques' in local_var_params and local_var_params['attack_techniques'] is not None:  # noqa: E501
            query_params.append(('attackTechniques', local_var_params['attack_techniques']))  # noqa: E501
            collection_formats['attackTechniques'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "list[AdmissionAudit]",
        }

        return self.api_client.call_api(
            '/api/v1/audits/admission', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_firewall_app_app_embedded_download_get(self, **kwargs):  # noqa: E501
        """api_v1_audits_firewall_app_app_embedded_download_get  # noqa: E501

        DownloadAppEmbeddedAppFirewallAudits downloads the embedded defender firewall audits according to the specified query   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_firewall_app_app_embedded_download_get(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param image_name: Images is the image names filter. 
        :type image_name: list[str]
        :param container_name: Containers is the container names filter. 
        :type container_name: list[str]
        :param hostname: Hosts is the hostnames filter. 
        :type hostname: list[str]
        :param rule_name: RuleNames is the rule names filter. 
        :type rule_name: list[str]
        :param type: Types is the firewall audit type filter. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect. 
        :type effect: str
        :param rule_app_id: RuleAppIDs is the rule app IDs filter. 
        :type rule_app_id: list[str]
        :param function: FunctionName is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param ns: Namespaces is the list of namespaces to use for filtering. 
        :type ns: list[str]
        :param app_id: AppIDs is the app embedded appID filter. 
        :type app_id: list[str]
        :param subnet: Subnets is the source IPs filter. 
        :type subnet: list[str]
        :param connecting_ips: ConnectingIPs is the connecting IPs filter. 
        :type connecting_ips: list[str]
        :param country: Countries is the source IP country filter. 
        :type country: list[str]
        :param user_agent_header: UserAgents is the user agent header filter. 
        :type user_agent_header: list[str]
        :param url: URLs is the URL filter. 
        :type url: list[str]
        :param request_host: RequestHosts is the request host filter. 
        :type request_host: list[str]
        :param url_path: Paths is the URL path filter. 
        :type url_path: list[str]
        :param url_query: Queries is the URL query filter. 
        :type url_query: list[str]
        :param method: Methods is the request method filter. 
        :type method: list[str]
        :param request_header_names: RequestHeaderNames is the request header names filter. 
        :type request_header_names: list[str]
        :param os: OS is the OS filter. 
        :type os: list[str]
        :param msg: Messages is the audit message text filter. 
        :type msg: list[str]
        :param cluster: Cluster is the audit cluster filter. 
        :type cluster: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param protection: Protections is the firewall audit protection type filter. 
        :type protection: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_firewall_app_app_embedded_download_get_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_firewall_app_app_embedded_download_get_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_firewall_app_app_embedded_download_get  # noqa: E501

        DownloadAppEmbeddedAppFirewallAudits downloads the embedded defender firewall audits according to the specified query   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_firewall_app_app_embedded_download_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param image_name: Images is the image names filter. 
        :type image_name: list[str]
        :param container_name: Containers is the container names filter. 
        :type container_name: list[str]
        :param hostname: Hosts is the hostnames filter. 
        :type hostname: list[str]
        :param rule_name: RuleNames is the rule names filter. 
        :type rule_name: list[str]
        :param type: Types is the firewall audit type filter. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect. 
        :type effect: str
        :param rule_app_id: RuleAppIDs is the rule app IDs filter. 
        :type rule_app_id: list[str]
        :param function: FunctionName is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param ns: Namespaces is the list of namespaces to use for filtering. 
        :type ns: list[str]
        :param app_id: AppIDs is the app embedded appID filter. 
        :type app_id: list[str]
        :param subnet: Subnets is the source IPs filter. 
        :type subnet: list[str]
        :param connecting_ips: ConnectingIPs is the connecting IPs filter. 
        :type connecting_ips: list[str]
        :param country: Countries is the source IP country filter. 
        :type country: list[str]
        :param user_agent_header: UserAgents is the user agent header filter. 
        :type user_agent_header: list[str]
        :param url: URLs is the URL filter. 
        :type url: list[str]
        :param request_host: RequestHosts is the request host filter. 
        :type request_host: list[str]
        :param url_path: Paths is the URL path filter. 
        :type url_path: list[str]
        :param url_query: Queries is the URL query filter. 
        :type url_query: list[str]
        :param method: Methods is the request method filter. 
        :type method: list[str]
        :param request_header_names: RequestHeaderNames is the request header names filter. 
        :type request_header_names: list[str]
        :param os: OS is the OS filter. 
        :type os: list[str]
        :param msg: Messages is the audit message text filter. 
        :type msg: list[str]
        :param cluster: Cluster is the audit cluster filter. 
        :type cluster: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param protection: Protections is the firewall audit protection type filter. 
        :type protection: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'offset',
            'limit',
            'search',
            'sort',
            'reverse',
            'collections',
            'account_ids',
            'fields',
            '_from',
            'to',
            'image_name',
            'container_name',
            'hostname',
            'rule_name',
            'type',
            'effect',
            'rule_app_id',
            'function',
            'region',
            'runtime',
            'ns',
            'app_id',
            'subnet',
            'connecting_ips',
            'country',
            'user_agent_header',
            'url',
            'request_host',
            'url_path',
            'url_query',
            'method',
            'request_header_names',
            'os',
            'msg',
            'cluster',
            'attack_techniques',
            'aggregate',
            'protection'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_firewall_app_app_embedded_download_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'reverse' in local_var_params and local_var_params['reverse'] is not None:  # noqa: E501
            query_params.append(('reverse', local_var_params['reverse']))  # noqa: E501
        if 'collections' in local_var_params and local_var_params['collections'] is not None:  # noqa: E501
            query_params.append(('collections', local_var_params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'account_ids' in local_var_params and local_var_params['account_ids'] is not None:  # noqa: E501
            query_params.append(('accountIDs', local_var_params['account_ids']))  # noqa: E501
            collection_formats['accountIDs'] = 'multi'  # noqa: E501
        if 'fields' in local_var_params and local_var_params['fields'] is not None:  # noqa: E501
            query_params.append(('fields', local_var_params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if '_from' in local_var_params and local_var_params['_from'] is not None:  # noqa: E501
            query_params.append(('from', local_var_params['_from']))  # noqa: E501
        if 'to' in local_var_params and local_var_params['to'] is not None:  # noqa: E501
            query_params.append(('to', local_var_params['to']))  # noqa: E501
        if 'image_name' in local_var_params and local_var_params['image_name'] is not None:  # noqa: E501
            query_params.append(('imageName', local_var_params['image_name']))  # noqa: E501
            collection_formats['imageName'] = 'multi'  # noqa: E501
        if 'container_name' in local_var_params and local_var_params['container_name'] is not None:  # noqa: E501
            query_params.append(('containerName', local_var_params['container_name']))  # noqa: E501
            collection_formats['containerName'] = 'multi'  # noqa: E501
        if 'hostname' in local_var_params and local_var_params['hostname'] is not None:  # noqa: E501
            query_params.append(('hostname', local_var_params['hostname']))  # noqa: E501
            collection_formats['hostname'] = 'multi'  # noqa: E501
        if 'rule_name' in local_var_params and local_var_params['rule_name'] is not None:  # noqa: E501
            query_params.append(('ruleName', local_var_params['rule_name']))  # noqa: E501
            collection_formats['ruleName'] = 'multi'  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
            collection_formats['type'] = 'multi'  # noqa: E501
        if 'effect' in local_var_params and local_var_params['effect'] is not None:  # noqa: E501
            query_params.append(('effect', local_var_params['effect']))  # noqa: E501
        if 'rule_app_id' in local_var_params and local_var_params['rule_app_id'] is not None:  # noqa: E501
            query_params.append(('ruleAppID', local_var_params['rule_app_id']))  # noqa: E501
            collection_formats['ruleAppID'] = 'multi'  # noqa: E501
        if 'function' in local_var_params and local_var_params['function'] is not None:  # noqa: E501
            query_params.append(('function', local_var_params['function']))  # noqa: E501
            collection_formats['function'] = 'multi'  # noqa: E501
        if 'region' in local_var_params and local_var_params['region'] is not None:  # noqa: E501
            query_params.append(('region', local_var_params['region']))  # noqa: E501
            collection_formats['region'] = 'multi'  # noqa: E501
        if 'runtime' in local_var_params and local_var_params['runtime'] is not None:  # noqa: E501
            query_params.append(('runtime', local_var_params['runtime']))  # noqa: E501
            collection_formats['runtime'] = 'multi'  # noqa: E501
        if 'ns' in local_var_params and local_var_params['ns'] is not None:  # noqa: E501
            query_params.append(('ns', local_var_params['ns']))  # noqa: E501
            collection_formats['ns'] = 'multi'  # noqa: E501
        if 'app_id' in local_var_params and local_var_params['app_id'] is not None:  # noqa: E501
            query_params.append(('appID', local_var_params['app_id']))  # noqa: E501
            collection_formats['appID'] = 'multi'  # noqa: E501
        if 'subnet' in local_var_params and local_var_params['subnet'] is not None:  # noqa: E501
            query_params.append(('subnet', local_var_params['subnet']))  # noqa: E501
            collection_formats['subnet'] = 'multi'  # noqa: E501
        if 'connecting_ips' in local_var_params and local_var_params['connecting_ips'] is not None:  # noqa: E501
            query_params.append(('connectingIPs', local_var_params['connecting_ips']))  # noqa: E501
            collection_formats['connectingIPs'] = 'multi'  # noqa: E501
        if 'country' in local_var_params and local_var_params['country'] is not None:  # noqa: E501
            query_params.append(('country', local_var_params['country']))  # noqa: E501
            collection_formats['country'] = 'multi'  # noqa: E501
        if 'user_agent_header' in local_var_params and local_var_params['user_agent_header'] is not None:  # noqa: E501
            query_params.append(('userAgentHeader', local_var_params['user_agent_header']))  # noqa: E501
            collection_formats['userAgentHeader'] = 'multi'  # noqa: E501
        if 'url' in local_var_params and local_var_params['url'] is not None:  # noqa: E501
            query_params.append(('url', local_var_params['url']))  # noqa: E501
            collection_formats['url'] = 'multi'  # noqa: E501
        if 'request_host' in local_var_params and local_var_params['request_host'] is not None:  # noqa: E501
            query_params.append(('requestHost', local_var_params['request_host']))  # noqa: E501
            collection_formats['requestHost'] = 'multi'  # noqa: E501
        if 'url_path' in local_var_params and local_var_params['url_path'] is not None:  # noqa: E501
            query_params.append(('urlPath', local_var_params['url_path']))  # noqa: E501
            collection_formats['urlPath'] = 'multi'  # noqa: E501
        if 'url_query' in local_var_params and local_var_params['url_query'] is not None:  # noqa: E501
            query_params.append(('urlQuery', local_var_params['url_query']))  # noqa: E501
            collection_formats['urlQuery'] = 'multi'  # noqa: E501
        if 'method' in local_var_params and local_var_params['method'] is not None:  # noqa: E501
            query_params.append(('method', local_var_params['method']))  # noqa: E501
            collection_formats['method'] = 'multi'  # noqa: E501
        if 'request_header_names' in local_var_params and local_var_params['request_header_names'] is not None:  # noqa: E501
            query_params.append(('requestHeaderNames', local_var_params['request_header_names']))  # noqa: E501
            collection_formats['requestHeaderNames'] = 'multi'  # noqa: E501
        if 'os' in local_var_params and local_var_params['os'] is not None:  # noqa: E501
            query_params.append(('os', local_var_params['os']))  # noqa: E501
            collection_formats['os'] = 'multi'  # noqa: E501
        if 'msg' in local_var_params and local_var_params['msg'] is not None:  # noqa: E501
            query_params.append(('msg', local_var_params['msg']))  # noqa: E501
            collection_formats['msg'] = 'multi'  # noqa: E501
        if 'cluster' in local_var_params and local_var_params['cluster'] is not None:  # noqa: E501
            query_params.append(('cluster', local_var_params['cluster']))  # noqa: E501
            collection_formats['cluster'] = 'multi'  # noqa: E501
        if 'attack_techniques' in local_var_params and local_var_params['attack_techniques'] is not None:  # noqa: E501
            query_params.append(('attackTechniques', local_var_params['attack_techniques']))  # noqa: E501
            collection_formats['attackTechniques'] = 'multi'  # noqa: E501
        if 'aggregate' in local_var_params and local_var_params['aggregate'] is not None:  # noqa: E501
            query_params.append(('aggregate', local_var_params['aggregate']))  # noqa: E501
        if 'protection' in local_var_params and local_var_params['protection'] is not None:  # noqa: E501
            query_params.append(('protection', local_var_params['protection']))  # noqa: E501
            collection_formats['protection'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/audits/firewall/app/app-embedded/download', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_firewall_app_app_embedded_get(self, **kwargs):  # noqa: E501
        """api_v1_audits_firewall_app_app_embedded_get  # noqa: E501

        AppEmbeddedAppFirewallAudits returns all embedded defender firewall audits according to the query specification   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_firewall_app_app_embedded_get(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param image_name: Images is the image names filter. 
        :type image_name: list[str]
        :param container_name: Containers is the container names filter. 
        :type container_name: list[str]
        :param hostname: Hosts is the hostnames filter. 
        :type hostname: list[str]
        :param rule_name: RuleNames is the rule names filter. 
        :type rule_name: list[str]
        :param type: Types is the firewall audit type filter. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect. 
        :type effect: str
        :param rule_app_id: RuleAppIDs is the rule app IDs filter. 
        :type rule_app_id: list[str]
        :param function: FunctionName is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param ns: Namespaces is the list of namespaces to use for filtering. 
        :type ns: list[str]
        :param app_id: AppIDs is the app embedded appID filter. 
        :type app_id: list[str]
        :param subnet: Subnets is the source IPs filter. 
        :type subnet: list[str]
        :param connecting_ips: ConnectingIPs is the connecting IPs filter. 
        :type connecting_ips: list[str]
        :param country: Countries is the source IP country filter. 
        :type country: list[str]
        :param user_agent_header: UserAgents is the user agent header filter. 
        :type user_agent_header: list[str]
        :param url: URLs is the URL filter. 
        :type url: list[str]
        :param request_host: RequestHosts is the request host filter. 
        :type request_host: list[str]
        :param url_path: Paths is the URL path filter. 
        :type url_path: list[str]
        :param url_query: Queries is the URL query filter. 
        :type url_query: list[str]
        :param method: Methods is the request method filter. 
        :type method: list[str]
        :param request_header_names: RequestHeaderNames is the request header names filter. 
        :type request_header_names: list[str]
        :param os: OS is the OS filter. 
        :type os: list[str]
        :param msg: Messages is the audit message text filter. 
        :type msg: list[str]
        :param cluster: Cluster is the audit cluster filter. 
        :type cluster: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param protection: Protections is the firewall audit protection type filter. 
        :type protection: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[SharedAppFirewallAudit]
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_firewall_app_app_embedded_get_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_firewall_app_app_embedded_get_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_firewall_app_app_embedded_get  # noqa: E501

        AppEmbeddedAppFirewallAudits returns all embedded defender firewall audits according to the query specification   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_firewall_app_app_embedded_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param image_name: Images is the image names filter. 
        :type image_name: list[str]
        :param container_name: Containers is the container names filter. 
        :type container_name: list[str]
        :param hostname: Hosts is the hostnames filter. 
        :type hostname: list[str]
        :param rule_name: RuleNames is the rule names filter. 
        :type rule_name: list[str]
        :param type: Types is the firewall audit type filter. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect. 
        :type effect: str
        :param rule_app_id: RuleAppIDs is the rule app IDs filter. 
        :type rule_app_id: list[str]
        :param function: FunctionName is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param ns: Namespaces is the list of namespaces to use for filtering. 
        :type ns: list[str]
        :param app_id: AppIDs is the app embedded appID filter. 
        :type app_id: list[str]
        :param subnet: Subnets is the source IPs filter. 
        :type subnet: list[str]
        :param connecting_ips: ConnectingIPs is the connecting IPs filter. 
        :type connecting_ips: list[str]
        :param country: Countries is the source IP country filter. 
        :type country: list[str]
        :param user_agent_header: UserAgents is the user agent header filter. 
        :type user_agent_header: list[str]
        :param url: URLs is the URL filter. 
        :type url: list[str]
        :param request_host: RequestHosts is the request host filter. 
        :type request_host: list[str]
        :param url_path: Paths is the URL path filter. 
        :type url_path: list[str]
        :param url_query: Queries is the URL query filter. 
        :type url_query: list[str]
        :param method: Methods is the request method filter. 
        :type method: list[str]
        :param request_header_names: RequestHeaderNames is the request header names filter. 
        :type request_header_names: list[str]
        :param os: OS is the OS filter. 
        :type os: list[str]
        :param msg: Messages is the audit message text filter. 
        :type msg: list[str]
        :param cluster: Cluster is the audit cluster filter. 
        :type cluster: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param protection: Protections is the firewall audit protection type filter. 
        :type protection: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[SharedAppFirewallAudit], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'offset',
            'limit',
            'search',
            'sort',
            'reverse',
            'collections',
            'account_ids',
            'fields',
            '_from',
            'to',
            'image_name',
            'container_name',
            'hostname',
            'rule_name',
            'type',
            'effect',
            'rule_app_id',
            'function',
            'region',
            'runtime',
            'ns',
            'app_id',
            'subnet',
            'connecting_ips',
            'country',
            'user_agent_header',
            'url',
            'request_host',
            'url_path',
            'url_query',
            'method',
            'request_header_names',
            'os',
            'msg',
            'cluster',
            'attack_techniques',
            'aggregate',
            'protection'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_firewall_app_app_embedded_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'reverse' in local_var_params and local_var_params['reverse'] is not None:  # noqa: E501
            query_params.append(('reverse', local_var_params['reverse']))  # noqa: E501
        if 'collections' in local_var_params and local_var_params['collections'] is not None:  # noqa: E501
            query_params.append(('collections', local_var_params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'account_ids' in local_var_params and local_var_params['account_ids'] is not None:  # noqa: E501
            query_params.append(('accountIDs', local_var_params['account_ids']))  # noqa: E501
            collection_formats['accountIDs'] = 'multi'  # noqa: E501
        if 'fields' in local_var_params and local_var_params['fields'] is not None:  # noqa: E501
            query_params.append(('fields', local_var_params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if '_from' in local_var_params and local_var_params['_from'] is not None:  # noqa: E501
            query_params.append(('from', local_var_params['_from']))  # noqa: E501
        if 'to' in local_var_params and local_var_params['to'] is not None:  # noqa: E501
            query_params.append(('to', local_var_params['to']))  # noqa: E501
        if 'image_name' in local_var_params and local_var_params['image_name'] is not None:  # noqa: E501
            query_params.append(('imageName', local_var_params['image_name']))  # noqa: E501
            collection_formats['imageName'] = 'multi'  # noqa: E501
        if 'container_name' in local_var_params and local_var_params['container_name'] is not None:  # noqa: E501
            query_params.append(('containerName', local_var_params['container_name']))  # noqa: E501
            collection_formats['containerName'] = 'multi'  # noqa: E501
        if 'hostname' in local_var_params and local_var_params['hostname'] is not None:  # noqa: E501
            query_params.append(('hostname', local_var_params['hostname']))  # noqa: E501
            collection_formats['hostname'] = 'multi'  # noqa: E501
        if 'rule_name' in local_var_params and local_var_params['rule_name'] is not None:  # noqa: E501
            query_params.append(('ruleName', local_var_params['rule_name']))  # noqa: E501
            collection_formats['ruleName'] = 'multi'  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
            collection_formats['type'] = 'multi'  # noqa: E501
        if 'effect' in local_var_params and local_var_params['effect'] is not None:  # noqa: E501
            query_params.append(('effect', local_var_params['effect']))  # noqa: E501
        if 'rule_app_id' in local_var_params and local_var_params['rule_app_id'] is not None:  # noqa: E501
            query_params.append(('ruleAppID', local_var_params['rule_app_id']))  # noqa: E501
            collection_formats['ruleAppID'] = 'multi'  # noqa: E501
        if 'function' in local_var_params and local_var_params['function'] is not None:  # noqa: E501
            query_params.append(('function', local_var_params['function']))  # noqa: E501
            collection_formats['function'] = 'multi'  # noqa: E501
        if 'region' in local_var_params and local_var_params['region'] is not None:  # noqa: E501
            query_params.append(('region', local_var_params['region']))  # noqa: E501
            collection_formats['region'] = 'multi'  # noqa: E501
        if 'runtime' in local_var_params and local_var_params['runtime'] is not None:  # noqa: E501
            query_params.append(('runtime', local_var_params['runtime']))  # noqa: E501
            collection_formats['runtime'] = 'multi'  # noqa: E501
        if 'ns' in local_var_params and local_var_params['ns'] is not None:  # noqa: E501
            query_params.append(('ns', local_var_params['ns']))  # noqa: E501
            collection_formats['ns'] = 'multi'  # noqa: E501
        if 'app_id' in local_var_params and local_var_params['app_id'] is not None:  # noqa: E501
            query_params.append(('appID', local_var_params['app_id']))  # noqa: E501
            collection_formats['appID'] = 'multi'  # noqa: E501
        if 'subnet' in local_var_params and local_var_params['subnet'] is not None:  # noqa: E501
            query_params.append(('subnet', local_var_params['subnet']))  # noqa: E501
            collection_formats['subnet'] = 'multi'  # noqa: E501
        if 'connecting_ips' in local_var_params and local_var_params['connecting_ips'] is not None:  # noqa: E501
            query_params.append(('connectingIPs', local_var_params['connecting_ips']))  # noqa: E501
            collection_formats['connectingIPs'] = 'multi'  # noqa: E501
        if 'country' in local_var_params and local_var_params['country'] is not None:  # noqa: E501
            query_params.append(('country', local_var_params['country']))  # noqa: E501
            collection_formats['country'] = 'multi'  # noqa: E501
        if 'user_agent_header' in local_var_params and local_var_params['user_agent_header'] is not None:  # noqa: E501
            query_params.append(('userAgentHeader', local_var_params['user_agent_header']))  # noqa: E501
            collection_formats['userAgentHeader'] = 'multi'  # noqa: E501
        if 'url' in local_var_params and local_var_params['url'] is not None:  # noqa: E501
            query_params.append(('url', local_var_params['url']))  # noqa: E501
            collection_formats['url'] = 'multi'  # noqa: E501
        if 'request_host' in local_var_params and local_var_params['request_host'] is not None:  # noqa: E501
            query_params.append(('requestHost', local_var_params['request_host']))  # noqa: E501
            collection_formats['requestHost'] = 'multi'  # noqa: E501
        if 'url_path' in local_var_params and local_var_params['url_path'] is not None:  # noqa: E501
            query_params.append(('urlPath', local_var_params['url_path']))  # noqa: E501
            collection_formats['urlPath'] = 'multi'  # noqa: E501
        if 'url_query' in local_var_params and local_var_params['url_query'] is not None:  # noqa: E501
            query_params.append(('urlQuery', local_var_params['url_query']))  # noqa: E501
            collection_formats['urlQuery'] = 'multi'  # noqa: E501
        if 'method' in local_var_params and local_var_params['method'] is not None:  # noqa: E501
            query_params.append(('method', local_var_params['method']))  # noqa: E501
            collection_formats['method'] = 'multi'  # noqa: E501
        if 'request_header_names' in local_var_params and local_var_params['request_header_names'] is not None:  # noqa: E501
            query_params.append(('requestHeaderNames', local_var_params['request_header_names']))  # noqa: E501
            collection_formats['requestHeaderNames'] = 'multi'  # noqa: E501
        if 'os' in local_var_params and local_var_params['os'] is not None:  # noqa: E501
            query_params.append(('os', local_var_params['os']))  # noqa: E501
            collection_formats['os'] = 'multi'  # noqa: E501
        if 'msg' in local_var_params and local_var_params['msg'] is not None:  # noqa: E501
            query_params.append(('msg', local_var_params['msg']))  # noqa: E501
            collection_formats['msg'] = 'multi'  # noqa: E501
        if 'cluster' in local_var_params and local_var_params['cluster'] is not None:  # noqa: E501
            query_params.append(('cluster', local_var_params['cluster']))  # noqa: E501
            collection_formats['cluster'] = 'multi'  # noqa: E501
        if 'attack_techniques' in local_var_params and local_var_params['attack_techniques'] is not None:  # noqa: E501
            query_params.append(('attackTechniques', local_var_params['attack_techniques']))  # noqa: E501
            collection_formats['attackTechniques'] = 'multi'  # noqa: E501
        if 'aggregate' in local_var_params and local_var_params['aggregate'] is not None:  # noqa: E501
            query_params.append(('aggregate', local_var_params['aggregate']))  # noqa: E501
        if 'protection' in local_var_params and local_var_params['protection'] is not None:  # noqa: E501
            query_params.append(('protection', local_var_params['protection']))  # noqa: E501
            collection_formats['protection'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "list[SharedAppFirewallAudit]",
        }

        return self.api_client.call_api(
            '/api/v1/audits/firewall/app/app-embedded', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_firewall_app_app_embedded_timeslice_get(self, **kwargs):  # noqa: E501
        """api_v1_audits_firewall_app_app_embedded_timeslice_get  # noqa: E501

        AppEmbeddedAppFirewallAuditTimeslice returns embedded firewall audit buckets according to the query timeframe   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_firewall_app_app_embedded_timeslice_get(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param image_name: Images is the image names filter. 
        :type image_name: list[str]
        :param container_name: Containers is the container names filter. 
        :type container_name: list[str]
        :param hostname: Hosts is the hostnames filter. 
        :type hostname: list[str]
        :param rule_name: RuleNames is the rule names filter. 
        :type rule_name: list[str]
        :param type: Types is the firewall audit type filter. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect. 
        :type effect: str
        :param rule_app_id: RuleAppIDs is the rule app IDs filter. 
        :type rule_app_id: list[str]
        :param function: FunctionName is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param ns: Namespaces is the list of namespaces to use for filtering. 
        :type ns: list[str]
        :param app_id: AppIDs is the app embedded appID filter. 
        :type app_id: list[str]
        :param subnet: Subnets is the source IPs filter. 
        :type subnet: list[str]
        :param connecting_ips: ConnectingIPs is the connecting IPs filter. 
        :type connecting_ips: list[str]
        :param country: Countries is the source IP country filter. 
        :type country: list[str]
        :param user_agent_header: UserAgents is the user agent header filter. 
        :type user_agent_header: list[str]
        :param url: URLs is the URL filter. 
        :type url: list[str]
        :param request_host: RequestHosts is the request host filter. 
        :type request_host: list[str]
        :param url_path: Paths is the URL path filter. 
        :type url_path: list[str]
        :param url_query: Queries is the URL query filter. 
        :type url_query: list[str]
        :param method: Methods is the request method filter. 
        :type method: list[str]
        :param request_header_names: RequestHeaderNames is the request header names filter. 
        :type request_header_names: list[str]
        :param os: OS is the OS filter. 
        :type os: list[str]
        :param msg: Messages is the audit message text filter. 
        :type msg: list[str]
        :param cluster: Cluster is the audit cluster filter. 
        :type cluster: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param protection: Protections is the firewall audit protection type filter. 
        :type protection: list[str]
        :param buckets: Buckets is the number of buckets to return. 
        :type buckets: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[TypesAuditTimeslice]
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_firewall_app_app_embedded_timeslice_get_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_firewall_app_app_embedded_timeslice_get_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_firewall_app_app_embedded_timeslice_get  # noqa: E501

        AppEmbeddedAppFirewallAuditTimeslice returns embedded firewall audit buckets according to the query timeframe   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_firewall_app_app_embedded_timeslice_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param image_name: Images is the image names filter. 
        :type image_name: list[str]
        :param container_name: Containers is the container names filter. 
        :type container_name: list[str]
        :param hostname: Hosts is the hostnames filter. 
        :type hostname: list[str]
        :param rule_name: RuleNames is the rule names filter. 
        :type rule_name: list[str]
        :param type: Types is the firewall audit type filter. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect. 
        :type effect: str
        :param rule_app_id: RuleAppIDs is the rule app IDs filter. 
        :type rule_app_id: list[str]
        :param function: FunctionName is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param ns: Namespaces is the list of namespaces to use for filtering. 
        :type ns: list[str]
        :param app_id: AppIDs is the app embedded appID filter. 
        :type app_id: list[str]
        :param subnet: Subnets is the source IPs filter. 
        :type subnet: list[str]
        :param connecting_ips: ConnectingIPs is the connecting IPs filter. 
        :type connecting_ips: list[str]
        :param country: Countries is the source IP country filter. 
        :type country: list[str]
        :param user_agent_header: UserAgents is the user agent header filter. 
        :type user_agent_header: list[str]
        :param url: URLs is the URL filter. 
        :type url: list[str]
        :param request_host: RequestHosts is the request host filter. 
        :type request_host: list[str]
        :param url_path: Paths is the URL path filter. 
        :type url_path: list[str]
        :param url_query: Queries is the URL query filter. 
        :type url_query: list[str]
        :param method: Methods is the request method filter. 
        :type method: list[str]
        :param request_header_names: RequestHeaderNames is the request header names filter. 
        :type request_header_names: list[str]
        :param os: OS is the OS filter. 
        :type os: list[str]
        :param msg: Messages is the audit message text filter. 
        :type msg: list[str]
        :param cluster: Cluster is the audit cluster filter. 
        :type cluster: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param protection: Protections is the firewall audit protection type filter. 
        :type protection: list[str]
        :param buckets: Buckets is the number of buckets to return. 
        :type buckets: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[TypesAuditTimeslice], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'offset',
            'limit',
            'search',
            'sort',
            'reverse',
            'collections',
            'account_ids',
            'fields',
            '_from',
            'to',
            'image_name',
            'container_name',
            'hostname',
            'rule_name',
            'type',
            'effect',
            'rule_app_id',
            'function',
            'region',
            'runtime',
            'ns',
            'app_id',
            'subnet',
            'connecting_ips',
            'country',
            'user_agent_header',
            'url',
            'request_host',
            'url_path',
            'url_query',
            'method',
            'request_header_names',
            'os',
            'msg',
            'cluster',
            'attack_techniques',
            'aggregate',
            'protection',
            'buckets'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_firewall_app_app_embedded_timeslice_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'reverse' in local_var_params and local_var_params['reverse'] is not None:  # noqa: E501
            query_params.append(('reverse', local_var_params['reverse']))  # noqa: E501
        if 'collections' in local_var_params and local_var_params['collections'] is not None:  # noqa: E501
            query_params.append(('collections', local_var_params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'account_ids' in local_var_params and local_var_params['account_ids'] is not None:  # noqa: E501
            query_params.append(('accountIDs', local_var_params['account_ids']))  # noqa: E501
            collection_formats['accountIDs'] = 'multi'  # noqa: E501
        if 'fields' in local_var_params and local_var_params['fields'] is not None:  # noqa: E501
            query_params.append(('fields', local_var_params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if '_from' in local_var_params and local_var_params['_from'] is not None:  # noqa: E501
            query_params.append(('from', local_var_params['_from']))  # noqa: E501
        if 'to' in local_var_params and local_var_params['to'] is not None:  # noqa: E501
            query_params.append(('to', local_var_params['to']))  # noqa: E501
        if 'image_name' in local_var_params and local_var_params['image_name'] is not None:  # noqa: E501
            query_params.append(('imageName', local_var_params['image_name']))  # noqa: E501
            collection_formats['imageName'] = 'multi'  # noqa: E501
        if 'container_name' in local_var_params and local_var_params['container_name'] is not None:  # noqa: E501
            query_params.append(('containerName', local_var_params['container_name']))  # noqa: E501
            collection_formats['containerName'] = 'multi'  # noqa: E501
        if 'hostname' in local_var_params and local_var_params['hostname'] is not None:  # noqa: E501
            query_params.append(('hostname', local_var_params['hostname']))  # noqa: E501
            collection_formats['hostname'] = 'multi'  # noqa: E501
        if 'rule_name' in local_var_params and local_var_params['rule_name'] is not None:  # noqa: E501
            query_params.append(('ruleName', local_var_params['rule_name']))  # noqa: E501
            collection_formats['ruleName'] = 'multi'  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
            collection_formats['type'] = 'multi'  # noqa: E501
        if 'effect' in local_var_params and local_var_params['effect'] is not None:  # noqa: E501
            query_params.append(('effect', local_var_params['effect']))  # noqa: E501
        if 'rule_app_id' in local_var_params and local_var_params['rule_app_id'] is not None:  # noqa: E501
            query_params.append(('ruleAppID', local_var_params['rule_app_id']))  # noqa: E501
            collection_formats['ruleAppID'] = 'multi'  # noqa: E501
        if 'function' in local_var_params and local_var_params['function'] is not None:  # noqa: E501
            query_params.append(('function', local_var_params['function']))  # noqa: E501
            collection_formats['function'] = 'multi'  # noqa: E501
        if 'region' in local_var_params and local_var_params['region'] is not None:  # noqa: E501
            query_params.append(('region', local_var_params['region']))  # noqa: E501
            collection_formats['region'] = 'multi'  # noqa: E501
        if 'runtime' in local_var_params and local_var_params['runtime'] is not None:  # noqa: E501
            query_params.append(('runtime', local_var_params['runtime']))  # noqa: E501
            collection_formats['runtime'] = 'multi'  # noqa: E501
        if 'ns' in local_var_params and local_var_params['ns'] is not None:  # noqa: E501
            query_params.append(('ns', local_var_params['ns']))  # noqa: E501
            collection_formats['ns'] = 'multi'  # noqa: E501
        if 'app_id' in local_var_params and local_var_params['app_id'] is not None:  # noqa: E501
            query_params.append(('appID', local_var_params['app_id']))  # noqa: E501
            collection_formats['appID'] = 'multi'  # noqa: E501
        if 'subnet' in local_var_params and local_var_params['subnet'] is not None:  # noqa: E501
            query_params.append(('subnet', local_var_params['subnet']))  # noqa: E501
            collection_formats['subnet'] = 'multi'  # noqa: E501
        if 'connecting_ips' in local_var_params and local_var_params['connecting_ips'] is not None:  # noqa: E501
            query_params.append(('connectingIPs', local_var_params['connecting_ips']))  # noqa: E501
            collection_formats['connectingIPs'] = 'multi'  # noqa: E501
        if 'country' in local_var_params and local_var_params['country'] is not None:  # noqa: E501
            query_params.append(('country', local_var_params['country']))  # noqa: E501
            collection_formats['country'] = 'multi'  # noqa: E501
        if 'user_agent_header' in local_var_params and local_var_params['user_agent_header'] is not None:  # noqa: E501
            query_params.append(('userAgentHeader', local_var_params['user_agent_header']))  # noqa: E501
            collection_formats['userAgentHeader'] = 'multi'  # noqa: E501
        if 'url' in local_var_params and local_var_params['url'] is not None:  # noqa: E501
            query_params.append(('url', local_var_params['url']))  # noqa: E501
            collection_formats['url'] = 'multi'  # noqa: E501
        if 'request_host' in local_var_params and local_var_params['request_host'] is not None:  # noqa: E501
            query_params.append(('requestHost', local_var_params['request_host']))  # noqa: E501
            collection_formats['requestHost'] = 'multi'  # noqa: E501
        if 'url_path' in local_var_params and local_var_params['url_path'] is not None:  # noqa: E501
            query_params.append(('urlPath', local_var_params['url_path']))  # noqa: E501
            collection_formats['urlPath'] = 'multi'  # noqa: E501
        if 'url_query' in local_var_params and local_var_params['url_query'] is not None:  # noqa: E501
            query_params.append(('urlQuery', local_var_params['url_query']))  # noqa: E501
            collection_formats['urlQuery'] = 'multi'  # noqa: E501
        if 'method' in local_var_params and local_var_params['method'] is not None:  # noqa: E501
            query_params.append(('method', local_var_params['method']))  # noqa: E501
            collection_formats['method'] = 'multi'  # noqa: E501
        if 'request_header_names' in local_var_params and local_var_params['request_header_names'] is not None:  # noqa: E501
            query_params.append(('requestHeaderNames', local_var_params['request_header_names']))  # noqa: E501
            collection_formats['requestHeaderNames'] = 'multi'  # noqa: E501
        if 'os' in local_var_params and local_var_params['os'] is not None:  # noqa: E501
            query_params.append(('os', local_var_params['os']))  # noqa: E501
            collection_formats['os'] = 'multi'  # noqa: E501
        if 'msg' in local_var_params and local_var_params['msg'] is not None:  # noqa: E501
            query_params.append(('msg', local_var_params['msg']))  # noqa: E501
            collection_formats['msg'] = 'multi'  # noqa: E501
        if 'cluster' in local_var_params and local_var_params['cluster'] is not None:  # noqa: E501
            query_params.append(('cluster', local_var_params['cluster']))  # noqa: E501
            collection_formats['cluster'] = 'multi'  # noqa: E501
        if 'attack_techniques' in local_var_params and local_var_params['attack_techniques'] is not None:  # noqa: E501
            query_params.append(('attackTechniques', local_var_params['attack_techniques']))  # noqa: E501
            collection_formats['attackTechniques'] = 'multi'  # noqa: E501
        if 'aggregate' in local_var_params and local_var_params['aggregate'] is not None:  # noqa: E501
            query_params.append(('aggregate', local_var_params['aggregate']))  # noqa: E501
        if 'protection' in local_var_params and local_var_params['protection'] is not None:  # noqa: E501
            query_params.append(('protection', local_var_params['protection']))  # noqa: E501
            collection_formats['protection'] = 'multi'  # noqa: E501
        if 'buckets' in local_var_params and local_var_params['buckets'] is not None:  # noqa: E501
            query_params.append(('buckets', local_var_params['buckets']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "list[TypesAuditTimeslice]",
        }

        return self.api_client.call_api(
            '/api/v1/audits/firewall/app/app-embedded/timeslice', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_firewall_app_container_download_get(self, **kwargs):  # noqa: E501
        """api_v1_audits_firewall_app_container_download_get  # noqa: E501

        DownloadContainerAppFirewallAudits downloads the container firewall audits according to the specified query   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_firewall_app_container_download_get(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param image_name: Images is the image names filter. 
        :type image_name: list[str]
        :param container_name: Containers is the container names filter. 
        :type container_name: list[str]
        :param hostname: Hosts is the hostnames filter. 
        :type hostname: list[str]
        :param rule_name: RuleNames is the rule names filter. 
        :type rule_name: list[str]
        :param type: Types is the firewall audit type filter. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect. 
        :type effect: str
        :param rule_app_id: RuleAppIDs is the rule app IDs filter. 
        :type rule_app_id: list[str]
        :param function: FunctionName is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param ns: Namespaces is the list of namespaces to use for filtering. 
        :type ns: list[str]
        :param app_id: AppIDs is the app embedded appID filter. 
        :type app_id: list[str]
        :param subnet: Subnets is the source IPs filter. 
        :type subnet: list[str]
        :param connecting_ips: ConnectingIPs is the connecting IPs filter. 
        :type connecting_ips: list[str]
        :param country: Countries is the source IP country filter. 
        :type country: list[str]
        :param user_agent_header: UserAgents is the user agent header filter. 
        :type user_agent_header: list[str]
        :param url: URLs is the URL filter. 
        :type url: list[str]
        :param request_host: RequestHosts is the request host filter. 
        :type request_host: list[str]
        :param url_path: Paths is the URL path filter. 
        :type url_path: list[str]
        :param url_query: Queries is the URL query filter. 
        :type url_query: list[str]
        :param method: Methods is the request method filter. 
        :type method: list[str]
        :param request_header_names: RequestHeaderNames is the request header names filter. 
        :type request_header_names: list[str]
        :param os: OS is the OS filter. 
        :type os: list[str]
        :param msg: Messages is the audit message text filter. 
        :type msg: list[str]
        :param cluster: Cluster is the audit cluster filter. 
        :type cluster: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param protection: Protections is the firewall audit protection type filter. 
        :type protection: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_firewall_app_container_download_get_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_firewall_app_container_download_get_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_firewall_app_container_download_get  # noqa: E501

        DownloadContainerAppFirewallAudits downloads the container firewall audits according to the specified query   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_firewall_app_container_download_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param image_name: Images is the image names filter. 
        :type image_name: list[str]
        :param container_name: Containers is the container names filter. 
        :type container_name: list[str]
        :param hostname: Hosts is the hostnames filter. 
        :type hostname: list[str]
        :param rule_name: RuleNames is the rule names filter. 
        :type rule_name: list[str]
        :param type: Types is the firewall audit type filter. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect. 
        :type effect: str
        :param rule_app_id: RuleAppIDs is the rule app IDs filter. 
        :type rule_app_id: list[str]
        :param function: FunctionName is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param ns: Namespaces is the list of namespaces to use for filtering. 
        :type ns: list[str]
        :param app_id: AppIDs is the app embedded appID filter. 
        :type app_id: list[str]
        :param subnet: Subnets is the source IPs filter. 
        :type subnet: list[str]
        :param connecting_ips: ConnectingIPs is the connecting IPs filter. 
        :type connecting_ips: list[str]
        :param country: Countries is the source IP country filter. 
        :type country: list[str]
        :param user_agent_header: UserAgents is the user agent header filter. 
        :type user_agent_header: list[str]
        :param url: URLs is the URL filter. 
        :type url: list[str]
        :param request_host: RequestHosts is the request host filter. 
        :type request_host: list[str]
        :param url_path: Paths is the URL path filter. 
        :type url_path: list[str]
        :param url_query: Queries is the URL query filter. 
        :type url_query: list[str]
        :param method: Methods is the request method filter. 
        :type method: list[str]
        :param request_header_names: RequestHeaderNames is the request header names filter. 
        :type request_header_names: list[str]
        :param os: OS is the OS filter. 
        :type os: list[str]
        :param msg: Messages is the audit message text filter. 
        :type msg: list[str]
        :param cluster: Cluster is the audit cluster filter. 
        :type cluster: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param protection: Protections is the firewall audit protection type filter. 
        :type protection: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'offset',
            'limit',
            'search',
            'sort',
            'reverse',
            'collections',
            'account_ids',
            'fields',
            '_from',
            'to',
            'image_name',
            'container_name',
            'hostname',
            'rule_name',
            'type',
            'effect',
            'rule_app_id',
            'function',
            'region',
            'runtime',
            'ns',
            'app_id',
            'subnet',
            'connecting_ips',
            'country',
            'user_agent_header',
            'url',
            'request_host',
            'url_path',
            'url_query',
            'method',
            'request_header_names',
            'os',
            'msg',
            'cluster',
            'attack_techniques',
            'aggregate',
            'protection'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_firewall_app_container_download_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'reverse' in local_var_params and local_var_params['reverse'] is not None:  # noqa: E501
            query_params.append(('reverse', local_var_params['reverse']))  # noqa: E501
        if 'collections' in local_var_params and local_var_params['collections'] is not None:  # noqa: E501
            query_params.append(('collections', local_var_params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'account_ids' in local_var_params and local_var_params['account_ids'] is not None:  # noqa: E501
            query_params.append(('accountIDs', local_var_params['account_ids']))  # noqa: E501
            collection_formats['accountIDs'] = 'multi'  # noqa: E501
        if 'fields' in local_var_params and local_var_params['fields'] is not None:  # noqa: E501
            query_params.append(('fields', local_var_params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if '_from' in local_var_params and local_var_params['_from'] is not None:  # noqa: E501
            query_params.append(('from', local_var_params['_from']))  # noqa: E501
        if 'to' in local_var_params and local_var_params['to'] is not None:  # noqa: E501
            query_params.append(('to', local_var_params['to']))  # noqa: E501
        if 'image_name' in local_var_params and local_var_params['image_name'] is not None:  # noqa: E501
            query_params.append(('imageName', local_var_params['image_name']))  # noqa: E501
            collection_formats['imageName'] = 'multi'  # noqa: E501
        if 'container_name' in local_var_params and local_var_params['container_name'] is not None:  # noqa: E501
            query_params.append(('containerName', local_var_params['container_name']))  # noqa: E501
            collection_formats['containerName'] = 'multi'  # noqa: E501
        if 'hostname' in local_var_params and local_var_params['hostname'] is not None:  # noqa: E501
            query_params.append(('hostname', local_var_params['hostname']))  # noqa: E501
            collection_formats['hostname'] = 'multi'  # noqa: E501
        if 'rule_name' in local_var_params and local_var_params['rule_name'] is not None:  # noqa: E501
            query_params.append(('ruleName', local_var_params['rule_name']))  # noqa: E501
            collection_formats['ruleName'] = 'multi'  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
            collection_formats['type'] = 'multi'  # noqa: E501
        if 'effect' in local_var_params and local_var_params['effect'] is not None:  # noqa: E501
            query_params.append(('effect', local_var_params['effect']))  # noqa: E501
        if 'rule_app_id' in local_var_params and local_var_params['rule_app_id'] is not None:  # noqa: E501
            query_params.append(('ruleAppID', local_var_params['rule_app_id']))  # noqa: E501
            collection_formats['ruleAppID'] = 'multi'  # noqa: E501
        if 'function' in local_var_params and local_var_params['function'] is not None:  # noqa: E501
            query_params.append(('function', local_var_params['function']))  # noqa: E501
            collection_formats['function'] = 'multi'  # noqa: E501
        if 'region' in local_var_params and local_var_params['region'] is not None:  # noqa: E501
            query_params.append(('region', local_var_params['region']))  # noqa: E501
            collection_formats['region'] = 'multi'  # noqa: E501
        if 'runtime' in local_var_params and local_var_params['runtime'] is not None:  # noqa: E501
            query_params.append(('runtime', local_var_params['runtime']))  # noqa: E501
            collection_formats['runtime'] = 'multi'  # noqa: E501
        if 'ns' in local_var_params and local_var_params['ns'] is not None:  # noqa: E501
            query_params.append(('ns', local_var_params['ns']))  # noqa: E501
            collection_formats['ns'] = 'multi'  # noqa: E501
        if 'app_id' in local_var_params and local_var_params['app_id'] is not None:  # noqa: E501
            query_params.append(('appID', local_var_params['app_id']))  # noqa: E501
            collection_formats['appID'] = 'multi'  # noqa: E501
        if 'subnet' in local_var_params and local_var_params['subnet'] is not None:  # noqa: E501
            query_params.append(('subnet', local_var_params['subnet']))  # noqa: E501
            collection_formats['subnet'] = 'multi'  # noqa: E501
        if 'connecting_ips' in local_var_params and local_var_params['connecting_ips'] is not None:  # noqa: E501
            query_params.append(('connectingIPs', local_var_params['connecting_ips']))  # noqa: E501
            collection_formats['connectingIPs'] = 'multi'  # noqa: E501
        if 'country' in local_var_params and local_var_params['country'] is not None:  # noqa: E501
            query_params.append(('country', local_var_params['country']))  # noqa: E501
            collection_formats['country'] = 'multi'  # noqa: E501
        if 'user_agent_header' in local_var_params and local_var_params['user_agent_header'] is not None:  # noqa: E501
            query_params.append(('userAgentHeader', local_var_params['user_agent_header']))  # noqa: E501
            collection_formats['userAgentHeader'] = 'multi'  # noqa: E501
        if 'url' in local_var_params and local_var_params['url'] is not None:  # noqa: E501
            query_params.append(('url', local_var_params['url']))  # noqa: E501
            collection_formats['url'] = 'multi'  # noqa: E501
        if 'request_host' in local_var_params and local_var_params['request_host'] is not None:  # noqa: E501
            query_params.append(('requestHost', local_var_params['request_host']))  # noqa: E501
            collection_formats['requestHost'] = 'multi'  # noqa: E501
        if 'url_path' in local_var_params and local_var_params['url_path'] is not None:  # noqa: E501
            query_params.append(('urlPath', local_var_params['url_path']))  # noqa: E501
            collection_formats['urlPath'] = 'multi'  # noqa: E501
        if 'url_query' in local_var_params and local_var_params['url_query'] is not None:  # noqa: E501
            query_params.append(('urlQuery', local_var_params['url_query']))  # noqa: E501
            collection_formats['urlQuery'] = 'multi'  # noqa: E501
        if 'method' in local_var_params and local_var_params['method'] is not None:  # noqa: E501
            query_params.append(('method', local_var_params['method']))  # noqa: E501
            collection_formats['method'] = 'multi'  # noqa: E501
        if 'request_header_names' in local_var_params and local_var_params['request_header_names'] is not None:  # noqa: E501
            query_params.append(('requestHeaderNames', local_var_params['request_header_names']))  # noqa: E501
            collection_formats['requestHeaderNames'] = 'multi'  # noqa: E501
        if 'os' in local_var_params and local_var_params['os'] is not None:  # noqa: E501
            query_params.append(('os', local_var_params['os']))  # noqa: E501
            collection_formats['os'] = 'multi'  # noqa: E501
        if 'msg' in local_var_params and local_var_params['msg'] is not None:  # noqa: E501
            query_params.append(('msg', local_var_params['msg']))  # noqa: E501
            collection_formats['msg'] = 'multi'  # noqa: E501
        if 'cluster' in local_var_params and local_var_params['cluster'] is not None:  # noqa: E501
            query_params.append(('cluster', local_var_params['cluster']))  # noqa: E501
            collection_formats['cluster'] = 'multi'  # noqa: E501
        if 'attack_techniques' in local_var_params and local_var_params['attack_techniques'] is not None:  # noqa: E501
            query_params.append(('attackTechniques', local_var_params['attack_techniques']))  # noqa: E501
            collection_formats['attackTechniques'] = 'multi'  # noqa: E501
        if 'aggregate' in local_var_params and local_var_params['aggregate'] is not None:  # noqa: E501
            query_params.append(('aggregate', local_var_params['aggregate']))  # noqa: E501
        if 'protection' in local_var_params and local_var_params['protection'] is not None:  # noqa: E501
            query_params.append(('protection', local_var_params['protection']))  # noqa: E501
            collection_formats['protection'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/audits/firewall/app/container/download', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_firewall_app_container_get(self, **kwargs):  # noqa: E501
        """api_v1_audits_firewall_app_container_get  # noqa: E501

        ContainerAppFirewallAudits returns all container firewall audits according to the query specification   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_firewall_app_container_get(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param image_name: Images is the image names filter. 
        :type image_name: list[str]
        :param container_name: Containers is the container names filter. 
        :type container_name: list[str]
        :param hostname: Hosts is the hostnames filter. 
        :type hostname: list[str]
        :param rule_name: RuleNames is the rule names filter. 
        :type rule_name: list[str]
        :param type: Types is the firewall audit type filter. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect. 
        :type effect: str
        :param rule_app_id: RuleAppIDs is the rule app IDs filter. 
        :type rule_app_id: list[str]
        :param function: FunctionName is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param ns: Namespaces is the list of namespaces to use for filtering. 
        :type ns: list[str]
        :param app_id: AppIDs is the app embedded appID filter. 
        :type app_id: list[str]
        :param subnet: Subnets is the source IPs filter. 
        :type subnet: list[str]
        :param connecting_ips: ConnectingIPs is the connecting IPs filter. 
        :type connecting_ips: list[str]
        :param country: Countries is the source IP country filter. 
        :type country: list[str]
        :param user_agent_header: UserAgents is the user agent header filter. 
        :type user_agent_header: list[str]
        :param url: URLs is the URL filter. 
        :type url: list[str]
        :param request_host: RequestHosts is the request host filter. 
        :type request_host: list[str]
        :param url_path: Paths is the URL path filter. 
        :type url_path: list[str]
        :param url_query: Queries is the URL query filter. 
        :type url_query: list[str]
        :param method: Methods is the request method filter. 
        :type method: list[str]
        :param request_header_names: RequestHeaderNames is the request header names filter. 
        :type request_header_names: list[str]
        :param os: OS is the OS filter. 
        :type os: list[str]
        :param msg: Messages is the audit message text filter. 
        :type msg: list[str]
        :param cluster: Cluster is the audit cluster filter. 
        :type cluster: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param protection: Protections is the firewall audit protection type filter. 
        :type protection: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[SharedAppFirewallAudit]
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_firewall_app_container_get_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_firewall_app_container_get_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_firewall_app_container_get  # noqa: E501

        ContainerAppFirewallAudits returns all container firewall audits according to the query specification   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_firewall_app_container_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param image_name: Images is the image names filter. 
        :type image_name: list[str]
        :param container_name: Containers is the container names filter. 
        :type container_name: list[str]
        :param hostname: Hosts is the hostnames filter. 
        :type hostname: list[str]
        :param rule_name: RuleNames is the rule names filter. 
        :type rule_name: list[str]
        :param type: Types is the firewall audit type filter. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect. 
        :type effect: str
        :param rule_app_id: RuleAppIDs is the rule app IDs filter. 
        :type rule_app_id: list[str]
        :param function: FunctionName is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param ns: Namespaces is the list of namespaces to use for filtering. 
        :type ns: list[str]
        :param app_id: AppIDs is the app embedded appID filter. 
        :type app_id: list[str]
        :param subnet: Subnets is the source IPs filter. 
        :type subnet: list[str]
        :param connecting_ips: ConnectingIPs is the connecting IPs filter. 
        :type connecting_ips: list[str]
        :param country: Countries is the source IP country filter. 
        :type country: list[str]
        :param user_agent_header: UserAgents is the user agent header filter. 
        :type user_agent_header: list[str]
        :param url: URLs is the URL filter. 
        :type url: list[str]
        :param request_host: RequestHosts is the request host filter. 
        :type request_host: list[str]
        :param url_path: Paths is the URL path filter. 
        :type url_path: list[str]
        :param url_query: Queries is the URL query filter. 
        :type url_query: list[str]
        :param method: Methods is the request method filter. 
        :type method: list[str]
        :param request_header_names: RequestHeaderNames is the request header names filter. 
        :type request_header_names: list[str]
        :param os: OS is the OS filter. 
        :type os: list[str]
        :param msg: Messages is the audit message text filter. 
        :type msg: list[str]
        :param cluster: Cluster is the audit cluster filter. 
        :type cluster: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param protection: Protections is the firewall audit protection type filter. 
        :type protection: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[SharedAppFirewallAudit], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'offset',
            'limit',
            'search',
            'sort',
            'reverse',
            'collections',
            'account_ids',
            'fields',
            '_from',
            'to',
            'image_name',
            'container_name',
            'hostname',
            'rule_name',
            'type',
            'effect',
            'rule_app_id',
            'function',
            'region',
            'runtime',
            'ns',
            'app_id',
            'subnet',
            'connecting_ips',
            'country',
            'user_agent_header',
            'url',
            'request_host',
            'url_path',
            'url_query',
            'method',
            'request_header_names',
            'os',
            'msg',
            'cluster',
            'attack_techniques',
            'aggregate',
            'protection'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_firewall_app_container_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'reverse' in local_var_params and local_var_params['reverse'] is not None:  # noqa: E501
            query_params.append(('reverse', local_var_params['reverse']))  # noqa: E501
        if 'collections' in local_var_params and local_var_params['collections'] is not None:  # noqa: E501
            query_params.append(('collections', local_var_params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'account_ids' in local_var_params and local_var_params['account_ids'] is not None:  # noqa: E501
            query_params.append(('accountIDs', local_var_params['account_ids']))  # noqa: E501
            collection_formats['accountIDs'] = 'multi'  # noqa: E501
        if 'fields' in local_var_params and local_var_params['fields'] is not None:  # noqa: E501
            query_params.append(('fields', local_var_params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if '_from' in local_var_params and local_var_params['_from'] is not None:  # noqa: E501
            query_params.append(('from', local_var_params['_from']))  # noqa: E501
        if 'to' in local_var_params and local_var_params['to'] is not None:  # noqa: E501
            query_params.append(('to', local_var_params['to']))  # noqa: E501
        if 'image_name' in local_var_params and local_var_params['image_name'] is not None:  # noqa: E501
            query_params.append(('imageName', local_var_params['image_name']))  # noqa: E501
            collection_formats['imageName'] = 'multi'  # noqa: E501
        if 'container_name' in local_var_params and local_var_params['container_name'] is not None:  # noqa: E501
            query_params.append(('containerName', local_var_params['container_name']))  # noqa: E501
            collection_formats['containerName'] = 'multi'  # noqa: E501
        if 'hostname' in local_var_params and local_var_params['hostname'] is not None:  # noqa: E501
            query_params.append(('hostname', local_var_params['hostname']))  # noqa: E501
            collection_formats['hostname'] = 'multi'  # noqa: E501
        if 'rule_name' in local_var_params and local_var_params['rule_name'] is not None:  # noqa: E501
            query_params.append(('ruleName', local_var_params['rule_name']))  # noqa: E501
            collection_formats['ruleName'] = 'multi'  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
            collection_formats['type'] = 'multi'  # noqa: E501
        if 'effect' in local_var_params and local_var_params['effect'] is not None:  # noqa: E501
            query_params.append(('effect', local_var_params['effect']))  # noqa: E501
        if 'rule_app_id' in local_var_params and local_var_params['rule_app_id'] is not None:  # noqa: E501
            query_params.append(('ruleAppID', local_var_params['rule_app_id']))  # noqa: E501
            collection_formats['ruleAppID'] = 'multi'  # noqa: E501
        if 'function' in local_var_params and local_var_params['function'] is not None:  # noqa: E501
            query_params.append(('function', local_var_params['function']))  # noqa: E501
            collection_formats['function'] = 'multi'  # noqa: E501
        if 'region' in local_var_params and local_var_params['region'] is not None:  # noqa: E501
            query_params.append(('region', local_var_params['region']))  # noqa: E501
            collection_formats['region'] = 'multi'  # noqa: E501
        if 'runtime' in local_var_params and local_var_params['runtime'] is not None:  # noqa: E501
            query_params.append(('runtime', local_var_params['runtime']))  # noqa: E501
            collection_formats['runtime'] = 'multi'  # noqa: E501
        if 'ns' in local_var_params and local_var_params['ns'] is not None:  # noqa: E501
            query_params.append(('ns', local_var_params['ns']))  # noqa: E501
            collection_formats['ns'] = 'multi'  # noqa: E501
        if 'app_id' in local_var_params and local_var_params['app_id'] is not None:  # noqa: E501
            query_params.append(('appID', local_var_params['app_id']))  # noqa: E501
            collection_formats['appID'] = 'multi'  # noqa: E501
        if 'subnet' in local_var_params and local_var_params['subnet'] is not None:  # noqa: E501
            query_params.append(('subnet', local_var_params['subnet']))  # noqa: E501
            collection_formats['subnet'] = 'multi'  # noqa: E501
        if 'connecting_ips' in local_var_params and local_var_params['connecting_ips'] is not None:  # noqa: E501
            query_params.append(('connectingIPs', local_var_params['connecting_ips']))  # noqa: E501
            collection_formats['connectingIPs'] = 'multi'  # noqa: E501
        if 'country' in local_var_params and local_var_params['country'] is not None:  # noqa: E501
            query_params.append(('country', local_var_params['country']))  # noqa: E501
            collection_formats['country'] = 'multi'  # noqa: E501
        if 'user_agent_header' in local_var_params and local_var_params['user_agent_header'] is not None:  # noqa: E501
            query_params.append(('userAgentHeader', local_var_params['user_agent_header']))  # noqa: E501
            collection_formats['userAgentHeader'] = 'multi'  # noqa: E501
        if 'url' in local_var_params and local_var_params['url'] is not None:  # noqa: E501
            query_params.append(('url', local_var_params['url']))  # noqa: E501
            collection_formats['url'] = 'multi'  # noqa: E501
        if 'request_host' in local_var_params and local_var_params['request_host'] is not None:  # noqa: E501
            query_params.append(('requestHost', local_var_params['request_host']))  # noqa: E501
            collection_formats['requestHost'] = 'multi'  # noqa: E501
        if 'url_path' in local_var_params and local_var_params['url_path'] is not None:  # noqa: E501
            query_params.append(('urlPath', local_var_params['url_path']))  # noqa: E501
            collection_formats['urlPath'] = 'multi'  # noqa: E501
        if 'url_query' in local_var_params and local_var_params['url_query'] is not None:  # noqa: E501
            query_params.append(('urlQuery', local_var_params['url_query']))  # noqa: E501
            collection_formats['urlQuery'] = 'multi'  # noqa: E501
        if 'method' in local_var_params and local_var_params['method'] is not None:  # noqa: E501
            query_params.append(('method', local_var_params['method']))  # noqa: E501
            collection_formats['method'] = 'multi'  # noqa: E501
        if 'request_header_names' in local_var_params and local_var_params['request_header_names'] is not None:  # noqa: E501
            query_params.append(('requestHeaderNames', local_var_params['request_header_names']))  # noqa: E501
            collection_formats['requestHeaderNames'] = 'multi'  # noqa: E501
        if 'os' in local_var_params and local_var_params['os'] is not None:  # noqa: E501
            query_params.append(('os', local_var_params['os']))  # noqa: E501
            collection_formats['os'] = 'multi'  # noqa: E501
        if 'msg' in local_var_params and local_var_params['msg'] is not None:  # noqa: E501
            query_params.append(('msg', local_var_params['msg']))  # noqa: E501
            collection_formats['msg'] = 'multi'  # noqa: E501
        if 'cluster' in local_var_params and local_var_params['cluster'] is not None:  # noqa: E501
            query_params.append(('cluster', local_var_params['cluster']))  # noqa: E501
            collection_formats['cluster'] = 'multi'  # noqa: E501
        if 'attack_techniques' in local_var_params and local_var_params['attack_techniques'] is not None:  # noqa: E501
            query_params.append(('attackTechniques', local_var_params['attack_techniques']))  # noqa: E501
            collection_formats['attackTechniques'] = 'multi'  # noqa: E501
        if 'aggregate' in local_var_params and local_var_params['aggregate'] is not None:  # noqa: E501
            query_params.append(('aggregate', local_var_params['aggregate']))  # noqa: E501
        if 'protection' in local_var_params and local_var_params['protection'] is not None:  # noqa: E501
            query_params.append(('protection', local_var_params['protection']))  # noqa: E501
            collection_formats['protection'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "list[SharedAppFirewallAudit]",
        }

        return self.api_client.call_api(
            '/api/v1/audits/firewall/app/container', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_firewall_app_container_timeslice_get(self, **kwargs):  # noqa: E501
        """api_v1_audits_firewall_app_container_timeslice_get  # noqa: E501

        ContainerAppFirewallAuditTimeslice returns container firewall audit buckets according to the query timeframe   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_firewall_app_container_timeslice_get(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param image_name: Images is the image names filter. 
        :type image_name: list[str]
        :param container_name: Containers is the container names filter. 
        :type container_name: list[str]
        :param hostname: Hosts is the hostnames filter. 
        :type hostname: list[str]
        :param rule_name: RuleNames is the rule names filter. 
        :type rule_name: list[str]
        :param type: Types is the firewall audit type filter. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect. 
        :type effect: str
        :param rule_app_id: RuleAppIDs is the rule app IDs filter. 
        :type rule_app_id: list[str]
        :param function: FunctionName is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param ns: Namespaces is the list of namespaces to use for filtering. 
        :type ns: list[str]
        :param app_id: AppIDs is the app embedded appID filter. 
        :type app_id: list[str]
        :param subnet: Subnets is the source IPs filter. 
        :type subnet: list[str]
        :param connecting_ips: ConnectingIPs is the connecting IPs filter. 
        :type connecting_ips: list[str]
        :param country: Countries is the source IP country filter. 
        :type country: list[str]
        :param user_agent_header: UserAgents is the user agent header filter. 
        :type user_agent_header: list[str]
        :param url: URLs is the URL filter. 
        :type url: list[str]
        :param request_host: RequestHosts is the request host filter. 
        :type request_host: list[str]
        :param url_path: Paths is the URL path filter. 
        :type url_path: list[str]
        :param url_query: Queries is the URL query filter. 
        :type url_query: list[str]
        :param method: Methods is the request method filter. 
        :type method: list[str]
        :param request_header_names: RequestHeaderNames is the request header names filter. 
        :type request_header_names: list[str]
        :param os: OS is the OS filter. 
        :type os: list[str]
        :param msg: Messages is the audit message text filter. 
        :type msg: list[str]
        :param cluster: Cluster is the audit cluster filter. 
        :type cluster: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param protection: Protections is the firewall audit protection type filter. 
        :type protection: list[str]
        :param buckets: Buckets is the number of buckets to return. 
        :type buckets: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[TypesAuditTimeslice]
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_firewall_app_container_timeslice_get_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_firewall_app_container_timeslice_get_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_firewall_app_container_timeslice_get  # noqa: E501

        ContainerAppFirewallAuditTimeslice returns container firewall audit buckets according to the query timeframe   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_firewall_app_container_timeslice_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param image_name: Images is the image names filter. 
        :type image_name: list[str]
        :param container_name: Containers is the container names filter. 
        :type container_name: list[str]
        :param hostname: Hosts is the hostnames filter. 
        :type hostname: list[str]
        :param rule_name: RuleNames is the rule names filter. 
        :type rule_name: list[str]
        :param type: Types is the firewall audit type filter. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect. 
        :type effect: str
        :param rule_app_id: RuleAppIDs is the rule app IDs filter. 
        :type rule_app_id: list[str]
        :param function: FunctionName is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param ns: Namespaces is the list of namespaces to use for filtering. 
        :type ns: list[str]
        :param app_id: AppIDs is the app embedded appID filter. 
        :type app_id: list[str]
        :param subnet: Subnets is the source IPs filter. 
        :type subnet: list[str]
        :param connecting_ips: ConnectingIPs is the connecting IPs filter. 
        :type connecting_ips: list[str]
        :param country: Countries is the source IP country filter. 
        :type country: list[str]
        :param user_agent_header: UserAgents is the user agent header filter. 
        :type user_agent_header: list[str]
        :param url: URLs is the URL filter. 
        :type url: list[str]
        :param request_host: RequestHosts is the request host filter. 
        :type request_host: list[str]
        :param url_path: Paths is the URL path filter. 
        :type url_path: list[str]
        :param url_query: Queries is the URL query filter. 
        :type url_query: list[str]
        :param method: Methods is the request method filter. 
        :type method: list[str]
        :param request_header_names: RequestHeaderNames is the request header names filter. 
        :type request_header_names: list[str]
        :param os: OS is the OS filter. 
        :type os: list[str]
        :param msg: Messages is the audit message text filter. 
        :type msg: list[str]
        :param cluster: Cluster is the audit cluster filter. 
        :type cluster: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param protection: Protections is the firewall audit protection type filter. 
        :type protection: list[str]
        :param buckets: Buckets is the number of buckets to return. 
        :type buckets: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[TypesAuditTimeslice], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'offset',
            'limit',
            'search',
            'sort',
            'reverse',
            'collections',
            'account_ids',
            'fields',
            '_from',
            'to',
            'image_name',
            'container_name',
            'hostname',
            'rule_name',
            'type',
            'effect',
            'rule_app_id',
            'function',
            'region',
            'runtime',
            'ns',
            'app_id',
            'subnet',
            'connecting_ips',
            'country',
            'user_agent_header',
            'url',
            'request_host',
            'url_path',
            'url_query',
            'method',
            'request_header_names',
            'os',
            'msg',
            'cluster',
            'attack_techniques',
            'aggregate',
            'protection',
            'buckets'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_firewall_app_container_timeslice_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'reverse' in local_var_params and local_var_params['reverse'] is not None:  # noqa: E501
            query_params.append(('reverse', local_var_params['reverse']))  # noqa: E501
        if 'collections' in local_var_params and local_var_params['collections'] is not None:  # noqa: E501
            query_params.append(('collections', local_var_params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'account_ids' in local_var_params and local_var_params['account_ids'] is not None:  # noqa: E501
            query_params.append(('accountIDs', local_var_params['account_ids']))  # noqa: E501
            collection_formats['accountIDs'] = 'multi'  # noqa: E501
        if 'fields' in local_var_params and local_var_params['fields'] is not None:  # noqa: E501
            query_params.append(('fields', local_var_params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if '_from' in local_var_params and local_var_params['_from'] is not None:  # noqa: E501
            query_params.append(('from', local_var_params['_from']))  # noqa: E501
        if 'to' in local_var_params and local_var_params['to'] is not None:  # noqa: E501
            query_params.append(('to', local_var_params['to']))  # noqa: E501
        if 'image_name' in local_var_params and local_var_params['image_name'] is not None:  # noqa: E501
            query_params.append(('imageName', local_var_params['image_name']))  # noqa: E501
            collection_formats['imageName'] = 'multi'  # noqa: E501
        if 'container_name' in local_var_params and local_var_params['container_name'] is not None:  # noqa: E501
            query_params.append(('containerName', local_var_params['container_name']))  # noqa: E501
            collection_formats['containerName'] = 'multi'  # noqa: E501
        if 'hostname' in local_var_params and local_var_params['hostname'] is not None:  # noqa: E501
            query_params.append(('hostname', local_var_params['hostname']))  # noqa: E501
            collection_formats['hostname'] = 'multi'  # noqa: E501
        if 'rule_name' in local_var_params and local_var_params['rule_name'] is not None:  # noqa: E501
            query_params.append(('ruleName', local_var_params['rule_name']))  # noqa: E501
            collection_formats['ruleName'] = 'multi'  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
            collection_formats['type'] = 'multi'  # noqa: E501
        if 'effect' in local_var_params and local_var_params['effect'] is not None:  # noqa: E501
            query_params.append(('effect', local_var_params['effect']))  # noqa: E501
        if 'rule_app_id' in local_var_params and local_var_params['rule_app_id'] is not None:  # noqa: E501
            query_params.append(('ruleAppID', local_var_params['rule_app_id']))  # noqa: E501
            collection_formats['ruleAppID'] = 'multi'  # noqa: E501
        if 'function' in local_var_params and local_var_params['function'] is not None:  # noqa: E501
            query_params.append(('function', local_var_params['function']))  # noqa: E501
            collection_formats['function'] = 'multi'  # noqa: E501
        if 'region' in local_var_params and local_var_params['region'] is not None:  # noqa: E501
            query_params.append(('region', local_var_params['region']))  # noqa: E501
            collection_formats['region'] = 'multi'  # noqa: E501
        if 'runtime' in local_var_params and local_var_params['runtime'] is not None:  # noqa: E501
            query_params.append(('runtime', local_var_params['runtime']))  # noqa: E501
            collection_formats['runtime'] = 'multi'  # noqa: E501
        if 'ns' in local_var_params and local_var_params['ns'] is not None:  # noqa: E501
            query_params.append(('ns', local_var_params['ns']))  # noqa: E501
            collection_formats['ns'] = 'multi'  # noqa: E501
        if 'app_id' in local_var_params and local_var_params['app_id'] is not None:  # noqa: E501
            query_params.append(('appID', local_var_params['app_id']))  # noqa: E501
            collection_formats['appID'] = 'multi'  # noqa: E501
        if 'subnet' in local_var_params and local_var_params['subnet'] is not None:  # noqa: E501
            query_params.append(('subnet', local_var_params['subnet']))  # noqa: E501
            collection_formats['subnet'] = 'multi'  # noqa: E501
        if 'connecting_ips' in local_var_params and local_var_params['connecting_ips'] is not None:  # noqa: E501
            query_params.append(('connectingIPs', local_var_params['connecting_ips']))  # noqa: E501
            collection_formats['connectingIPs'] = 'multi'  # noqa: E501
        if 'country' in local_var_params and local_var_params['country'] is not None:  # noqa: E501
            query_params.append(('country', local_var_params['country']))  # noqa: E501
            collection_formats['country'] = 'multi'  # noqa: E501
        if 'user_agent_header' in local_var_params and local_var_params['user_agent_header'] is not None:  # noqa: E501
            query_params.append(('userAgentHeader', local_var_params['user_agent_header']))  # noqa: E501
            collection_formats['userAgentHeader'] = 'multi'  # noqa: E501
        if 'url' in local_var_params and local_var_params['url'] is not None:  # noqa: E501
            query_params.append(('url', local_var_params['url']))  # noqa: E501
            collection_formats['url'] = 'multi'  # noqa: E501
        if 'request_host' in local_var_params and local_var_params['request_host'] is not None:  # noqa: E501
            query_params.append(('requestHost', local_var_params['request_host']))  # noqa: E501
            collection_formats['requestHost'] = 'multi'  # noqa: E501
        if 'url_path' in local_var_params and local_var_params['url_path'] is not None:  # noqa: E501
            query_params.append(('urlPath', local_var_params['url_path']))  # noqa: E501
            collection_formats['urlPath'] = 'multi'  # noqa: E501
        if 'url_query' in local_var_params and local_var_params['url_query'] is not None:  # noqa: E501
            query_params.append(('urlQuery', local_var_params['url_query']))  # noqa: E501
            collection_formats['urlQuery'] = 'multi'  # noqa: E501
        if 'method' in local_var_params and local_var_params['method'] is not None:  # noqa: E501
            query_params.append(('method', local_var_params['method']))  # noqa: E501
            collection_formats['method'] = 'multi'  # noqa: E501
        if 'request_header_names' in local_var_params and local_var_params['request_header_names'] is not None:  # noqa: E501
            query_params.append(('requestHeaderNames', local_var_params['request_header_names']))  # noqa: E501
            collection_formats['requestHeaderNames'] = 'multi'  # noqa: E501
        if 'os' in local_var_params and local_var_params['os'] is not None:  # noqa: E501
            query_params.append(('os', local_var_params['os']))  # noqa: E501
            collection_formats['os'] = 'multi'  # noqa: E501
        if 'msg' in local_var_params and local_var_params['msg'] is not None:  # noqa: E501
            query_params.append(('msg', local_var_params['msg']))  # noqa: E501
            collection_formats['msg'] = 'multi'  # noqa: E501
        if 'cluster' in local_var_params and local_var_params['cluster'] is not None:  # noqa: E501
            query_params.append(('cluster', local_var_params['cluster']))  # noqa: E501
            collection_formats['cluster'] = 'multi'  # noqa: E501
        if 'attack_techniques' in local_var_params and local_var_params['attack_techniques'] is not None:  # noqa: E501
            query_params.append(('attackTechniques', local_var_params['attack_techniques']))  # noqa: E501
            collection_formats['attackTechniques'] = 'multi'  # noqa: E501
        if 'aggregate' in local_var_params and local_var_params['aggregate'] is not None:  # noqa: E501
            query_params.append(('aggregate', local_var_params['aggregate']))  # noqa: E501
        if 'protection' in local_var_params and local_var_params['protection'] is not None:  # noqa: E501
            query_params.append(('protection', local_var_params['protection']))  # noqa: E501
            collection_formats['protection'] = 'multi'  # noqa: E501
        if 'buckets' in local_var_params and local_var_params['buckets'] is not None:  # noqa: E501
            query_params.append(('buckets', local_var_params['buckets']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "list[TypesAuditTimeslice]",
        }

        return self.api_client.call_api(
            '/api/v1/audits/firewall/app/container/timeslice', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_firewall_app_host_download_get(self, **kwargs):  # noqa: E501
        """api_v1_audits_firewall_app_host_download_get  # noqa: E501

        DownloadHostAppFirewallAudits downloads the host firewall audits according to the specified query   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_firewall_app_host_download_get(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param image_name: Images is the image names filter. 
        :type image_name: list[str]
        :param container_name: Containers is the container names filter. 
        :type container_name: list[str]
        :param hostname: Hosts is the hostnames filter. 
        :type hostname: list[str]
        :param rule_name: RuleNames is the rule names filter. 
        :type rule_name: list[str]
        :param type: Types is the firewall audit type filter. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect. 
        :type effect: str
        :param rule_app_id: RuleAppIDs is the rule app IDs filter. 
        :type rule_app_id: list[str]
        :param function: FunctionName is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param ns: Namespaces is the list of namespaces to use for filtering. 
        :type ns: list[str]
        :param app_id: AppIDs is the app embedded appID filter. 
        :type app_id: list[str]
        :param subnet: Subnets is the source IPs filter. 
        :type subnet: list[str]
        :param connecting_ips: ConnectingIPs is the connecting IPs filter. 
        :type connecting_ips: list[str]
        :param country: Countries is the source IP country filter. 
        :type country: list[str]
        :param user_agent_header: UserAgents is the user agent header filter. 
        :type user_agent_header: list[str]
        :param url: URLs is the URL filter. 
        :type url: list[str]
        :param request_host: RequestHosts is the request host filter. 
        :type request_host: list[str]
        :param url_path: Paths is the URL path filter. 
        :type url_path: list[str]
        :param url_query: Queries is the URL query filter. 
        :type url_query: list[str]
        :param method: Methods is the request method filter. 
        :type method: list[str]
        :param request_header_names: RequestHeaderNames is the request header names filter. 
        :type request_header_names: list[str]
        :param os: OS is the OS filter. 
        :type os: list[str]
        :param msg: Messages is the audit message text filter. 
        :type msg: list[str]
        :param cluster: Cluster is the audit cluster filter. 
        :type cluster: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param protection: Protections is the firewall audit protection type filter. 
        :type protection: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_firewall_app_host_download_get_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_firewall_app_host_download_get_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_firewall_app_host_download_get  # noqa: E501

        DownloadHostAppFirewallAudits downloads the host firewall audits according to the specified query   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_firewall_app_host_download_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param image_name: Images is the image names filter. 
        :type image_name: list[str]
        :param container_name: Containers is the container names filter. 
        :type container_name: list[str]
        :param hostname: Hosts is the hostnames filter. 
        :type hostname: list[str]
        :param rule_name: RuleNames is the rule names filter. 
        :type rule_name: list[str]
        :param type: Types is the firewall audit type filter. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect. 
        :type effect: str
        :param rule_app_id: RuleAppIDs is the rule app IDs filter. 
        :type rule_app_id: list[str]
        :param function: FunctionName is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param ns: Namespaces is the list of namespaces to use for filtering. 
        :type ns: list[str]
        :param app_id: AppIDs is the app embedded appID filter. 
        :type app_id: list[str]
        :param subnet: Subnets is the source IPs filter. 
        :type subnet: list[str]
        :param connecting_ips: ConnectingIPs is the connecting IPs filter. 
        :type connecting_ips: list[str]
        :param country: Countries is the source IP country filter. 
        :type country: list[str]
        :param user_agent_header: UserAgents is the user agent header filter. 
        :type user_agent_header: list[str]
        :param url: URLs is the URL filter. 
        :type url: list[str]
        :param request_host: RequestHosts is the request host filter. 
        :type request_host: list[str]
        :param url_path: Paths is the URL path filter. 
        :type url_path: list[str]
        :param url_query: Queries is the URL query filter. 
        :type url_query: list[str]
        :param method: Methods is the request method filter. 
        :type method: list[str]
        :param request_header_names: RequestHeaderNames is the request header names filter. 
        :type request_header_names: list[str]
        :param os: OS is the OS filter. 
        :type os: list[str]
        :param msg: Messages is the audit message text filter. 
        :type msg: list[str]
        :param cluster: Cluster is the audit cluster filter. 
        :type cluster: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param protection: Protections is the firewall audit protection type filter. 
        :type protection: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'offset',
            'limit',
            'search',
            'sort',
            'reverse',
            'collections',
            'account_ids',
            'fields',
            '_from',
            'to',
            'image_name',
            'container_name',
            'hostname',
            'rule_name',
            'type',
            'effect',
            'rule_app_id',
            'function',
            'region',
            'runtime',
            'ns',
            'app_id',
            'subnet',
            'connecting_ips',
            'country',
            'user_agent_header',
            'url',
            'request_host',
            'url_path',
            'url_query',
            'method',
            'request_header_names',
            'os',
            'msg',
            'cluster',
            'attack_techniques',
            'aggregate',
            'protection'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_firewall_app_host_download_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'reverse' in local_var_params and local_var_params['reverse'] is not None:  # noqa: E501
            query_params.append(('reverse', local_var_params['reverse']))  # noqa: E501
        if 'collections' in local_var_params and local_var_params['collections'] is not None:  # noqa: E501
            query_params.append(('collections', local_var_params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'account_ids' in local_var_params and local_var_params['account_ids'] is not None:  # noqa: E501
            query_params.append(('accountIDs', local_var_params['account_ids']))  # noqa: E501
            collection_formats['accountIDs'] = 'multi'  # noqa: E501
        if 'fields' in local_var_params and local_var_params['fields'] is not None:  # noqa: E501
            query_params.append(('fields', local_var_params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if '_from' in local_var_params and local_var_params['_from'] is not None:  # noqa: E501
            query_params.append(('from', local_var_params['_from']))  # noqa: E501
        if 'to' in local_var_params and local_var_params['to'] is not None:  # noqa: E501
            query_params.append(('to', local_var_params['to']))  # noqa: E501
        if 'image_name' in local_var_params and local_var_params['image_name'] is not None:  # noqa: E501
            query_params.append(('imageName', local_var_params['image_name']))  # noqa: E501
            collection_formats['imageName'] = 'multi'  # noqa: E501
        if 'container_name' in local_var_params and local_var_params['container_name'] is not None:  # noqa: E501
            query_params.append(('containerName', local_var_params['container_name']))  # noqa: E501
            collection_formats['containerName'] = 'multi'  # noqa: E501
        if 'hostname' in local_var_params and local_var_params['hostname'] is not None:  # noqa: E501
            query_params.append(('hostname', local_var_params['hostname']))  # noqa: E501
            collection_formats['hostname'] = 'multi'  # noqa: E501
        if 'rule_name' in local_var_params and local_var_params['rule_name'] is not None:  # noqa: E501
            query_params.append(('ruleName', local_var_params['rule_name']))  # noqa: E501
            collection_formats['ruleName'] = 'multi'  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
            collection_formats['type'] = 'multi'  # noqa: E501
        if 'effect' in local_var_params and local_var_params['effect'] is not None:  # noqa: E501
            query_params.append(('effect', local_var_params['effect']))  # noqa: E501
        if 'rule_app_id' in local_var_params and local_var_params['rule_app_id'] is not None:  # noqa: E501
            query_params.append(('ruleAppID', local_var_params['rule_app_id']))  # noqa: E501
            collection_formats['ruleAppID'] = 'multi'  # noqa: E501
        if 'function' in local_var_params and local_var_params['function'] is not None:  # noqa: E501
            query_params.append(('function', local_var_params['function']))  # noqa: E501
            collection_formats['function'] = 'multi'  # noqa: E501
        if 'region' in local_var_params and local_var_params['region'] is not None:  # noqa: E501
            query_params.append(('region', local_var_params['region']))  # noqa: E501
            collection_formats['region'] = 'multi'  # noqa: E501
        if 'runtime' in local_var_params and local_var_params['runtime'] is not None:  # noqa: E501
            query_params.append(('runtime', local_var_params['runtime']))  # noqa: E501
            collection_formats['runtime'] = 'multi'  # noqa: E501
        if 'ns' in local_var_params and local_var_params['ns'] is not None:  # noqa: E501
            query_params.append(('ns', local_var_params['ns']))  # noqa: E501
            collection_formats['ns'] = 'multi'  # noqa: E501
        if 'app_id' in local_var_params and local_var_params['app_id'] is not None:  # noqa: E501
            query_params.append(('appID', local_var_params['app_id']))  # noqa: E501
            collection_formats['appID'] = 'multi'  # noqa: E501
        if 'subnet' in local_var_params and local_var_params['subnet'] is not None:  # noqa: E501
            query_params.append(('subnet', local_var_params['subnet']))  # noqa: E501
            collection_formats['subnet'] = 'multi'  # noqa: E501
        if 'connecting_ips' in local_var_params and local_var_params['connecting_ips'] is not None:  # noqa: E501
            query_params.append(('connectingIPs', local_var_params['connecting_ips']))  # noqa: E501
            collection_formats['connectingIPs'] = 'multi'  # noqa: E501
        if 'country' in local_var_params and local_var_params['country'] is not None:  # noqa: E501
            query_params.append(('country', local_var_params['country']))  # noqa: E501
            collection_formats['country'] = 'multi'  # noqa: E501
        if 'user_agent_header' in local_var_params and local_var_params['user_agent_header'] is not None:  # noqa: E501
            query_params.append(('userAgentHeader', local_var_params['user_agent_header']))  # noqa: E501
            collection_formats['userAgentHeader'] = 'multi'  # noqa: E501
        if 'url' in local_var_params and local_var_params['url'] is not None:  # noqa: E501
            query_params.append(('url', local_var_params['url']))  # noqa: E501
            collection_formats['url'] = 'multi'  # noqa: E501
        if 'request_host' in local_var_params and local_var_params['request_host'] is not None:  # noqa: E501
            query_params.append(('requestHost', local_var_params['request_host']))  # noqa: E501
            collection_formats['requestHost'] = 'multi'  # noqa: E501
        if 'url_path' in local_var_params and local_var_params['url_path'] is not None:  # noqa: E501
            query_params.append(('urlPath', local_var_params['url_path']))  # noqa: E501
            collection_formats['urlPath'] = 'multi'  # noqa: E501
        if 'url_query' in local_var_params and local_var_params['url_query'] is not None:  # noqa: E501
            query_params.append(('urlQuery', local_var_params['url_query']))  # noqa: E501
            collection_formats['urlQuery'] = 'multi'  # noqa: E501
        if 'method' in local_var_params and local_var_params['method'] is not None:  # noqa: E501
            query_params.append(('method', local_var_params['method']))  # noqa: E501
            collection_formats['method'] = 'multi'  # noqa: E501
        if 'request_header_names' in local_var_params and local_var_params['request_header_names'] is not None:  # noqa: E501
            query_params.append(('requestHeaderNames', local_var_params['request_header_names']))  # noqa: E501
            collection_formats['requestHeaderNames'] = 'multi'  # noqa: E501
        if 'os' in local_var_params and local_var_params['os'] is not None:  # noqa: E501
            query_params.append(('os', local_var_params['os']))  # noqa: E501
            collection_formats['os'] = 'multi'  # noqa: E501
        if 'msg' in local_var_params and local_var_params['msg'] is not None:  # noqa: E501
            query_params.append(('msg', local_var_params['msg']))  # noqa: E501
            collection_formats['msg'] = 'multi'  # noqa: E501
        if 'cluster' in local_var_params and local_var_params['cluster'] is not None:  # noqa: E501
            query_params.append(('cluster', local_var_params['cluster']))  # noqa: E501
            collection_formats['cluster'] = 'multi'  # noqa: E501
        if 'attack_techniques' in local_var_params and local_var_params['attack_techniques'] is not None:  # noqa: E501
            query_params.append(('attackTechniques', local_var_params['attack_techniques']))  # noqa: E501
            collection_formats['attackTechniques'] = 'multi'  # noqa: E501
        if 'aggregate' in local_var_params and local_var_params['aggregate'] is not None:  # noqa: E501
            query_params.append(('aggregate', local_var_params['aggregate']))  # noqa: E501
        if 'protection' in local_var_params and local_var_params['protection'] is not None:  # noqa: E501
            query_params.append(('protection', local_var_params['protection']))  # noqa: E501
            collection_formats['protection'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/audits/firewall/app/host/download', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_firewall_app_host_get(self, **kwargs):  # noqa: E501
        """api_v1_audits_firewall_app_host_get  # noqa: E501

        HostAppFirewallAudits returns all host firewall audits according to the query specification   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_firewall_app_host_get(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param image_name: Images is the image names filter. 
        :type image_name: list[str]
        :param container_name: Containers is the container names filter. 
        :type container_name: list[str]
        :param hostname: Hosts is the hostnames filter. 
        :type hostname: list[str]
        :param rule_name: RuleNames is the rule names filter. 
        :type rule_name: list[str]
        :param type: Types is the firewall audit type filter. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect. 
        :type effect: str
        :param rule_app_id: RuleAppIDs is the rule app IDs filter. 
        :type rule_app_id: list[str]
        :param function: FunctionName is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param ns: Namespaces is the list of namespaces to use for filtering. 
        :type ns: list[str]
        :param app_id: AppIDs is the app embedded appID filter. 
        :type app_id: list[str]
        :param subnet: Subnets is the source IPs filter. 
        :type subnet: list[str]
        :param connecting_ips: ConnectingIPs is the connecting IPs filter. 
        :type connecting_ips: list[str]
        :param country: Countries is the source IP country filter. 
        :type country: list[str]
        :param user_agent_header: UserAgents is the user agent header filter. 
        :type user_agent_header: list[str]
        :param url: URLs is the URL filter. 
        :type url: list[str]
        :param request_host: RequestHosts is the request host filter. 
        :type request_host: list[str]
        :param url_path: Paths is the URL path filter. 
        :type url_path: list[str]
        :param url_query: Queries is the URL query filter. 
        :type url_query: list[str]
        :param method: Methods is the request method filter. 
        :type method: list[str]
        :param request_header_names: RequestHeaderNames is the request header names filter. 
        :type request_header_names: list[str]
        :param os: OS is the OS filter. 
        :type os: list[str]
        :param msg: Messages is the audit message text filter. 
        :type msg: list[str]
        :param cluster: Cluster is the audit cluster filter. 
        :type cluster: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param protection: Protections is the firewall audit protection type filter. 
        :type protection: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[SharedAppFirewallAudit]
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_firewall_app_host_get_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_firewall_app_host_get_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_firewall_app_host_get  # noqa: E501

        HostAppFirewallAudits returns all host firewall audits according to the query specification   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_firewall_app_host_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param image_name: Images is the image names filter. 
        :type image_name: list[str]
        :param container_name: Containers is the container names filter. 
        :type container_name: list[str]
        :param hostname: Hosts is the hostnames filter. 
        :type hostname: list[str]
        :param rule_name: RuleNames is the rule names filter. 
        :type rule_name: list[str]
        :param type: Types is the firewall audit type filter. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect. 
        :type effect: str
        :param rule_app_id: RuleAppIDs is the rule app IDs filter. 
        :type rule_app_id: list[str]
        :param function: FunctionName is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param ns: Namespaces is the list of namespaces to use for filtering. 
        :type ns: list[str]
        :param app_id: AppIDs is the app embedded appID filter. 
        :type app_id: list[str]
        :param subnet: Subnets is the source IPs filter. 
        :type subnet: list[str]
        :param connecting_ips: ConnectingIPs is the connecting IPs filter. 
        :type connecting_ips: list[str]
        :param country: Countries is the source IP country filter. 
        :type country: list[str]
        :param user_agent_header: UserAgents is the user agent header filter. 
        :type user_agent_header: list[str]
        :param url: URLs is the URL filter. 
        :type url: list[str]
        :param request_host: RequestHosts is the request host filter. 
        :type request_host: list[str]
        :param url_path: Paths is the URL path filter. 
        :type url_path: list[str]
        :param url_query: Queries is the URL query filter. 
        :type url_query: list[str]
        :param method: Methods is the request method filter. 
        :type method: list[str]
        :param request_header_names: RequestHeaderNames is the request header names filter. 
        :type request_header_names: list[str]
        :param os: OS is the OS filter. 
        :type os: list[str]
        :param msg: Messages is the audit message text filter. 
        :type msg: list[str]
        :param cluster: Cluster is the audit cluster filter. 
        :type cluster: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param protection: Protections is the firewall audit protection type filter. 
        :type protection: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[SharedAppFirewallAudit], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'offset',
            'limit',
            'search',
            'sort',
            'reverse',
            'collections',
            'account_ids',
            'fields',
            '_from',
            'to',
            'image_name',
            'container_name',
            'hostname',
            'rule_name',
            'type',
            'effect',
            'rule_app_id',
            'function',
            'region',
            'runtime',
            'ns',
            'app_id',
            'subnet',
            'connecting_ips',
            'country',
            'user_agent_header',
            'url',
            'request_host',
            'url_path',
            'url_query',
            'method',
            'request_header_names',
            'os',
            'msg',
            'cluster',
            'attack_techniques',
            'aggregate',
            'protection'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_firewall_app_host_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'reverse' in local_var_params and local_var_params['reverse'] is not None:  # noqa: E501
            query_params.append(('reverse', local_var_params['reverse']))  # noqa: E501
        if 'collections' in local_var_params and local_var_params['collections'] is not None:  # noqa: E501
            query_params.append(('collections', local_var_params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'account_ids' in local_var_params and local_var_params['account_ids'] is not None:  # noqa: E501
            query_params.append(('accountIDs', local_var_params['account_ids']))  # noqa: E501
            collection_formats['accountIDs'] = 'multi'  # noqa: E501
        if 'fields' in local_var_params and local_var_params['fields'] is not None:  # noqa: E501
            query_params.append(('fields', local_var_params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if '_from' in local_var_params and local_var_params['_from'] is not None:  # noqa: E501
            query_params.append(('from', local_var_params['_from']))  # noqa: E501
        if 'to' in local_var_params and local_var_params['to'] is not None:  # noqa: E501
            query_params.append(('to', local_var_params['to']))  # noqa: E501
        if 'image_name' in local_var_params and local_var_params['image_name'] is not None:  # noqa: E501
            query_params.append(('imageName', local_var_params['image_name']))  # noqa: E501
            collection_formats['imageName'] = 'multi'  # noqa: E501
        if 'container_name' in local_var_params and local_var_params['container_name'] is not None:  # noqa: E501
            query_params.append(('containerName', local_var_params['container_name']))  # noqa: E501
            collection_formats['containerName'] = 'multi'  # noqa: E501
        if 'hostname' in local_var_params and local_var_params['hostname'] is not None:  # noqa: E501
            query_params.append(('hostname', local_var_params['hostname']))  # noqa: E501
            collection_formats['hostname'] = 'multi'  # noqa: E501
        if 'rule_name' in local_var_params and local_var_params['rule_name'] is not None:  # noqa: E501
            query_params.append(('ruleName', local_var_params['rule_name']))  # noqa: E501
            collection_formats['ruleName'] = 'multi'  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
            collection_formats['type'] = 'multi'  # noqa: E501
        if 'effect' in local_var_params and local_var_params['effect'] is not None:  # noqa: E501
            query_params.append(('effect', local_var_params['effect']))  # noqa: E501
        if 'rule_app_id' in local_var_params and local_var_params['rule_app_id'] is not None:  # noqa: E501
            query_params.append(('ruleAppID', local_var_params['rule_app_id']))  # noqa: E501
            collection_formats['ruleAppID'] = 'multi'  # noqa: E501
        if 'function' in local_var_params and local_var_params['function'] is not None:  # noqa: E501
            query_params.append(('function', local_var_params['function']))  # noqa: E501
            collection_formats['function'] = 'multi'  # noqa: E501
        if 'region' in local_var_params and local_var_params['region'] is not None:  # noqa: E501
            query_params.append(('region', local_var_params['region']))  # noqa: E501
            collection_formats['region'] = 'multi'  # noqa: E501
        if 'runtime' in local_var_params and local_var_params['runtime'] is not None:  # noqa: E501
            query_params.append(('runtime', local_var_params['runtime']))  # noqa: E501
            collection_formats['runtime'] = 'multi'  # noqa: E501
        if 'ns' in local_var_params and local_var_params['ns'] is not None:  # noqa: E501
            query_params.append(('ns', local_var_params['ns']))  # noqa: E501
            collection_formats['ns'] = 'multi'  # noqa: E501
        if 'app_id' in local_var_params and local_var_params['app_id'] is not None:  # noqa: E501
            query_params.append(('appID', local_var_params['app_id']))  # noqa: E501
            collection_formats['appID'] = 'multi'  # noqa: E501
        if 'subnet' in local_var_params and local_var_params['subnet'] is not None:  # noqa: E501
            query_params.append(('subnet', local_var_params['subnet']))  # noqa: E501
            collection_formats['subnet'] = 'multi'  # noqa: E501
        if 'connecting_ips' in local_var_params and local_var_params['connecting_ips'] is not None:  # noqa: E501
            query_params.append(('connectingIPs', local_var_params['connecting_ips']))  # noqa: E501
            collection_formats['connectingIPs'] = 'multi'  # noqa: E501
        if 'country' in local_var_params and local_var_params['country'] is not None:  # noqa: E501
            query_params.append(('country', local_var_params['country']))  # noqa: E501
            collection_formats['country'] = 'multi'  # noqa: E501
        if 'user_agent_header' in local_var_params and local_var_params['user_agent_header'] is not None:  # noqa: E501
            query_params.append(('userAgentHeader', local_var_params['user_agent_header']))  # noqa: E501
            collection_formats['userAgentHeader'] = 'multi'  # noqa: E501
        if 'url' in local_var_params and local_var_params['url'] is not None:  # noqa: E501
            query_params.append(('url', local_var_params['url']))  # noqa: E501
            collection_formats['url'] = 'multi'  # noqa: E501
        if 'request_host' in local_var_params and local_var_params['request_host'] is not None:  # noqa: E501
            query_params.append(('requestHost', local_var_params['request_host']))  # noqa: E501
            collection_formats['requestHost'] = 'multi'  # noqa: E501
        if 'url_path' in local_var_params and local_var_params['url_path'] is not None:  # noqa: E501
            query_params.append(('urlPath', local_var_params['url_path']))  # noqa: E501
            collection_formats['urlPath'] = 'multi'  # noqa: E501
        if 'url_query' in local_var_params and local_var_params['url_query'] is not None:  # noqa: E501
            query_params.append(('urlQuery', local_var_params['url_query']))  # noqa: E501
            collection_formats['urlQuery'] = 'multi'  # noqa: E501
        if 'method' in local_var_params and local_var_params['method'] is not None:  # noqa: E501
            query_params.append(('method', local_var_params['method']))  # noqa: E501
            collection_formats['method'] = 'multi'  # noqa: E501
        if 'request_header_names' in local_var_params and local_var_params['request_header_names'] is not None:  # noqa: E501
            query_params.append(('requestHeaderNames', local_var_params['request_header_names']))  # noqa: E501
            collection_formats['requestHeaderNames'] = 'multi'  # noqa: E501
        if 'os' in local_var_params and local_var_params['os'] is not None:  # noqa: E501
            query_params.append(('os', local_var_params['os']))  # noqa: E501
            collection_formats['os'] = 'multi'  # noqa: E501
        if 'msg' in local_var_params and local_var_params['msg'] is not None:  # noqa: E501
            query_params.append(('msg', local_var_params['msg']))  # noqa: E501
            collection_formats['msg'] = 'multi'  # noqa: E501
        if 'cluster' in local_var_params and local_var_params['cluster'] is not None:  # noqa: E501
            query_params.append(('cluster', local_var_params['cluster']))  # noqa: E501
            collection_formats['cluster'] = 'multi'  # noqa: E501
        if 'attack_techniques' in local_var_params and local_var_params['attack_techniques'] is not None:  # noqa: E501
            query_params.append(('attackTechniques', local_var_params['attack_techniques']))  # noqa: E501
            collection_formats['attackTechniques'] = 'multi'  # noqa: E501
        if 'aggregate' in local_var_params and local_var_params['aggregate'] is not None:  # noqa: E501
            query_params.append(('aggregate', local_var_params['aggregate']))  # noqa: E501
        if 'protection' in local_var_params and local_var_params['protection'] is not None:  # noqa: E501
            query_params.append(('protection', local_var_params['protection']))  # noqa: E501
            collection_formats['protection'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "list[SharedAppFirewallAudit]",
        }

        return self.api_client.call_api(
            '/api/v1/audits/firewall/app/host', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_firewall_app_host_timeslice_get(self, **kwargs):  # noqa: E501
        """api_v1_audits_firewall_app_host_timeslice_get  # noqa: E501

        HostAppFirewallAuditTimeslice returns host firewall audit buckets according to the query timeframe   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_firewall_app_host_timeslice_get(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param image_name: Images is the image names filter. 
        :type image_name: list[str]
        :param container_name: Containers is the container names filter. 
        :type container_name: list[str]
        :param hostname: Hosts is the hostnames filter. 
        :type hostname: list[str]
        :param rule_name: RuleNames is the rule names filter. 
        :type rule_name: list[str]
        :param type: Types is the firewall audit type filter. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect. 
        :type effect: str
        :param rule_app_id: RuleAppIDs is the rule app IDs filter. 
        :type rule_app_id: list[str]
        :param function: FunctionName is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param ns: Namespaces is the list of namespaces to use for filtering. 
        :type ns: list[str]
        :param app_id: AppIDs is the app embedded appID filter. 
        :type app_id: list[str]
        :param subnet: Subnets is the source IPs filter. 
        :type subnet: list[str]
        :param connecting_ips: ConnectingIPs is the connecting IPs filter. 
        :type connecting_ips: list[str]
        :param country: Countries is the source IP country filter. 
        :type country: list[str]
        :param user_agent_header: UserAgents is the user agent header filter. 
        :type user_agent_header: list[str]
        :param url: URLs is the URL filter. 
        :type url: list[str]
        :param request_host: RequestHosts is the request host filter. 
        :type request_host: list[str]
        :param url_path: Paths is the URL path filter. 
        :type url_path: list[str]
        :param url_query: Queries is the URL query filter. 
        :type url_query: list[str]
        :param method: Methods is the request method filter. 
        :type method: list[str]
        :param request_header_names: RequestHeaderNames is the request header names filter. 
        :type request_header_names: list[str]
        :param os: OS is the OS filter. 
        :type os: list[str]
        :param msg: Messages is the audit message text filter. 
        :type msg: list[str]
        :param cluster: Cluster is the audit cluster filter. 
        :type cluster: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param protection: Protections is the firewall audit protection type filter. 
        :type protection: list[str]
        :param buckets: Buckets is the number of buckets to return. 
        :type buckets: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[TypesAuditTimeslice]
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_firewall_app_host_timeslice_get_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_firewall_app_host_timeslice_get_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_firewall_app_host_timeslice_get  # noqa: E501

        HostAppFirewallAuditTimeslice returns host firewall audit buckets according to the query timeframe   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_firewall_app_host_timeslice_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param image_name: Images is the image names filter. 
        :type image_name: list[str]
        :param container_name: Containers is the container names filter. 
        :type container_name: list[str]
        :param hostname: Hosts is the hostnames filter. 
        :type hostname: list[str]
        :param rule_name: RuleNames is the rule names filter. 
        :type rule_name: list[str]
        :param type: Types is the firewall audit type filter. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect. 
        :type effect: str
        :param rule_app_id: RuleAppIDs is the rule app IDs filter. 
        :type rule_app_id: list[str]
        :param function: FunctionName is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param ns: Namespaces is the list of namespaces to use for filtering. 
        :type ns: list[str]
        :param app_id: AppIDs is the app embedded appID filter. 
        :type app_id: list[str]
        :param subnet: Subnets is the source IPs filter. 
        :type subnet: list[str]
        :param connecting_ips: ConnectingIPs is the connecting IPs filter. 
        :type connecting_ips: list[str]
        :param country: Countries is the source IP country filter. 
        :type country: list[str]
        :param user_agent_header: UserAgents is the user agent header filter. 
        :type user_agent_header: list[str]
        :param url: URLs is the URL filter. 
        :type url: list[str]
        :param request_host: RequestHosts is the request host filter. 
        :type request_host: list[str]
        :param url_path: Paths is the URL path filter. 
        :type url_path: list[str]
        :param url_query: Queries is the URL query filter. 
        :type url_query: list[str]
        :param method: Methods is the request method filter. 
        :type method: list[str]
        :param request_header_names: RequestHeaderNames is the request header names filter. 
        :type request_header_names: list[str]
        :param os: OS is the OS filter. 
        :type os: list[str]
        :param msg: Messages is the audit message text filter. 
        :type msg: list[str]
        :param cluster: Cluster is the audit cluster filter. 
        :type cluster: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param protection: Protections is the firewall audit protection type filter. 
        :type protection: list[str]
        :param buckets: Buckets is the number of buckets to return. 
        :type buckets: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[TypesAuditTimeslice], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'offset',
            'limit',
            'search',
            'sort',
            'reverse',
            'collections',
            'account_ids',
            'fields',
            '_from',
            'to',
            'image_name',
            'container_name',
            'hostname',
            'rule_name',
            'type',
            'effect',
            'rule_app_id',
            'function',
            'region',
            'runtime',
            'ns',
            'app_id',
            'subnet',
            'connecting_ips',
            'country',
            'user_agent_header',
            'url',
            'request_host',
            'url_path',
            'url_query',
            'method',
            'request_header_names',
            'os',
            'msg',
            'cluster',
            'attack_techniques',
            'aggregate',
            'protection',
            'buckets'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_firewall_app_host_timeslice_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'reverse' in local_var_params and local_var_params['reverse'] is not None:  # noqa: E501
            query_params.append(('reverse', local_var_params['reverse']))  # noqa: E501
        if 'collections' in local_var_params and local_var_params['collections'] is not None:  # noqa: E501
            query_params.append(('collections', local_var_params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'account_ids' in local_var_params and local_var_params['account_ids'] is not None:  # noqa: E501
            query_params.append(('accountIDs', local_var_params['account_ids']))  # noqa: E501
            collection_formats['accountIDs'] = 'multi'  # noqa: E501
        if 'fields' in local_var_params and local_var_params['fields'] is not None:  # noqa: E501
            query_params.append(('fields', local_var_params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if '_from' in local_var_params and local_var_params['_from'] is not None:  # noqa: E501
            query_params.append(('from', local_var_params['_from']))  # noqa: E501
        if 'to' in local_var_params and local_var_params['to'] is not None:  # noqa: E501
            query_params.append(('to', local_var_params['to']))  # noqa: E501
        if 'image_name' in local_var_params and local_var_params['image_name'] is not None:  # noqa: E501
            query_params.append(('imageName', local_var_params['image_name']))  # noqa: E501
            collection_formats['imageName'] = 'multi'  # noqa: E501
        if 'container_name' in local_var_params and local_var_params['container_name'] is not None:  # noqa: E501
            query_params.append(('containerName', local_var_params['container_name']))  # noqa: E501
            collection_formats['containerName'] = 'multi'  # noqa: E501
        if 'hostname' in local_var_params and local_var_params['hostname'] is not None:  # noqa: E501
            query_params.append(('hostname', local_var_params['hostname']))  # noqa: E501
            collection_formats['hostname'] = 'multi'  # noqa: E501
        if 'rule_name' in local_var_params and local_var_params['rule_name'] is not None:  # noqa: E501
            query_params.append(('ruleName', local_var_params['rule_name']))  # noqa: E501
            collection_formats['ruleName'] = 'multi'  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
            collection_formats['type'] = 'multi'  # noqa: E501
        if 'effect' in local_var_params and local_var_params['effect'] is not None:  # noqa: E501
            query_params.append(('effect', local_var_params['effect']))  # noqa: E501
        if 'rule_app_id' in local_var_params and local_var_params['rule_app_id'] is not None:  # noqa: E501
            query_params.append(('ruleAppID', local_var_params['rule_app_id']))  # noqa: E501
            collection_formats['ruleAppID'] = 'multi'  # noqa: E501
        if 'function' in local_var_params and local_var_params['function'] is not None:  # noqa: E501
            query_params.append(('function', local_var_params['function']))  # noqa: E501
            collection_formats['function'] = 'multi'  # noqa: E501
        if 'region' in local_var_params and local_var_params['region'] is not None:  # noqa: E501
            query_params.append(('region', local_var_params['region']))  # noqa: E501
            collection_formats['region'] = 'multi'  # noqa: E501
        if 'runtime' in local_var_params and local_var_params['runtime'] is not None:  # noqa: E501
            query_params.append(('runtime', local_var_params['runtime']))  # noqa: E501
            collection_formats['runtime'] = 'multi'  # noqa: E501
        if 'ns' in local_var_params and local_var_params['ns'] is not None:  # noqa: E501
            query_params.append(('ns', local_var_params['ns']))  # noqa: E501
            collection_formats['ns'] = 'multi'  # noqa: E501
        if 'app_id' in local_var_params and local_var_params['app_id'] is not None:  # noqa: E501
            query_params.append(('appID', local_var_params['app_id']))  # noqa: E501
            collection_formats['appID'] = 'multi'  # noqa: E501
        if 'subnet' in local_var_params and local_var_params['subnet'] is not None:  # noqa: E501
            query_params.append(('subnet', local_var_params['subnet']))  # noqa: E501
            collection_formats['subnet'] = 'multi'  # noqa: E501
        if 'connecting_ips' in local_var_params and local_var_params['connecting_ips'] is not None:  # noqa: E501
            query_params.append(('connectingIPs', local_var_params['connecting_ips']))  # noqa: E501
            collection_formats['connectingIPs'] = 'multi'  # noqa: E501
        if 'country' in local_var_params and local_var_params['country'] is not None:  # noqa: E501
            query_params.append(('country', local_var_params['country']))  # noqa: E501
            collection_formats['country'] = 'multi'  # noqa: E501
        if 'user_agent_header' in local_var_params and local_var_params['user_agent_header'] is not None:  # noqa: E501
            query_params.append(('userAgentHeader', local_var_params['user_agent_header']))  # noqa: E501
            collection_formats['userAgentHeader'] = 'multi'  # noqa: E501
        if 'url' in local_var_params and local_var_params['url'] is not None:  # noqa: E501
            query_params.append(('url', local_var_params['url']))  # noqa: E501
            collection_formats['url'] = 'multi'  # noqa: E501
        if 'request_host' in local_var_params and local_var_params['request_host'] is not None:  # noqa: E501
            query_params.append(('requestHost', local_var_params['request_host']))  # noqa: E501
            collection_formats['requestHost'] = 'multi'  # noqa: E501
        if 'url_path' in local_var_params and local_var_params['url_path'] is not None:  # noqa: E501
            query_params.append(('urlPath', local_var_params['url_path']))  # noqa: E501
            collection_formats['urlPath'] = 'multi'  # noqa: E501
        if 'url_query' in local_var_params and local_var_params['url_query'] is not None:  # noqa: E501
            query_params.append(('urlQuery', local_var_params['url_query']))  # noqa: E501
            collection_formats['urlQuery'] = 'multi'  # noqa: E501
        if 'method' in local_var_params and local_var_params['method'] is not None:  # noqa: E501
            query_params.append(('method', local_var_params['method']))  # noqa: E501
            collection_formats['method'] = 'multi'  # noqa: E501
        if 'request_header_names' in local_var_params and local_var_params['request_header_names'] is not None:  # noqa: E501
            query_params.append(('requestHeaderNames', local_var_params['request_header_names']))  # noqa: E501
            collection_formats['requestHeaderNames'] = 'multi'  # noqa: E501
        if 'os' in local_var_params and local_var_params['os'] is not None:  # noqa: E501
            query_params.append(('os', local_var_params['os']))  # noqa: E501
            collection_formats['os'] = 'multi'  # noqa: E501
        if 'msg' in local_var_params and local_var_params['msg'] is not None:  # noqa: E501
            query_params.append(('msg', local_var_params['msg']))  # noqa: E501
            collection_formats['msg'] = 'multi'  # noqa: E501
        if 'cluster' in local_var_params and local_var_params['cluster'] is not None:  # noqa: E501
            query_params.append(('cluster', local_var_params['cluster']))  # noqa: E501
            collection_formats['cluster'] = 'multi'  # noqa: E501
        if 'attack_techniques' in local_var_params and local_var_params['attack_techniques'] is not None:  # noqa: E501
            query_params.append(('attackTechniques', local_var_params['attack_techniques']))  # noqa: E501
            collection_formats['attackTechniques'] = 'multi'  # noqa: E501
        if 'aggregate' in local_var_params and local_var_params['aggregate'] is not None:  # noqa: E501
            query_params.append(('aggregate', local_var_params['aggregate']))  # noqa: E501
        if 'protection' in local_var_params and local_var_params['protection'] is not None:  # noqa: E501
            query_params.append(('protection', local_var_params['protection']))  # noqa: E501
            collection_formats['protection'] = 'multi'  # noqa: E501
        if 'buckets' in local_var_params and local_var_params['buckets'] is not None:  # noqa: E501
            query_params.append(('buckets', local_var_params['buckets']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "list[TypesAuditTimeslice]",
        }

        return self.api_client.call_api(
            '/api/v1/audits/firewall/app/host/timeslice', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_firewall_app_serverless_download_get(self, **kwargs):  # noqa: E501
        """api_v1_audits_firewall_app_serverless_download_get  # noqa: E501

        DownloadServerlessAppFirewallAudits downloads the serverless firewall audits according to the specified query   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_firewall_app_serverless_download_get(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param image_name: Images is the image names filter. 
        :type image_name: list[str]
        :param container_name: Containers is the container names filter. 
        :type container_name: list[str]
        :param hostname: Hosts is the hostnames filter. 
        :type hostname: list[str]
        :param rule_name: RuleNames is the rule names filter. 
        :type rule_name: list[str]
        :param type: Types is the firewall audit type filter. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect. 
        :type effect: str
        :param rule_app_id: RuleAppIDs is the rule app IDs filter. 
        :type rule_app_id: list[str]
        :param function: FunctionName is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param ns: Namespaces is the list of namespaces to use for filtering. 
        :type ns: list[str]
        :param app_id: AppIDs is the app embedded appID filter. 
        :type app_id: list[str]
        :param subnet: Subnets is the source IPs filter. 
        :type subnet: list[str]
        :param connecting_ips: ConnectingIPs is the connecting IPs filter. 
        :type connecting_ips: list[str]
        :param country: Countries is the source IP country filter. 
        :type country: list[str]
        :param user_agent_header: UserAgents is the user agent header filter. 
        :type user_agent_header: list[str]
        :param url: URLs is the URL filter. 
        :type url: list[str]
        :param request_host: RequestHosts is the request host filter. 
        :type request_host: list[str]
        :param url_path: Paths is the URL path filter. 
        :type url_path: list[str]
        :param url_query: Queries is the URL query filter. 
        :type url_query: list[str]
        :param method: Methods is the request method filter. 
        :type method: list[str]
        :param request_header_names: RequestHeaderNames is the request header names filter. 
        :type request_header_names: list[str]
        :param os: OS is the OS filter. 
        :type os: list[str]
        :param msg: Messages is the audit message text filter. 
        :type msg: list[str]
        :param cluster: Cluster is the audit cluster filter. 
        :type cluster: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param protection: Protections is the firewall audit protection type filter. 
        :type protection: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_firewall_app_serverless_download_get_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_firewall_app_serverless_download_get_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_firewall_app_serverless_download_get  # noqa: E501

        DownloadServerlessAppFirewallAudits downloads the serverless firewall audits according to the specified query   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_firewall_app_serverless_download_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param image_name: Images is the image names filter. 
        :type image_name: list[str]
        :param container_name: Containers is the container names filter. 
        :type container_name: list[str]
        :param hostname: Hosts is the hostnames filter. 
        :type hostname: list[str]
        :param rule_name: RuleNames is the rule names filter. 
        :type rule_name: list[str]
        :param type: Types is the firewall audit type filter. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect. 
        :type effect: str
        :param rule_app_id: RuleAppIDs is the rule app IDs filter. 
        :type rule_app_id: list[str]
        :param function: FunctionName is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param ns: Namespaces is the list of namespaces to use for filtering. 
        :type ns: list[str]
        :param app_id: AppIDs is the app embedded appID filter. 
        :type app_id: list[str]
        :param subnet: Subnets is the source IPs filter. 
        :type subnet: list[str]
        :param connecting_ips: ConnectingIPs is the connecting IPs filter. 
        :type connecting_ips: list[str]
        :param country: Countries is the source IP country filter. 
        :type country: list[str]
        :param user_agent_header: UserAgents is the user agent header filter. 
        :type user_agent_header: list[str]
        :param url: URLs is the URL filter. 
        :type url: list[str]
        :param request_host: RequestHosts is the request host filter. 
        :type request_host: list[str]
        :param url_path: Paths is the URL path filter. 
        :type url_path: list[str]
        :param url_query: Queries is the URL query filter. 
        :type url_query: list[str]
        :param method: Methods is the request method filter. 
        :type method: list[str]
        :param request_header_names: RequestHeaderNames is the request header names filter. 
        :type request_header_names: list[str]
        :param os: OS is the OS filter. 
        :type os: list[str]
        :param msg: Messages is the audit message text filter. 
        :type msg: list[str]
        :param cluster: Cluster is the audit cluster filter. 
        :type cluster: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param protection: Protections is the firewall audit protection type filter. 
        :type protection: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'offset',
            'limit',
            'search',
            'sort',
            'reverse',
            'collections',
            'account_ids',
            'fields',
            '_from',
            'to',
            'image_name',
            'container_name',
            'hostname',
            'rule_name',
            'type',
            'effect',
            'rule_app_id',
            'function',
            'region',
            'runtime',
            'ns',
            'app_id',
            'subnet',
            'connecting_ips',
            'country',
            'user_agent_header',
            'url',
            'request_host',
            'url_path',
            'url_query',
            'method',
            'request_header_names',
            'os',
            'msg',
            'cluster',
            'attack_techniques',
            'aggregate',
            'protection'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_firewall_app_serverless_download_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'reverse' in local_var_params and local_var_params['reverse'] is not None:  # noqa: E501
            query_params.append(('reverse', local_var_params['reverse']))  # noqa: E501
        if 'collections' in local_var_params and local_var_params['collections'] is not None:  # noqa: E501
            query_params.append(('collections', local_var_params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'account_ids' in local_var_params and local_var_params['account_ids'] is not None:  # noqa: E501
            query_params.append(('accountIDs', local_var_params['account_ids']))  # noqa: E501
            collection_formats['accountIDs'] = 'multi'  # noqa: E501
        if 'fields' in local_var_params and local_var_params['fields'] is not None:  # noqa: E501
            query_params.append(('fields', local_var_params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if '_from' in local_var_params and local_var_params['_from'] is not None:  # noqa: E501
            query_params.append(('from', local_var_params['_from']))  # noqa: E501
        if 'to' in local_var_params and local_var_params['to'] is not None:  # noqa: E501
            query_params.append(('to', local_var_params['to']))  # noqa: E501
        if 'image_name' in local_var_params and local_var_params['image_name'] is not None:  # noqa: E501
            query_params.append(('imageName', local_var_params['image_name']))  # noqa: E501
            collection_formats['imageName'] = 'multi'  # noqa: E501
        if 'container_name' in local_var_params and local_var_params['container_name'] is not None:  # noqa: E501
            query_params.append(('containerName', local_var_params['container_name']))  # noqa: E501
            collection_formats['containerName'] = 'multi'  # noqa: E501
        if 'hostname' in local_var_params and local_var_params['hostname'] is not None:  # noqa: E501
            query_params.append(('hostname', local_var_params['hostname']))  # noqa: E501
            collection_formats['hostname'] = 'multi'  # noqa: E501
        if 'rule_name' in local_var_params and local_var_params['rule_name'] is not None:  # noqa: E501
            query_params.append(('ruleName', local_var_params['rule_name']))  # noqa: E501
            collection_formats['ruleName'] = 'multi'  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
            collection_formats['type'] = 'multi'  # noqa: E501
        if 'effect' in local_var_params and local_var_params['effect'] is not None:  # noqa: E501
            query_params.append(('effect', local_var_params['effect']))  # noqa: E501
        if 'rule_app_id' in local_var_params and local_var_params['rule_app_id'] is not None:  # noqa: E501
            query_params.append(('ruleAppID', local_var_params['rule_app_id']))  # noqa: E501
            collection_formats['ruleAppID'] = 'multi'  # noqa: E501
        if 'function' in local_var_params and local_var_params['function'] is not None:  # noqa: E501
            query_params.append(('function', local_var_params['function']))  # noqa: E501
            collection_formats['function'] = 'multi'  # noqa: E501
        if 'region' in local_var_params and local_var_params['region'] is not None:  # noqa: E501
            query_params.append(('region', local_var_params['region']))  # noqa: E501
            collection_formats['region'] = 'multi'  # noqa: E501
        if 'runtime' in local_var_params and local_var_params['runtime'] is not None:  # noqa: E501
            query_params.append(('runtime', local_var_params['runtime']))  # noqa: E501
            collection_formats['runtime'] = 'multi'  # noqa: E501
        if 'ns' in local_var_params and local_var_params['ns'] is not None:  # noqa: E501
            query_params.append(('ns', local_var_params['ns']))  # noqa: E501
            collection_formats['ns'] = 'multi'  # noqa: E501
        if 'app_id' in local_var_params and local_var_params['app_id'] is not None:  # noqa: E501
            query_params.append(('appID', local_var_params['app_id']))  # noqa: E501
            collection_formats['appID'] = 'multi'  # noqa: E501
        if 'subnet' in local_var_params and local_var_params['subnet'] is not None:  # noqa: E501
            query_params.append(('subnet', local_var_params['subnet']))  # noqa: E501
            collection_formats['subnet'] = 'multi'  # noqa: E501
        if 'connecting_ips' in local_var_params and local_var_params['connecting_ips'] is not None:  # noqa: E501
            query_params.append(('connectingIPs', local_var_params['connecting_ips']))  # noqa: E501
            collection_formats['connectingIPs'] = 'multi'  # noqa: E501
        if 'country' in local_var_params and local_var_params['country'] is not None:  # noqa: E501
            query_params.append(('country', local_var_params['country']))  # noqa: E501
            collection_formats['country'] = 'multi'  # noqa: E501
        if 'user_agent_header' in local_var_params and local_var_params['user_agent_header'] is not None:  # noqa: E501
            query_params.append(('userAgentHeader', local_var_params['user_agent_header']))  # noqa: E501
            collection_formats['userAgentHeader'] = 'multi'  # noqa: E501
        if 'url' in local_var_params and local_var_params['url'] is not None:  # noqa: E501
            query_params.append(('url', local_var_params['url']))  # noqa: E501
            collection_formats['url'] = 'multi'  # noqa: E501
        if 'request_host' in local_var_params and local_var_params['request_host'] is not None:  # noqa: E501
            query_params.append(('requestHost', local_var_params['request_host']))  # noqa: E501
            collection_formats['requestHost'] = 'multi'  # noqa: E501
        if 'url_path' in local_var_params and local_var_params['url_path'] is not None:  # noqa: E501
            query_params.append(('urlPath', local_var_params['url_path']))  # noqa: E501
            collection_formats['urlPath'] = 'multi'  # noqa: E501
        if 'url_query' in local_var_params and local_var_params['url_query'] is not None:  # noqa: E501
            query_params.append(('urlQuery', local_var_params['url_query']))  # noqa: E501
            collection_formats['urlQuery'] = 'multi'  # noqa: E501
        if 'method' in local_var_params and local_var_params['method'] is not None:  # noqa: E501
            query_params.append(('method', local_var_params['method']))  # noqa: E501
            collection_formats['method'] = 'multi'  # noqa: E501
        if 'request_header_names' in local_var_params and local_var_params['request_header_names'] is not None:  # noqa: E501
            query_params.append(('requestHeaderNames', local_var_params['request_header_names']))  # noqa: E501
            collection_formats['requestHeaderNames'] = 'multi'  # noqa: E501
        if 'os' in local_var_params and local_var_params['os'] is not None:  # noqa: E501
            query_params.append(('os', local_var_params['os']))  # noqa: E501
            collection_formats['os'] = 'multi'  # noqa: E501
        if 'msg' in local_var_params and local_var_params['msg'] is not None:  # noqa: E501
            query_params.append(('msg', local_var_params['msg']))  # noqa: E501
            collection_formats['msg'] = 'multi'  # noqa: E501
        if 'cluster' in local_var_params and local_var_params['cluster'] is not None:  # noqa: E501
            query_params.append(('cluster', local_var_params['cluster']))  # noqa: E501
            collection_formats['cluster'] = 'multi'  # noqa: E501
        if 'attack_techniques' in local_var_params and local_var_params['attack_techniques'] is not None:  # noqa: E501
            query_params.append(('attackTechniques', local_var_params['attack_techniques']))  # noqa: E501
            collection_formats['attackTechniques'] = 'multi'  # noqa: E501
        if 'aggregate' in local_var_params and local_var_params['aggregate'] is not None:  # noqa: E501
            query_params.append(('aggregate', local_var_params['aggregate']))  # noqa: E501
        if 'protection' in local_var_params and local_var_params['protection'] is not None:  # noqa: E501
            query_params.append(('protection', local_var_params['protection']))  # noqa: E501
            collection_formats['protection'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/audits/firewall/app/serverless/download', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_firewall_app_serverless_get(self, **kwargs):  # noqa: E501
        """api_v1_audits_firewall_app_serverless_get  # noqa: E501

        ServerlessAppFirewallAudits returns all serverless firewall audits according to the query specification   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_firewall_app_serverless_get(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param image_name: Images is the image names filter. 
        :type image_name: list[str]
        :param container_name: Containers is the container names filter. 
        :type container_name: list[str]
        :param hostname: Hosts is the hostnames filter. 
        :type hostname: list[str]
        :param rule_name: RuleNames is the rule names filter. 
        :type rule_name: list[str]
        :param type: Types is the firewall audit type filter. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect. 
        :type effect: str
        :param rule_app_id: RuleAppIDs is the rule app IDs filter. 
        :type rule_app_id: list[str]
        :param function: FunctionName is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param ns: Namespaces is the list of namespaces to use for filtering. 
        :type ns: list[str]
        :param app_id: AppIDs is the app embedded appID filter. 
        :type app_id: list[str]
        :param subnet: Subnets is the source IPs filter. 
        :type subnet: list[str]
        :param connecting_ips: ConnectingIPs is the connecting IPs filter. 
        :type connecting_ips: list[str]
        :param country: Countries is the source IP country filter. 
        :type country: list[str]
        :param user_agent_header: UserAgents is the user agent header filter. 
        :type user_agent_header: list[str]
        :param url: URLs is the URL filter. 
        :type url: list[str]
        :param request_host: RequestHosts is the request host filter. 
        :type request_host: list[str]
        :param url_path: Paths is the URL path filter. 
        :type url_path: list[str]
        :param url_query: Queries is the URL query filter. 
        :type url_query: list[str]
        :param method: Methods is the request method filter. 
        :type method: list[str]
        :param request_header_names: RequestHeaderNames is the request header names filter. 
        :type request_header_names: list[str]
        :param os: OS is the OS filter. 
        :type os: list[str]
        :param msg: Messages is the audit message text filter. 
        :type msg: list[str]
        :param cluster: Cluster is the audit cluster filter. 
        :type cluster: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param protection: Protections is the firewall audit protection type filter. 
        :type protection: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[SharedAppFirewallAudit]
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_firewall_app_serverless_get_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_firewall_app_serverless_get_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_firewall_app_serverless_get  # noqa: E501

        ServerlessAppFirewallAudits returns all serverless firewall audits according to the query specification   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_firewall_app_serverless_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param image_name: Images is the image names filter. 
        :type image_name: list[str]
        :param container_name: Containers is the container names filter. 
        :type container_name: list[str]
        :param hostname: Hosts is the hostnames filter. 
        :type hostname: list[str]
        :param rule_name: RuleNames is the rule names filter. 
        :type rule_name: list[str]
        :param type: Types is the firewall audit type filter. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect. 
        :type effect: str
        :param rule_app_id: RuleAppIDs is the rule app IDs filter. 
        :type rule_app_id: list[str]
        :param function: FunctionName is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param ns: Namespaces is the list of namespaces to use for filtering. 
        :type ns: list[str]
        :param app_id: AppIDs is the app embedded appID filter. 
        :type app_id: list[str]
        :param subnet: Subnets is the source IPs filter. 
        :type subnet: list[str]
        :param connecting_ips: ConnectingIPs is the connecting IPs filter. 
        :type connecting_ips: list[str]
        :param country: Countries is the source IP country filter. 
        :type country: list[str]
        :param user_agent_header: UserAgents is the user agent header filter. 
        :type user_agent_header: list[str]
        :param url: URLs is the URL filter. 
        :type url: list[str]
        :param request_host: RequestHosts is the request host filter. 
        :type request_host: list[str]
        :param url_path: Paths is the URL path filter. 
        :type url_path: list[str]
        :param url_query: Queries is the URL query filter. 
        :type url_query: list[str]
        :param method: Methods is the request method filter. 
        :type method: list[str]
        :param request_header_names: RequestHeaderNames is the request header names filter. 
        :type request_header_names: list[str]
        :param os: OS is the OS filter. 
        :type os: list[str]
        :param msg: Messages is the audit message text filter. 
        :type msg: list[str]
        :param cluster: Cluster is the audit cluster filter. 
        :type cluster: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param protection: Protections is the firewall audit protection type filter. 
        :type protection: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[SharedAppFirewallAudit], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'offset',
            'limit',
            'search',
            'sort',
            'reverse',
            'collections',
            'account_ids',
            'fields',
            '_from',
            'to',
            'image_name',
            'container_name',
            'hostname',
            'rule_name',
            'type',
            'effect',
            'rule_app_id',
            'function',
            'region',
            'runtime',
            'ns',
            'app_id',
            'subnet',
            'connecting_ips',
            'country',
            'user_agent_header',
            'url',
            'request_host',
            'url_path',
            'url_query',
            'method',
            'request_header_names',
            'os',
            'msg',
            'cluster',
            'attack_techniques',
            'aggregate',
            'protection'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_firewall_app_serverless_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'reverse' in local_var_params and local_var_params['reverse'] is not None:  # noqa: E501
            query_params.append(('reverse', local_var_params['reverse']))  # noqa: E501
        if 'collections' in local_var_params and local_var_params['collections'] is not None:  # noqa: E501
            query_params.append(('collections', local_var_params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'account_ids' in local_var_params and local_var_params['account_ids'] is not None:  # noqa: E501
            query_params.append(('accountIDs', local_var_params['account_ids']))  # noqa: E501
            collection_formats['accountIDs'] = 'multi'  # noqa: E501
        if 'fields' in local_var_params and local_var_params['fields'] is not None:  # noqa: E501
            query_params.append(('fields', local_var_params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if '_from' in local_var_params and local_var_params['_from'] is not None:  # noqa: E501
            query_params.append(('from', local_var_params['_from']))  # noqa: E501
        if 'to' in local_var_params and local_var_params['to'] is not None:  # noqa: E501
            query_params.append(('to', local_var_params['to']))  # noqa: E501
        if 'image_name' in local_var_params and local_var_params['image_name'] is not None:  # noqa: E501
            query_params.append(('imageName', local_var_params['image_name']))  # noqa: E501
            collection_formats['imageName'] = 'multi'  # noqa: E501
        if 'container_name' in local_var_params and local_var_params['container_name'] is not None:  # noqa: E501
            query_params.append(('containerName', local_var_params['container_name']))  # noqa: E501
            collection_formats['containerName'] = 'multi'  # noqa: E501
        if 'hostname' in local_var_params and local_var_params['hostname'] is not None:  # noqa: E501
            query_params.append(('hostname', local_var_params['hostname']))  # noqa: E501
            collection_formats['hostname'] = 'multi'  # noqa: E501
        if 'rule_name' in local_var_params and local_var_params['rule_name'] is not None:  # noqa: E501
            query_params.append(('ruleName', local_var_params['rule_name']))  # noqa: E501
            collection_formats['ruleName'] = 'multi'  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
            collection_formats['type'] = 'multi'  # noqa: E501
        if 'effect' in local_var_params and local_var_params['effect'] is not None:  # noqa: E501
            query_params.append(('effect', local_var_params['effect']))  # noqa: E501
        if 'rule_app_id' in local_var_params and local_var_params['rule_app_id'] is not None:  # noqa: E501
            query_params.append(('ruleAppID', local_var_params['rule_app_id']))  # noqa: E501
            collection_formats['ruleAppID'] = 'multi'  # noqa: E501
        if 'function' in local_var_params and local_var_params['function'] is not None:  # noqa: E501
            query_params.append(('function', local_var_params['function']))  # noqa: E501
            collection_formats['function'] = 'multi'  # noqa: E501
        if 'region' in local_var_params and local_var_params['region'] is not None:  # noqa: E501
            query_params.append(('region', local_var_params['region']))  # noqa: E501
            collection_formats['region'] = 'multi'  # noqa: E501
        if 'runtime' in local_var_params and local_var_params['runtime'] is not None:  # noqa: E501
            query_params.append(('runtime', local_var_params['runtime']))  # noqa: E501
            collection_formats['runtime'] = 'multi'  # noqa: E501
        if 'ns' in local_var_params and local_var_params['ns'] is not None:  # noqa: E501
            query_params.append(('ns', local_var_params['ns']))  # noqa: E501
            collection_formats['ns'] = 'multi'  # noqa: E501
        if 'app_id' in local_var_params and local_var_params['app_id'] is not None:  # noqa: E501
            query_params.append(('appID', local_var_params['app_id']))  # noqa: E501
            collection_formats['appID'] = 'multi'  # noqa: E501
        if 'subnet' in local_var_params and local_var_params['subnet'] is not None:  # noqa: E501
            query_params.append(('subnet', local_var_params['subnet']))  # noqa: E501
            collection_formats['subnet'] = 'multi'  # noqa: E501
        if 'connecting_ips' in local_var_params and local_var_params['connecting_ips'] is not None:  # noqa: E501
            query_params.append(('connectingIPs', local_var_params['connecting_ips']))  # noqa: E501
            collection_formats['connectingIPs'] = 'multi'  # noqa: E501
        if 'country' in local_var_params and local_var_params['country'] is not None:  # noqa: E501
            query_params.append(('country', local_var_params['country']))  # noqa: E501
            collection_formats['country'] = 'multi'  # noqa: E501
        if 'user_agent_header' in local_var_params and local_var_params['user_agent_header'] is not None:  # noqa: E501
            query_params.append(('userAgentHeader', local_var_params['user_agent_header']))  # noqa: E501
            collection_formats['userAgentHeader'] = 'multi'  # noqa: E501
        if 'url' in local_var_params and local_var_params['url'] is not None:  # noqa: E501
            query_params.append(('url', local_var_params['url']))  # noqa: E501
            collection_formats['url'] = 'multi'  # noqa: E501
        if 'request_host' in local_var_params and local_var_params['request_host'] is not None:  # noqa: E501
            query_params.append(('requestHost', local_var_params['request_host']))  # noqa: E501
            collection_formats['requestHost'] = 'multi'  # noqa: E501
        if 'url_path' in local_var_params and local_var_params['url_path'] is not None:  # noqa: E501
            query_params.append(('urlPath', local_var_params['url_path']))  # noqa: E501
            collection_formats['urlPath'] = 'multi'  # noqa: E501
        if 'url_query' in local_var_params and local_var_params['url_query'] is not None:  # noqa: E501
            query_params.append(('urlQuery', local_var_params['url_query']))  # noqa: E501
            collection_formats['urlQuery'] = 'multi'  # noqa: E501
        if 'method' in local_var_params and local_var_params['method'] is not None:  # noqa: E501
            query_params.append(('method', local_var_params['method']))  # noqa: E501
            collection_formats['method'] = 'multi'  # noqa: E501
        if 'request_header_names' in local_var_params and local_var_params['request_header_names'] is not None:  # noqa: E501
            query_params.append(('requestHeaderNames', local_var_params['request_header_names']))  # noqa: E501
            collection_formats['requestHeaderNames'] = 'multi'  # noqa: E501
        if 'os' in local_var_params and local_var_params['os'] is not None:  # noqa: E501
            query_params.append(('os', local_var_params['os']))  # noqa: E501
            collection_formats['os'] = 'multi'  # noqa: E501
        if 'msg' in local_var_params and local_var_params['msg'] is not None:  # noqa: E501
            query_params.append(('msg', local_var_params['msg']))  # noqa: E501
            collection_formats['msg'] = 'multi'  # noqa: E501
        if 'cluster' in local_var_params and local_var_params['cluster'] is not None:  # noqa: E501
            query_params.append(('cluster', local_var_params['cluster']))  # noqa: E501
            collection_formats['cluster'] = 'multi'  # noqa: E501
        if 'attack_techniques' in local_var_params and local_var_params['attack_techniques'] is not None:  # noqa: E501
            query_params.append(('attackTechniques', local_var_params['attack_techniques']))  # noqa: E501
            collection_formats['attackTechniques'] = 'multi'  # noqa: E501
        if 'aggregate' in local_var_params and local_var_params['aggregate'] is not None:  # noqa: E501
            query_params.append(('aggregate', local_var_params['aggregate']))  # noqa: E501
        if 'protection' in local_var_params and local_var_params['protection'] is not None:  # noqa: E501
            query_params.append(('protection', local_var_params['protection']))  # noqa: E501
            collection_formats['protection'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "list[SharedAppFirewallAudit]",
        }

        return self.api_client.call_api(
            '/api/v1/audits/firewall/app/serverless', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_firewall_app_serverless_timeslice_get(self, **kwargs):  # noqa: E501
        """api_v1_audits_firewall_app_serverless_timeslice_get  # noqa: E501

        ServerlessAppFirewallAuditTimeslice returns serverless firewall audit buckets according to the query timeframe   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_firewall_app_serverless_timeslice_get(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param image_name: Images is the image names filter. 
        :type image_name: list[str]
        :param container_name: Containers is the container names filter. 
        :type container_name: list[str]
        :param hostname: Hosts is the hostnames filter. 
        :type hostname: list[str]
        :param rule_name: RuleNames is the rule names filter. 
        :type rule_name: list[str]
        :param type: Types is the firewall audit type filter. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect. 
        :type effect: str
        :param rule_app_id: RuleAppIDs is the rule app IDs filter. 
        :type rule_app_id: list[str]
        :param function: FunctionName is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param ns: Namespaces is the list of namespaces to use for filtering. 
        :type ns: list[str]
        :param app_id: AppIDs is the app embedded appID filter. 
        :type app_id: list[str]
        :param subnet: Subnets is the source IPs filter. 
        :type subnet: list[str]
        :param connecting_ips: ConnectingIPs is the connecting IPs filter. 
        :type connecting_ips: list[str]
        :param country: Countries is the source IP country filter. 
        :type country: list[str]
        :param user_agent_header: UserAgents is the user agent header filter. 
        :type user_agent_header: list[str]
        :param url: URLs is the URL filter. 
        :type url: list[str]
        :param request_host: RequestHosts is the request host filter. 
        :type request_host: list[str]
        :param url_path: Paths is the URL path filter. 
        :type url_path: list[str]
        :param url_query: Queries is the URL query filter. 
        :type url_query: list[str]
        :param method: Methods is the request method filter. 
        :type method: list[str]
        :param request_header_names: RequestHeaderNames is the request header names filter. 
        :type request_header_names: list[str]
        :param os: OS is the OS filter. 
        :type os: list[str]
        :param msg: Messages is the audit message text filter. 
        :type msg: list[str]
        :param cluster: Cluster is the audit cluster filter. 
        :type cluster: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param protection: Protections is the firewall audit protection type filter. 
        :type protection: list[str]
        :param buckets: Buckets is the number of buckets to return. 
        :type buckets: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[TypesAuditTimeslice]
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_firewall_app_serverless_timeslice_get_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_firewall_app_serverless_timeslice_get_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_firewall_app_serverless_timeslice_get  # noqa: E501

        ServerlessAppFirewallAuditTimeslice returns serverless firewall audit buckets according to the query timeframe   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_firewall_app_serverless_timeslice_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param image_name: Images is the image names filter. 
        :type image_name: list[str]
        :param container_name: Containers is the container names filter. 
        :type container_name: list[str]
        :param hostname: Hosts is the hostnames filter. 
        :type hostname: list[str]
        :param rule_name: RuleNames is the rule names filter. 
        :type rule_name: list[str]
        :param type: Types is the firewall audit type filter. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect. 
        :type effect: str
        :param rule_app_id: RuleAppIDs is the rule app IDs filter. 
        :type rule_app_id: list[str]
        :param function: FunctionName is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param ns: Namespaces is the list of namespaces to use for filtering. 
        :type ns: list[str]
        :param app_id: AppIDs is the app embedded appID filter. 
        :type app_id: list[str]
        :param subnet: Subnets is the source IPs filter. 
        :type subnet: list[str]
        :param connecting_ips: ConnectingIPs is the connecting IPs filter. 
        :type connecting_ips: list[str]
        :param country: Countries is the source IP country filter. 
        :type country: list[str]
        :param user_agent_header: UserAgents is the user agent header filter. 
        :type user_agent_header: list[str]
        :param url: URLs is the URL filter. 
        :type url: list[str]
        :param request_host: RequestHosts is the request host filter. 
        :type request_host: list[str]
        :param url_path: Paths is the URL path filter. 
        :type url_path: list[str]
        :param url_query: Queries is the URL query filter. 
        :type url_query: list[str]
        :param method: Methods is the request method filter. 
        :type method: list[str]
        :param request_header_names: RequestHeaderNames is the request header names filter. 
        :type request_header_names: list[str]
        :param os: OS is the OS filter. 
        :type os: list[str]
        :param msg: Messages is the audit message text filter. 
        :type msg: list[str]
        :param cluster: Cluster is the audit cluster filter. 
        :type cluster: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param protection: Protections is the firewall audit protection type filter. 
        :type protection: list[str]
        :param buckets: Buckets is the number of buckets to return. 
        :type buckets: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[TypesAuditTimeslice], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'offset',
            'limit',
            'search',
            'sort',
            'reverse',
            'collections',
            'account_ids',
            'fields',
            '_from',
            'to',
            'image_name',
            'container_name',
            'hostname',
            'rule_name',
            'type',
            'effect',
            'rule_app_id',
            'function',
            'region',
            'runtime',
            'ns',
            'app_id',
            'subnet',
            'connecting_ips',
            'country',
            'user_agent_header',
            'url',
            'request_host',
            'url_path',
            'url_query',
            'method',
            'request_header_names',
            'os',
            'msg',
            'cluster',
            'attack_techniques',
            'aggregate',
            'protection',
            'buckets'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_firewall_app_serverless_timeslice_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'reverse' in local_var_params and local_var_params['reverse'] is not None:  # noqa: E501
            query_params.append(('reverse', local_var_params['reverse']))  # noqa: E501
        if 'collections' in local_var_params and local_var_params['collections'] is not None:  # noqa: E501
            query_params.append(('collections', local_var_params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'account_ids' in local_var_params and local_var_params['account_ids'] is not None:  # noqa: E501
            query_params.append(('accountIDs', local_var_params['account_ids']))  # noqa: E501
            collection_formats['accountIDs'] = 'multi'  # noqa: E501
        if 'fields' in local_var_params and local_var_params['fields'] is not None:  # noqa: E501
            query_params.append(('fields', local_var_params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if '_from' in local_var_params and local_var_params['_from'] is not None:  # noqa: E501
            query_params.append(('from', local_var_params['_from']))  # noqa: E501
        if 'to' in local_var_params and local_var_params['to'] is not None:  # noqa: E501
            query_params.append(('to', local_var_params['to']))  # noqa: E501
        if 'image_name' in local_var_params and local_var_params['image_name'] is not None:  # noqa: E501
            query_params.append(('imageName', local_var_params['image_name']))  # noqa: E501
            collection_formats['imageName'] = 'multi'  # noqa: E501
        if 'container_name' in local_var_params and local_var_params['container_name'] is not None:  # noqa: E501
            query_params.append(('containerName', local_var_params['container_name']))  # noqa: E501
            collection_formats['containerName'] = 'multi'  # noqa: E501
        if 'hostname' in local_var_params and local_var_params['hostname'] is not None:  # noqa: E501
            query_params.append(('hostname', local_var_params['hostname']))  # noqa: E501
            collection_formats['hostname'] = 'multi'  # noqa: E501
        if 'rule_name' in local_var_params and local_var_params['rule_name'] is not None:  # noqa: E501
            query_params.append(('ruleName', local_var_params['rule_name']))  # noqa: E501
            collection_formats['ruleName'] = 'multi'  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
            collection_formats['type'] = 'multi'  # noqa: E501
        if 'effect' in local_var_params and local_var_params['effect'] is not None:  # noqa: E501
            query_params.append(('effect', local_var_params['effect']))  # noqa: E501
        if 'rule_app_id' in local_var_params and local_var_params['rule_app_id'] is not None:  # noqa: E501
            query_params.append(('ruleAppID', local_var_params['rule_app_id']))  # noqa: E501
            collection_formats['ruleAppID'] = 'multi'  # noqa: E501
        if 'function' in local_var_params and local_var_params['function'] is not None:  # noqa: E501
            query_params.append(('function', local_var_params['function']))  # noqa: E501
            collection_formats['function'] = 'multi'  # noqa: E501
        if 'region' in local_var_params and local_var_params['region'] is not None:  # noqa: E501
            query_params.append(('region', local_var_params['region']))  # noqa: E501
            collection_formats['region'] = 'multi'  # noqa: E501
        if 'runtime' in local_var_params and local_var_params['runtime'] is not None:  # noqa: E501
            query_params.append(('runtime', local_var_params['runtime']))  # noqa: E501
            collection_formats['runtime'] = 'multi'  # noqa: E501
        if 'ns' in local_var_params and local_var_params['ns'] is not None:  # noqa: E501
            query_params.append(('ns', local_var_params['ns']))  # noqa: E501
            collection_formats['ns'] = 'multi'  # noqa: E501
        if 'app_id' in local_var_params and local_var_params['app_id'] is not None:  # noqa: E501
            query_params.append(('appID', local_var_params['app_id']))  # noqa: E501
            collection_formats['appID'] = 'multi'  # noqa: E501
        if 'subnet' in local_var_params and local_var_params['subnet'] is not None:  # noqa: E501
            query_params.append(('subnet', local_var_params['subnet']))  # noqa: E501
            collection_formats['subnet'] = 'multi'  # noqa: E501
        if 'connecting_ips' in local_var_params and local_var_params['connecting_ips'] is not None:  # noqa: E501
            query_params.append(('connectingIPs', local_var_params['connecting_ips']))  # noqa: E501
            collection_formats['connectingIPs'] = 'multi'  # noqa: E501
        if 'country' in local_var_params and local_var_params['country'] is not None:  # noqa: E501
            query_params.append(('country', local_var_params['country']))  # noqa: E501
            collection_formats['country'] = 'multi'  # noqa: E501
        if 'user_agent_header' in local_var_params and local_var_params['user_agent_header'] is not None:  # noqa: E501
            query_params.append(('userAgentHeader', local_var_params['user_agent_header']))  # noqa: E501
            collection_formats['userAgentHeader'] = 'multi'  # noqa: E501
        if 'url' in local_var_params and local_var_params['url'] is not None:  # noqa: E501
            query_params.append(('url', local_var_params['url']))  # noqa: E501
            collection_formats['url'] = 'multi'  # noqa: E501
        if 'request_host' in local_var_params and local_var_params['request_host'] is not None:  # noqa: E501
            query_params.append(('requestHost', local_var_params['request_host']))  # noqa: E501
            collection_formats['requestHost'] = 'multi'  # noqa: E501
        if 'url_path' in local_var_params and local_var_params['url_path'] is not None:  # noqa: E501
            query_params.append(('urlPath', local_var_params['url_path']))  # noqa: E501
            collection_formats['urlPath'] = 'multi'  # noqa: E501
        if 'url_query' in local_var_params and local_var_params['url_query'] is not None:  # noqa: E501
            query_params.append(('urlQuery', local_var_params['url_query']))  # noqa: E501
            collection_formats['urlQuery'] = 'multi'  # noqa: E501
        if 'method' in local_var_params and local_var_params['method'] is not None:  # noqa: E501
            query_params.append(('method', local_var_params['method']))  # noqa: E501
            collection_formats['method'] = 'multi'  # noqa: E501
        if 'request_header_names' in local_var_params and local_var_params['request_header_names'] is not None:  # noqa: E501
            query_params.append(('requestHeaderNames', local_var_params['request_header_names']))  # noqa: E501
            collection_formats['requestHeaderNames'] = 'multi'  # noqa: E501
        if 'os' in local_var_params and local_var_params['os'] is not None:  # noqa: E501
            query_params.append(('os', local_var_params['os']))  # noqa: E501
            collection_formats['os'] = 'multi'  # noqa: E501
        if 'msg' in local_var_params and local_var_params['msg'] is not None:  # noqa: E501
            query_params.append(('msg', local_var_params['msg']))  # noqa: E501
            collection_formats['msg'] = 'multi'  # noqa: E501
        if 'cluster' in local_var_params and local_var_params['cluster'] is not None:  # noqa: E501
            query_params.append(('cluster', local_var_params['cluster']))  # noqa: E501
            collection_formats['cluster'] = 'multi'  # noqa: E501
        if 'attack_techniques' in local_var_params and local_var_params['attack_techniques'] is not None:  # noqa: E501
            query_params.append(('attackTechniques', local_var_params['attack_techniques']))  # noqa: E501
            collection_formats['attackTechniques'] = 'multi'  # noqa: E501
        if 'aggregate' in local_var_params and local_var_params['aggregate'] is not None:  # noqa: E501
            query_params.append(('aggregate', local_var_params['aggregate']))  # noqa: E501
        if 'protection' in local_var_params and local_var_params['protection'] is not None:  # noqa: E501
            query_params.append(('protection', local_var_params['protection']))  # noqa: E501
            collection_formats['protection'] = 'multi'  # noqa: E501
        if 'buckets' in local_var_params and local_var_params['buckets'] is not None:  # noqa: E501
            query_params.append(('buckets', local_var_params['buckets']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "list[TypesAuditTimeslice]",
        }

        return self.api_client.call_api(
            '/api/v1/audits/firewall/app/serverless/timeslice', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_firewall_network_container_download_get(self, **kwargs):  # noqa: E501
        """api_v1_audits_firewall_network_container_download_get  # noqa: E501

        DownloadContainerNetworkFirewallAudits downloads the container network firewall audits according to the specified query   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_firewall_network_container_download_get(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audits. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audits. 
        :type to: datetime
        :param src_image_name: SrcImages are the source images filter. 
        :type src_image_name: list[str]
        :param dst_image_name: DstImages are the destination images filter. 
        :type dst_image_name: list[str]
        :param block: Block is the block/audit filter. 
        :type block: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_firewall_network_container_download_get_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_firewall_network_container_download_get_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_firewall_network_container_download_get  # noqa: E501

        DownloadContainerNetworkFirewallAudits downloads the container network firewall audits according to the specified query   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_firewall_network_container_download_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audits. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audits. 
        :type to: datetime
        :param src_image_name: SrcImages are the source images filter. 
        :type src_image_name: list[str]
        :param dst_image_name: DstImages are the destination images filter. 
        :type dst_image_name: list[str]
        :param block: Block is the block/audit filter. 
        :type block: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'offset',
            'limit',
            'search',
            'sort',
            'reverse',
            'collections',
            'account_ids',
            'fields',
            '_from',
            'to',
            'src_image_name',
            'dst_image_name',
            'block'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_firewall_network_container_download_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'reverse' in local_var_params and local_var_params['reverse'] is not None:  # noqa: E501
            query_params.append(('reverse', local_var_params['reverse']))  # noqa: E501
        if 'collections' in local_var_params and local_var_params['collections'] is not None:  # noqa: E501
            query_params.append(('collections', local_var_params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'account_ids' in local_var_params and local_var_params['account_ids'] is not None:  # noqa: E501
            query_params.append(('accountIDs', local_var_params['account_ids']))  # noqa: E501
            collection_formats['accountIDs'] = 'multi'  # noqa: E501
        if 'fields' in local_var_params and local_var_params['fields'] is not None:  # noqa: E501
            query_params.append(('fields', local_var_params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if '_from' in local_var_params and local_var_params['_from'] is not None:  # noqa: E501
            query_params.append(('from', local_var_params['_from']))  # noqa: E501
        if 'to' in local_var_params and local_var_params['to'] is not None:  # noqa: E501
            query_params.append(('to', local_var_params['to']))  # noqa: E501
        if 'src_image_name' in local_var_params and local_var_params['src_image_name'] is not None:  # noqa: E501
            query_params.append(('srcImageName', local_var_params['src_image_name']))  # noqa: E501
            collection_formats['srcImageName'] = 'multi'  # noqa: E501
        if 'dst_image_name' in local_var_params and local_var_params['dst_image_name'] is not None:  # noqa: E501
            query_params.append(('dstImageName', local_var_params['dst_image_name']))  # noqa: E501
            collection_formats['dstImageName'] = 'multi'  # noqa: E501
        if 'block' in local_var_params and local_var_params['block'] is not None:  # noqa: E501
            query_params.append(('block', local_var_params['block']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/audits/firewall/network/container/download', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_firewall_network_container_get(self, **kwargs):  # noqa: E501
        """api_v1_audits_firewall_network_container_get  # noqa: E501

        ContainerNetworkFirewallAudits returns all container network firewall audits according to the query specification   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_firewall_network_container_get(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audits. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audits. 
        :type to: datetime
        :param src_image_name: SrcImages are the source images filter. 
        :type src_image_name: list[str]
        :param dst_image_name: DstImages are the destination images filter. 
        :type dst_image_name: list[str]
        :param block: Block is the block/audit filter. 
        :type block: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[SharedContainerNetworkFirewallProfileAudits]
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_firewall_network_container_get_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_firewall_network_container_get_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_firewall_network_container_get  # noqa: E501

        ContainerNetworkFirewallAudits returns all container network firewall audits according to the query specification   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_firewall_network_container_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audits. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audits. 
        :type to: datetime
        :param src_image_name: SrcImages are the source images filter. 
        :type src_image_name: list[str]
        :param dst_image_name: DstImages are the destination images filter. 
        :type dst_image_name: list[str]
        :param block: Block is the block/audit filter. 
        :type block: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[SharedContainerNetworkFirewallProfileAudits], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'offset',
            'limit',
            'search',
            'sort',
            'reverse',
            'collections',
            'account_ids',
            'fields',
            '_from',
            'to',
            'src_image_name',
            'dst_image_name',
            'block'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_firewall_network_container_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'reverse' in local_var_params and local_var_params['reverse'] is not None:  # noqa: E501
            query_params.append(('reverse', local_var_params['reverse']))  # noqa: E501
        if 'collections' in local_var_params and local_var_params['collections'] is not None:  # noqa: E501
            query_params.append(('collections', local_var_params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'account_ids' in local_var_params and local_var_params['account_ids'] is not None:  # noqa: E501
            query_params.append(('accountIDs', local_var_params['account_ids']))  # noqa: E501
            collection_formats['accountIDs'] = 'multi'  # noqa: E501
        if 'fields' in local_var_params and local_var_params['fields'] is not None:  # noqa: E501
            query_params.append(('fields', local_var_params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if '_from' in local_var_params and local_var_params['_from'] is not None:  # noqa: E501
            query_params.append(('from', local_var_params['_from']))  # noqa: E501
        if 'to' in local_var_params and local_var_params['to'] is not None:  # noqa: E501
            query_params.append(('to', local_var_params['to']))  # noqa: E501
        if 'src_image_name' in local_var_params and local_var_params['src_image_name'] is not None:  # noqa: E501
            query_params.append(('srcImageName', local_var_params['src_image_name']))  # noqa: E501
            collection_formats['srcImageName'] = 'multi'  # noqa: E501
        if 'dst_image_name' in local_var_params and local_var_params['dst_image_name'] is not None:  # noqa: E501
            query_params.append(('dstImageName', local_var_params['dst_image_name']))  # noqa: E501
            collection_formats['dstImageName'] = 'multi'  # noqa: E501
        if 'block' in local_var_params and local_var_params['block'] is not None:  # noqa: E501
            query_params.append(('block', local_var_params['block']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "list[SharedContainerNetworkFirewallProfileAudits]",
        }

        return self.api_client.call_api(
            '/api/v1/audits/firewall/network/container', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_firewall_network_host_download_get(self, **kwargs):  # noqa: E501
        """api_v1_audits_firewall_network_host_download_get  # noqa: E501

        DownloadHostNetworkFirewallAudits downloads the host network firewall audits according to the specified query   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_firewall_network_host_download_get(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audits. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audits. 
        :type to: datetime
        :param src_hostnames: SrcHostname are the source hostnames filter. 
        :type src_hostnames: list[str]
        :param dst_hostnames: DstHostname are the destination hostnames filter. 
        :type dst_hostnames: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_firewall_network_host_download_get_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_firewall_network_host_download_get_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_firewall_network_host_download_get  # noqa: E501

        DownloadHostNetworkFirewallAudits downloads the host network firewall audits according to the specified query   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_firewall_network_host_download_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audits. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audits. 
        :type to: datetime
        :param src_hostnames: SrcHostname are the source hostnames filter. 
        :type src_hostnames: list[str]
        :param dst_hostnames: DstHostname are the destination hostnames filter. 
        :type dst_hostnames: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'offset',
            'limit',
            'search',
            'sort',
            'reverse',
            'collections',
            'account_ids',
            'fields',
            '_from',
            'to',
            'src_hostnames',
            'dst_hostnames'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_firewall_network_host_download_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'reverse' in local_var_params and local_var_params['reverse'] is not None:  # noqa: E501
            query_params.append(('reverse', local_var_params['reverse']))  # noqa: E501
        if 'collections' in local_var_params and local_var_params['collections'] is not None:  # noqa: E501
            query_params.append(('collections', local_var_params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'account_ids' in local_var_params and local_var_params['account_ids'] is not None:  # noqa: E501
            query_params.append(('accountIDs', local_var_params['account_ids']))  # noqa: E501
            collection_formats['accountIDs'] = 'multi'  # noqa: E501
        if 'fields' in local_var_params and local_var_params['fields'] is not None:  # noqa: E501
            query_params.append(('fields', local_var_params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if '_from' in local_var_params and local_var_params['_from'] is not None:  # noqa: E501
            query_params.append(('from', local_var_params['_from']))  # noqa: E501
        if 'to' in local_var_params and local_var_params['to'] is not None:  # noqa: E501
            query_params.append(('to', local_var_params['to']))  # noqa: E501
        if 'src_hostnames' in local_var_params and local_var_params['src_hostnames'] is not None:  # noqa: E501
            query_params.append(('srcHostnames', local_var_params['src_hostnames']))  # noqa: E501
            collection_formats['srcHostnames'] = 'multi'  # noqa: E501
        if 'dst_hostnames' in local_var_params and local_var_params['dst_hostnames'] is not None:  # noqa: E501
            query_params.append(('dstHostnames', local_var_params['dst_hostnames']))  # noqa: E501
            collection_formats['dstHostnames'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/audits/firewall/network/host/download', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_firewall_network_host_get(self, **kwargs):  # noqa: E501
        """api_v1_audits_firewall_network_host_get  # noqa: E501

        HostNetworkFirewallAudits returns all host network firewall audits according to the query specification   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_firewall_network_host_get(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audits. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audits. 
        :type to: datetime
        :param src_hostnames: SrcHostname are the source hostnames filter. 
        :type src_hostnames: list[str]
        :param dst_hostnames: DstHostname are the destination hostnames filter. 
        :type dst_hostnames: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[SharedHostNetworkFirewallProfileAudits]
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_firewall_network_host_get_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_firewall_network_host_get_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_firewall_network_host_get  # noqa: E501

        HostNetworkFirewallAudits returns all host network firewall audits according to the query specification   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_firewall_network_host_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audits. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audits. 
        :type to: datetime
        :param src_hostnames: SrcHostname are the source hostnames filter. 
        :type src_hostnames: list[str]
        :param dst_hostnames: DstHostname are the destination hostnames filter. 
        :type dst_hostnames: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[SharedHostNetworkFirewallProfileAudits], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'offset',
            'limit',
            'search',
            'sort',
            'reverse',
            'collections',
            'account_ids',
            'fields',
            '_from',
            'to',
            'src_hostnames',
            'dst_hostnames'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_firewall_network_host_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'reverse' in local_var_params and local_var_params['reverse'] is not None:  # noqa: E501
            query_params.append(('reverse', local_var_params['reverse']))  # noqa: E501
        if 'collections' in local_var_params and local_var_params['collections'] is not None:  # noqa: E501
            query_params.append(('collections', local_var_params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'account_ids' in local_var_params and local_var_params['account_ids'] is not None:  # noqa: E501
            query_params.append(('accountIDs', local_var_params['account_ids']))  # noqa: E501
            collection_formats['accountIDs'] = 'multi'  # noqa: E501
        if 'fields' in local_var_params and local_var_params['fields'] is not None:  # noqa: E501
            query_params.append(('fields', local_var_params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if '_from' in local_var_params and local_var_params['_from'] is not None:  # noqa: E501
            query_params.append(('from', local_var_params['_from']))  # noqa: E501
        if 'to' in local_var_params and local_var_params['to'] is not None:  # noqa: E501
            query_params.append(('to', local_var_params['to']))  # noqa: E501
        if 'src_hostnames' in local_var_params and local_var_params['src_hostnames'] is not None:  # noqa: E501
            query_params.append(('srcHostnames', local_var_params['src_hostnames']))  # noqa: E501
            collection_formats['srcHostnames'] = 'multi'  # noqa: E501
        if 'dst_hostnames' in local_var_params and local_var_params['dst_hostnames'] is not None:  # noqa: E501
            query_params.append(('dstHostnames', local_var_params['dst_hostnames']))  # noqa: E501
            collection_formats['dstHostnames'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "list[SharedHostNetworkFirewallProfileAudits]",
        }

        return self.api_client.call_api(
            '/api/v1/audits/firewall/network/host', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_incidents_acknowledge_id_patch(self, id, **kwargs):  # noqa: E501
        """api_v1_audits_incidents_acknowledge_id_patch  # noqa: E501

        SetIncidentAcknowledge sets the given incident's acknowledgement status   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_incidents_acknowledge_id_patch(id, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param shared_incident:
        :type shared_incident: SharedIncident
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_incidents_acknowledge_id_patch_with_http_info(id, **kwargs)  # noqa: E501

    def api_v1_audits_incidents_acknowledge_id_patch_with_http_info(self, id, **kwargs):  # noqa: E501
        """api_v1_audits_incidents_acknowledge_id_patch  # noqa: E501

        SetIncidentAcknowledge sets the given incident's acknowledgement status   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_incidents_acknowledge_id_patch_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param shared_incident:
        :type shared_incident: SharedIncident
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'id',
            'shared_incident'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_incidents_acknowledge_id_patch" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `api_v1_audits_incidents_acknowledge_id_patch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'shared_incident' in local_var_params:
            body_params = local_var_params['shared_incident']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/audits/incidents/acknowledge/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_incidents_download_get(self, **kwargs):  # noqa: E501
        """api_v1_audits_incidents_download_get  # noqa: E501

        DownloadIncidents downloads incidents according to the specified query   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_incidents_download_get(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: Filters results from a start datetime. 
        :type _from: datetime
        :param to: Filters results from an end datetime. 
        :type to: datetime
        :param hostname: Filters results by hostname where the incident occurred. 
        :type hostname: list[str]
        :param category: Filters results by incident category. 
        :type category: list[str]
        :param type: Filters results by incident type. 
        :type type: list[str]
        :param profile_id: Filters results by runtime profile ID. 
        :type profile_id: list[str]
        :param acknowledged: Filters results by incidents that have been acknowledged. 
        :type acknowledged: str
        :param region: Filters results by region (for functions). 
        :type region: list[str]
        :param cluster: Filters results by cluster name. 
        :type cluster: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_incidents_download_get_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_incidents_download_get_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_incidents_download_get  # noqa: E501

        DownloadIncidents downloads incidents according to the specified query   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_incidents_download_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: Filters results from a start datetime. 
        :type _from: datetime
        :param to: Filters results from an end datetime. 
        :type to: datetime
        :param hostname: Filters results by hostname where the incident occurred. 
        :type hostname: list[str]
        :param category: Filters results by incident category. 
        :type category: list[str]
        :param type: Filters results by incident type. 
        :type type: list[str]
        :param profile_id: Filters results by runtime profile ID. 
        :type profile_id: list[str]
        :param acknowledged: Filters results by incidents that have been acknowledged. 
        :type acknowledged: str
        :param region: Filters results by region (for functions). 
        :type region: list[str]
        :param cluster: Filters results by cluster name. 
        :type cluster: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'offset',
            'limit',
            'search',
            'sort',
            'reverse',
            'collections',
            'account_ids',
            'fields',
            '_from',
            'to',
            'hostname',
            'category',
            'type',
            'profile_id',
            'acknowledged',
            'region',
            'cluster'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_incidents_download_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'reverse' in local_var_params and local_var_params['reverse'] is not None:  # noqa: E501
            query_params.append(('reverse', local_var_params['reverse']))  # noqa: E501
        if 'collections' in local_var_params and local_var_params['collections'] is not None:  # noqa: E501
            query_params.append(('collections', local_var_params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'account_ids' in local_var_params and local_var_params['account_ids'] is not None:  # noqa: E501
            query_params.append(('accountIDs', local_var_params['account_ids']))  # noqa: E501
            collection_formats['accountIDs'] = 'multi'  # noqa: E501
        if 'fields' in local_var_params and local_var_params['fields'] is not None:  # noqa: E501
            query_params.append(('fields', local_var_params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if '_from' in local_var_params and local_var_params['_from'] is not None:  # noqa: E501
            query_params.append(('from', local_var_params['_from']))  # noqa: E501
        if 'to' in local_var_params and local_var_params['to'] is not None:  # noqa: E501
            query_params.append(('to', local_var_params['to']))  # noqa: E501
        if 'hostname' in local_var_params and local_var_params['hostname'] is not None:  # noqa: E501
            query_params.append(('hostname', local_var_params['hostname']))  # noqa: E501
            collection_formats['hostname'] = 'multi'  # noqa: E501
        if 'category' in local_var_params and local_var_params['category'] is not None:  # noqa: E501
            query_params.append(('category', local_var_params['category']))  # noqa: E501
            collection_formats['category'] = 'multi'  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
            collection_formats['type'] = 'multi'  # noqa: E501
        if 'profile_id' in local_var_params and local_var_params['profile_id'] is not None:  # noqa: E501
            query_params.append(('profileID', local_var_params['profile_id']))  # noqa: E501
            collection_formats['profileID'] = 'multi'  # noqa: E501
        if 'acknowledged' in local_var_params and local_var_params['acknowledged'] is not None:  # noqa: E501
            query_params.append(('acknowledged', local_var_params['acknowledged']))  # noqa: E501
        if 'region' in local_var_params and local_var_params['region'] is not None:  # noqa: E501
            query_params.append(('region', local_var_params['region']))  # noqa: E501
            collection_formats['region'] = 'multi'  # noqa: E501
        if 'cluster' in local_var_params and local_var_params['cluster'] is not None:  # noqa: E501
            query_params.append(('cluster', local_var_params['cluster']))  # noqa: E501
            collection_formats['cluster'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/audits/incidents/download', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_incidents_get(self, **kwargs):  # noqa: E501
        """api_v1_audits_incidents_get  # noqa: E501

        Incidents returns all incidents according to the query specification   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_incidents_get(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: Filters results from a start datetime. 
        :type _from: datetime
        :param to: Filters results from an end datetime. 
        :type to: datetime
        :param hostname: Filters results by hostname where the incident occurred. 
        :type hostname: list[str]
        :param category: Filters results by incident category. 
        :type category: list[str]
        :param type: Filters results by incident type. 
        :type type: list[str]
        :param profile_id: Filters results by runtime profile ID. 
        :type profile_id: list[str]
        :param acknowledged: Filters results by incidents that have been acknowledged. 
        :type acknowledged: str
        :param region: Filters results by region (for functions). 
        :type region: list[str]
        :param cluster: Filters results by cluster name. 
        :type cluster: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[SharedIncident]
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_incidents_get_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_incidents_get_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_incidents_get  # noqa: E501

        Incidents returns all incidents according to the query specification   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_incidents_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: Filters results from a start datetime. 
        :type _from: datetime
        :param to: Filters results from an end datetime. 
        :type to: datetime
        :param hostname: Filters results by hostname where the incident occurred. 
        :type hostname: list[str]
        :param category: Filters results by incident category. 
        :type category: list[str]
        :param type: Filters results by incident type. 
        :type type: list[str]
        :param profile_id: Filters results by runtime profile ID. 
        :type profile_id: list[str]
        :param acknowledged: Filters results by incidents that have been acknowledged. 
        :type acknowledged: str
        :param region: Filters results by region (for functions). 
        :type region: list[str]
        :param cluster: Filters results by cluster name. 
        :type cluster: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[SharedIncident], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'offset',
            'limit',
            'search',
            'sort',
            'reverse',
            'collections',
            'account_ids',
            'fields',
            '_from',
            'to',
            'hostname',
            'category',
            'type',
            'profile_id',
            'acknowledged',
            'region',
            'cluster'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_incidents_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'reverse' in local_var_params and local_var_params['reverse'] is not None:  # noqa: E501
            query_params.append(('reverse', local_var_params['reverse']))  # noqa: E501
        if 'collections' in local_var_params and local_var_params['collections'] is not None:  # noqa: E501
            query_params.append(('collections', local_var_params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'account_ids' in local_var_params and local_var_params['account_ids'] is not None:  # noqa: E501
            query_params.append(('accountIDs', local_var_params['account_ids']))  # noqa: E501
            collection_formats['accountIDs'] = 'multi'  # noqa: E501
        if 'fields' in local_var_params and local_var_params['fields'] is not None:  # noqa: E501
            query_params.append(('fields', local_var_params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if '_from' in local_var_params and local_var_params['_from'] is not None:  # noqa: E501
            query_params.append(('from', local_var_params['_from']))  # noqa: E501
        if 'to' in local_var_params and local_var_params['to'] is not None:  # noqa: E501
            query_params.append(('to', local_var_params['to']))  # noqa: E501
        if 'hostname' in local_var_params and local_var_params['hostname'] is not None:  # noqa: E501
            query_params.append(('hostname', local_var_params['hostname']))  # noqa: E501
            collection_formats['hostname'] = 'multi'  # noqa: E501
        if 'category' in local_var_params and local_var_params['category'] is not None:  # noqa: E501
            query_params.append(('category', local_var_params['category']))  # noqa: E501
            collection_formats['category'] = 'multi'  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
            collection_formats['type'] = 'multi'  # noqa: E501
        if 'profile_id' in local_var_params and local_var_params['profile_id'] is not None:  # noqa: E501
            query_params.append(('profileID', local_var_params['profile_id']))  # noqa: E501
            collection_formats['profileID'] = 'multi'  # noqa: E501
        if 'acknowledged' in local_var_params and local_var_params['acknowledged'] is not None:  # noqa: E501
            query_params.append(('acknowledged', local_var_params['acknowledged']))  # noqa: E501
        if 'region' in local_var_params and local_var_params['region'] is not None:  # noqa: E501
            query_params.append(('region', local_var_params['region']))  # noqa: E501
            collection_formats['region'] = 'multi'  # noqa: E501
        if 'cluster' in local_var_params and local_var_params['cluster'] is not None:  # noqa: E501
            query_params.append(('cluster', local_var_params['cluster']))  # noqa: E501
            collection_formats['cluster'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "list[SharedIncident]",
        }

        return self.api_client.call_api(
            '/api/v1/audits/incidents', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_kubernetes_download_get(self, **kwargs):  # noqa: E501
        """api_v1_audits_kubernetes_download_get  # noqa: E501

        DownloadKubernetesAudits downloads the Kubernetes audits according to the specified query   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_kubernetes_download_get(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the activity. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the activity. 
        :type to: datetime
        :param user: Users is the list of users to use for filtering. 
        :type user: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_kubernetes_download_get_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_kubernetes_download_get_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_kubernetes_download_get  # noqa: E501

        DownloadKubernetesAudits downloads the Kubernetes audits according to the specified query   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_kubernetes_download_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the activity. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the activity. 
        :type to: datetime
        :param user: Users is the list of users to use for filtering. 
        :type user: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'offset',
            'limit',
            'search',
            'sort',
            'reverse',
            'collections',
            'account_ids',
            'fields',
            '_from',
            'to',
            'user',
            'attack_techniques'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_kubernetes_download_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'reverse' in local_var_params and local_var_params['reverse'] is not None:  # noqa: E501
            query_params.append(('reverse', local_var_params['reverse']))  # noqa: E501
        if 'collections' in local_var_params and local_var_params['collections'] is not None:  # noqa: E501
            query_params.append(('collections', local_var_params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'account_ids' in local_var_params and local_var_params['account_ids'] is not None:  # noqa: E501
            query_params.append(('accountIDs', local_var_params['account_ids']))  # noqa: E501
            collection_formats['accountIDs'] = 'multi'  # noqa: E501
        if 'fields' in local_var_params and local_var_params['fields'] is not None:  # noqa: E501
            query_params.append(('fields', local_var_params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if '_from' in local_var_params and local_var_params['_from'] is not None:  # noqa: E501
            query_params.append(('from', local_var_params['_from']))  # noqa: E501
        if 'to' in local_var_params and local_var_params['to'] is not None:  # noqa: E501
            query_params.append(('to', local_var_params['to']))  # noqa: E501
        if 'user' in local_var_params and local_var_params['user'] is not None:  # noqa: E501
            query_params.append(('user', local_var_params['user']))  # noqa: E501
            collection_formats['user'] = 'multi'  # noqa: E501
        if 'attack_techniques' in local_var_params and local_var_params['attack_techniques'] is not None:  # noqa: E501
            query_params.append(('attackTechniques', local_var_params['attack_techniques']))  # noqa: E501
            collection_formats['attackTechniques'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/audits/kubernetes/download', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_kubernetes_get(self, **kwargs):  # noqa: E501
        """api_v1_audits_kubernetes_get  # noqa: E501

        KubernetesAudits returns a list of Kubernetes audits   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_kubernetes_get(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the activity. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the activity. 
        :type to: datetime
        :param user: Users is the list of users to use for filtering. 
        :type user: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[SharedKubernetesAudit]
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_kubernetes_get_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_kubernetes_get_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_kubernetes_get  # noqa: E501

        KubernetesAudits returns a list of Kubernetes audits   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_kubernetes_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the activity. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the activity. 
        :type to: datetime
        :param user: Users is the list of users to use for filtering. 
        :type user: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[SharedKubernetesAudit], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'offset',
            'limit',
            'search',
            'sort',
            'reverse',
            'collections',
            'account_ids',
            'fields',
            '_from',
            'to',
            'user',
            'attack_techniques'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_kubernetes_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'reverse' in local_var_params and local_var_params['reverse'] is not None:  # noqa: E501
            query_params.append(('reverse', local_var_params['reverse']))  # noqa: E501
        if 'collections' in local_var_params and local_var_params['collections'] is not None:  # noqa: E501
            query_params.append(('collections', local_var_params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'account_ids' in local_var_params and local_var_params['account_ids'] is not None:  # noqa: E501
            query_params.append(('accountIDs', local_var_params['account_ids']))  # noqa: E501
            collection_formats['accountIDs'] = 'multi'  # noqa: E501
        if 'fields' in local_var_params and local_var_params['fields'] is not None:  # noqa: E501
            query_params.append(('fields', local_var_params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if '_from' in local_var_params and local_var_params['_from'] is not None:  # noqa: E501
            query_params.append(('from', local_var_params['_from']))  # noqa: E501
        if 'to' in local_var_params and local_var_params['to'] is not None:  # noqa: E501
            query_params.append(('to', local_var_params['to']))  # noqa: E501
        if 'user' in local_var_params and local_var_params['user'] is not None:  # noqa: E501
            query_params.append(('user', local_var_params['user']))  # noqa: E501
            collection_formats['user'] = 'multi'  # noqa: E501
        if 'attack_techniques' in local_var_params and local_var_params['attack_techniques'] is not None:  # noqa: E501
            query_params.append(('attackTechniques', local_var_params['attack_techniques']))  # noqa: E501
            collection_formats['attackTechniques'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "list[SharedKubernetesAudit]",
        }

        return self.api_client.call_api(
            '/api/v1/audits/kubernetes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_mgmt_download_get(self, **kwargs):  # noqa: E501
        """api_v1_audits_mgmt_download_get  # noqa: E501

        DownloadMgmtAudits downloads the management audits according to the specified query   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_mgmt_download_get(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param type: Types is the audit type filter. 
        :type type: list[str]
        :param username: Usernames is the username filter. 
        :type username: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_mgmt_download_get_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_mgmt_download_get_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_mgmt_download_get  # noqa: E501

        DownloadMgmtAudits downloads the management audits according to the specified query   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_mgmt_download_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param type: Types is the audit type filter. 
        :type type: list[str]
        :param username: Usernames is the username filter. 
        :type username: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'offset',
            'limit',
            'search',
            'sort',
            'reverse',
            'collections',
            'account_ids',
            'fields',
            '_from',
            'to',
            'type',
            'username'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_mgmt_download_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'reverse' in local_var_params and local_var_params['reverse'] is not None:  # noqa: E501
            query_params.append(('reverse', local_var_params['reverse']))  # noqa: E501
        if 'collections' in local_var_params and local_var_params['collections'] is not None:  # noqa: E501
            query_params.append(('collections', local_var_params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'account_ids' in local_var_params and local_var_params['account_ids'] is not None:  # noqa: E501
            query_params.append(('accountIDs', local_var_params['account_ids']))  # noqa: E501
            collection_formats['accountIDs'] = 'multi'  # noqa: E501
        if 'fields' in local_var_params and local_var_params['fields'] is not None:  # noqa: E501
            query_params.append(('fields', local_var_params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if '_from' in local_var_params and local_var_params['_from'] is not None:  # noqa: E501
            query_params.append(('from', local_var_params['_from']))  # noqa: E501
        if 'to' in local_var_params and local_var_params['to'] is not None:  # noqa: E501
            query_params.append(('to', local_var_params['to']))  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
            collection_formats['type'] = 'multi'  # noqa: E501
        if 'username' in local_var_params and local_var_params['username'] is not None:  # noqa: E501
            query_params.append(('username', local_var_params['username']))  # noqa: E501
            collection_formats['username'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/audits/mgmt/download', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_mgmt_filters_get(self, **kwargs):  # noqa: E501
        """api_v1_audits_mgmt_filters_get  # noqa: E501

        MgmtAuditFilters returns container management audits filters according to the query specification   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_mgmt_filters_get(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param type: Types is the audit type filter. 
        :type type: list[str]
        :param username: Usernames is the username filter. 
        :type username: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TypesMgmtAuditFilters
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_mgmt_filters_get_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_mgmt_filters_get_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_mgmt_filters_get  # noqa: E501

        MgmtAuditFilters returns container management audits filters according to the query specification   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_mgmt_filters_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param type: Types is the audit type filter. 
        :type type: list[str]
        :param username: Usernames is the username filter. 
        :type username: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TypesMgmtAuditFilters, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'offset',
            'limit',
            'search',
            'sort',
            'reverse',
            'collections',
            'account_ids',
            'fields',
            '_from',
            'to',
            'type',
            'username'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_mgmt_filters_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'reverse' in local_var_params and local_var_params['reverse'] is not None:  # noqa: E501
            query_params.append(('reverse', local_var_params['reverse']))  # noqa: E501
        if 'collections' in local_var_params and local_var_params['collections'] is not None:  # noqa: E501
            query_params.append(('collections', local_var_params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'account_ids' in local_var_params and local_var_params['account_ids'] is not None:  # noqa: E501
            query_params.append(('accountIDs', local_var_params['account_ids']))  # noqa: E501
            collection_formats['accountIDs'] = 'multi'  # noqa: E501
        if 'fields' in local_var_params and local_var_params['fields'] is not None:  # noqa: E501
            query_params.append(('fields', local_var_params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if '_from' in local_var_params and local_var_params['_from'] is not None:  # noqa: E501
            query_params.append(('from', local_var_params['_from']))  # noqa: E501
        if 'to' in local_var_params and local_var_params['to'] is not None:  # noqa: E501
            query_params.append(('to', local_var_params['to']))  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
            collection_formats['type'] = 'multi'  # noqa: E501
        if 'username' in local_var_params and local_var_params['username'] is not None:  # noqa: E501
            query_params.append(('username', local_var_params['username']))  # noqa: E501
            collection_formats['username'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "TypesMgmtAuditFilters",
        }

        return self.api_client.call_api(
            '/api/v1/audits/mgmt/filters', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_mgmt_get(self, **kwargs):  # noqa: E501
        """api_v1_audits_mgmt_get  # noqa: E501

        MgmtAudits returns all management audits according to the query specification   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_mgmt_get(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param type: Types is the audit type filter. 
        :type type: list[str]
        :param username: Usernames is the username filter. 
        :type username: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[SharedMgmtAudit]
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_mgmt_get_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_mgmt_get_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_mgmt_get  # noqa: E501

        MgmtAudits returns all management audits according to the query specification   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_mgmt_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param type: Types is the audit type filter. 
        :type type: list[str]
        :param username: Usernames is the username filter. 
        :type username: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[SharedMgmtAudit], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'offset',
            'limit',
            'search',
            'sort',
            'reverse',
            'collections',
            'account_ids',
            'fields',
            '_from',
            'to',
            'type',
            'username'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_mgmt_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'reverse' in local_var_params and local_var_params['reverse'] is not None:  # noqa: E501
            query_params.append(('reverse', local_var_params['reverse']))  # noqa: E501
        if 'collections' in local_var_params and local_var_params['collections'] is not None:  # noqa: E501
            query_params.append(('collections', local_var_params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'account_ids' in local_var_params and local_var_params['account_ids'] is not None:  # noqa: E501
            query_params.append(('accountIDs', local_var_params['account_ids']))  # noqa: E501
            collection_formats['accountIDs'] = 'multi'  # noqa: E501
        if 'fields' in local_var_params and local_var_params['fields'] is not None:  # noqa: E501
            query_params.append(('fields', local_var_params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if '_from' in local_var_params and local_var_params['_from'] is not None:  # noqa: E501
            query_params.append(('from', local_var_params['_from']))  # noqa: E501
        if 'to' in local_var_params and local_var_params['to'] is not None:  # noqa: E501
            query_params.append(('to', local_var_params['to']))  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
            collection_formats['type'] = 'multi'  # noqa: E501
        if 'username' in local_var_params and local_var_params['username'] is not None:  # noqa: E501
            query_params.append(('username', local_var_params['username']))  # noqa: E501
            collection_formats['username'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "list[SharedMgmtAudit]",
        }

        return self.api_client.call_api(
            '/api/v1/audits/mgmt', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_runtime_app_embedded_delete(self, **kwargs):  # noqa: E501
        """api_v1_audits_runtime_app_embedded_delete  # noqa: E501

        DeleteAppEmbeddedRuntimeAudits deletes all embedded defender runtime audits   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_runtime_app_embedded_delete(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_runtime_app_embedded_delete_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_runtime_app_embedded_delete_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_runtime_app_embedded_delete  # noqa: E501

        DeleteAppEmbeddedRuntimeAudits deletes all embedded defender runtime audits   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_runtime_app_embedded_delete_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_runtime_app_embedded_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/audits/runtime/app-embedded', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_runtime_app_embedded_download_get(self, **kwargs):  # noqa: E501
        """api_v1_audits_runtime_app_embedded_download_get  # noqa: E501

        DownloadAppEmbeddedRuntimeAudits downloads the embedded defender audits according to the specified query   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_runtime_app_embedded_download_get(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param profile_id: ProfileIDs are the profile IDs to filter. 
        :type profile_id: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param time: Time is used to filter by audit time. 
        :type time: datetime
        :param image_name: ImageNames is the image name filter. 
        :type image_name: list[str]
        :param container: Containers is the container name filter. 
        :type container: list[str]
        :param container_id: ContainerID is used to filter by container ID. 
        :type container_id: list[str]
        :param rule_name: RuleNames is used to filter by rule name. 
        :type rule_name: list[str]
        :param type: Types is used to filter by runtime audit type. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect (e.g., block/alert). 
        :type effect: list[str]
        :param user: Users is used to filter by host users. 
        :type user: list[str]
        :param os: OS is the image OS distro filter. 
        :type os: list[str]
        :param namespace: Namespaces is the namespaces filter. 
        :type namespace: list[str]
        :param cluster: Clusters is the cluster filter. 
        :type cluster: list[str]
        :param attack_type: AttackTypes is used to filter by runtime audit attack type. 
        :type attack_type: list[str]
        :param hostname: Hostname is the hostname filter. 
        :type hostname: list[str]
        :param msg: Message is the audit message text filter. 
        :type msg: list[str]
        :param interactive: Interactive is the audit interactive filter. 
        :type interactive: list[str]
        :param function: Function is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param app: App is the name constraint of the service that triggered the audit. 
        :type app: list[str]
        :param process_path: ProcessPath is the path constraint of the process that triggered the audit. 
        :type process_path: list[str]
        :param request_id: RequestID is used to filter by request ID. 
        :type request_id: list[str]
        :param function_id: FunctionID is used to filter by function ID. 
        :type function_id: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_runtime_app_embedded_download_get_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_runtime_app_embedded_download_get_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_runtime_app_embedded_download_get  # noqa: E501

        DownloadAppEmbeddedRuntimeAudits downloads the embedded defender audits according to the specified query   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_runtime_app_embedded_download_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param profile_id: ProfileIDs are the profile IDs to filter. 
        :type profile_id: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param time: Time is used to filter by audit time. 
        :type time: datetime
        :param image_name: ImageNames is the image name filter. 
        :type image_name: list[str]
        :param container: Containers is the container name filter. 
        :type container: list[str]
        :param container_id: ContainerID is used to filter by container ID. 
        :type container_id: list[str]
        :param rule_name: RuleNames is used to filter by rule name. 
        :type rule_name: list[str]
        :param type: Types is used to filter by runtime audit type. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect (e.g., block/alert). 
        :type effect: list[str]
        :param user: Users is used to filter by host users. 
        :type user: list[str]
        :param os: OS is the image OS distro filter. 
        :type os: list[str]
        :param namespace: Namespaces is the namespaces filter. 
        :type namespace: list[str]
        :param cluster: Clusters is the cluster filter. 
        :type cluster: list[str]
        :param attack_type: AttackTypes is used to filter by runtime audit attack type. 
        :type attack_type: list[str]
        :param hostname: Hostname is the hostname filter. 
        :type hostname: list[str]
        :param msg: Message is the audit message text filter. 
        :type msg: list[str]
        :param interactive: Interactive is the audit interactive filter. 
        :type interactive: list[str]
        :param function: Function is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param app: App is the name constraint of the service that triggered the audit. 
        :type app: list[str]
        :param process_path: ProcessPath is the path constraint of the process that triggered the audit. 
        :type process_path: list[str]
        :param request_id: RequestID is used to filter by request ID. 
        :type request_id: list[str]
        :param function_id: FunctionID is used to filter by function ID. 
        :type function_id: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'offset',
            'limit',
            'search',
            'sort',
            'reverse',
            'collections',
            'account_ids',
            'fields',
            'profile_id',
            '_from',
            'to',
            'time',
            'image_name',
            'container',
            'container_id',
            'rule_name',
            'type',
            'effect',
            'user',
            'os',
            'namespace',
            'cluster',
            'attack_type',
            'hostname',
            'msg',
            'interactive',
            'function',
            'region',
            'runtime',
            'attack_techniques',
            'app',
            'process_path',
            'request_id',
            'function_id',
            'aggregate'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_runtime_app_embedded_download_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'reverse' in local_var_params and local_var_params['reverse'] is not None:  # noqa: E501
            query_params.append(('reverse', local_var_params['reverse']))  # noqa: E501
        if 'collections' in local_var_params and local_var_params['collections'] is not None:  # noqa: E501
            query_params.append(('collections', local_var_params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'account_ids' in local_var_params and local_var_params['account_ids'] is not None:  # noqa: E501
            query_params.append(('accountIDs', local_var_params['account_ids']))  # noqa: E501
            collection_formats['accountIDs'] = 'multi'  # noqa: E501
        if 'fields' in local_var_params and local_var_params['fields'] is not None:  # noqa: E501
            query_params.append(('fields', local_var_params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if 'profile_id' in local_var_params and local_var_params['profile_id'] is not None:  # noqa: E501
            query_params.append(('profileID', local_var_params['profile_id']))  # noqa: E501
            collection_formats['profileID'] = 'multi'  # noqa: E501
        if '_from' in local_var_params and local_var_params['_from'] is not None:  # noqa: E501
            query_params.append(('from', local_var_params['_from']))  # noqa: E501
        if 'to' in local_var_params and local_var_params['to'] is not None:  # noqa: E501
            query_params.append(('to', local_var_params['to']))  # noqa: E501
        if 'time' in local_var_params and local_var_params['time'] is not None:  # noqa: E501
            query_params.append(('time', local_var_params['time']))  # noqa: E501
        if 'image_name' in local_var_params and local_var_params['image_name'] is not None:  # noqa: E501
            query_params.append(('imageName', local_var_params['image_name']))  # noqa: E501
            collection_formats['imageName'] = 'multi'  # noqa: E501
        if 'container' in local_var_params and local_var_params['container'] is not None:  # noqa: E501
            query_params.append(('container', local_var_params['container']))  # noqa: E501
            collection_formats['container'] = 'multi'  # noqa: E501
        if 'container_id' in local_var_params and local_var_params['container_id'] is not None:  # noqa: E501
            query_params.append(('containerID', local_var_params['container_id']))  # noqa: E501
            collection_formats['containerID'] = 'multi'  # noqa: E501
        if 'rule_name' in local_var_params and local_var_params['rule_name'] is not None:  # noqa: E501
            query_params.append(('ruleName', local_var_params['rule_name']))  # noqa: E501
            collection_formats['ruleName'] = 'multi'  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
            collection_formats['type'] = 'multi'  # noqa: E501
        if 'effect' in local_var_params and local_var_params['effect'] is not None:  # noqa: E501
            query_params.append(('effect', local_var_params['effect']))  # noqa: E501
            collection_formats['effect'] = 'multi'  # noqa: E501
        if 'user' in local_var_params and local_var_params['user'] is not None:  # noqa: E501
            query_params.append(('user', local_var_params['user']))  # noqa: E501
            collection_formats['user'] = 'multi'  # noqa: E501
        if 'os' in local_var_params and local_var_params['os'] is not None:  # noqa: E501
            query_params.append(('os', local_var_params['os']))  # noqa: E501
            collection_formats['os'] = 'multi'  # noqa: E501
        if 'namespace' in local_var_params and local_var_params['namespace'] is not None:  # noqa: E501
            query_params.append(('namespace', local_var_params['namespace']))  # noqa: E501
            collection_formats['namespace'] = 'multi'  # noqa: E501
        if 'cluster' in local_var_params and local_var_params['cluster'] is not None:  # noqa: E501
            query_params.append(('cluster', local_var_params['cluster']))  # noqa: E501
            collection_formats['cluster'] = 'multi'  # noqa: E501
        if 'attack_type' in local_var_params and local_var_params['attack_type'] is not None:  # noqa: E501
            query_params.append(('attackType', local_var_params['attack_type']))  # noqa: E501
            collection_formats['attackType'] = 'multi'  # noqa: E501
        if 'hostname' in local_var_params and local_var_params['hostname'] is not None:  # noqa: E501
            query_params.append(('hostname', local_var_params['hostname']))  # noqa: E501
            collection_formats['hostname'] = 'multi'  # noqa: E501
        if 'msg' in local_var_params and local_var_params['msg'] is not None:  # noqa: E501
            query_params.append(('msg', local_var_params['msg']))  # noqa: E501
            collection_formats['msg'] = 'multi'  # noqa: E501
        if 'interactive' in local_var_params and local_var_params['interactive'] is not None:  # noqa: E501
            query_params.append(('interactive', local_var_params['interactive']))  # noqa: E501
            collection_formats['interactive'] = 'multi'  # noqa: E501
        if 'function' in local_var_params and local_var_params['function'] is not None:  # noqa: E501
            query_params.append(('function', local_var_params['function']))  # noqa: E501
            collection_formats['function'] = 'multi'  # noqa: E501
        if 'region' in local_var_params and local_var_params['region'] is not None:  # noqa: E501
            query_params.append(('region', local_var_params['region']))  # noqa: E501
            collection_formats['region'] = 'multi'  # noqa: E501
        if 'runtime' in local_var_params and local_var_params['runtime'] is not None:  # noqa: E501
            query_params.append(('runtime', local_var_params['runtime']))  # noqa: E501
            collection_formats['runtime'] = 'multi'  # noqa: E501
        if 'attack_techniques' in local_var_params and local_var_params['attack_techniques'] is not None:  # noqa: E501
            query_params.append(('attackTechniques', local_var_params['attack_techniques']))  # noqa: E501
            collection_formats['attackTechniques'] = 'multi'  # noqa: E501
        if 'app' in local_var_params and local_var_params['app'] is not None:  # noqa: E501
            query_params.append(('app', local_var_params['app']))  # noqa: E501
            collection_formats['app'] = 'multi'  # noqa: E501
        if 'process_path' in local_var_params and local_var_params['process_path'] is not None:  # noqa: E501
            query_params.append(('processPath', local_var_params['process_path']))  # noqa: E501
            collection_formats['processPath'] = 'multi'  # noqa: E501
        if 'request_id' in local_var_params and local_var_params['request_id'] is not None:  # noqa: E501
            query_params.append(('requestID', local_var_params['request_id']))  # noqa: E501
            collection_formats['requestID'] = 'multi'  # noqa: E501
        if 'function_id' in local_var_params and local_var_params['function_id'] is not None:  # noqa: E501
            query_params.append(('functionID', local_var_params['function_id']))  # noqa: E501
            collection_formats['functionID'] = 'multi'  # noqa: E501
        if 'aggregate' in local_var_params and local_var_params['aggregate'] is not None:  # noqa: E501
            query_params.append(('aggregate', local_var_params['aggregate']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/audits/runtime/app-embedded/download', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_runtime_app_embedded_get(self, **kwargs):  # noqa: E501
        """api_v1_audits_runtime_app_embedded_get  # noqa: E501

        AppEmbeddedRuntimeAudits returns all embedded defender audits according to the query specification   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_runtime_app_embedded_get(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param profile_id: ProfileIDs are the profile IDs to filter. 
        :type profile_id: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param time: Time is used to filter by audit time. 
        :type time: datetime
        :param image_name: ImageNames is the image name filter. 
        :type image_name: list[str]
        :param container: Containers is the container name filter. 
        :type container: list[str]
        :param container_id: ContainerID is used to filter by container ID. 
        :type container_id: list[str]
        :param rule_name: RuleNames is used to filter by rule name. 
        :type rule_name: list[str]
        :param type: Types is used to filter by runtime audit type. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect (e.g., block/alert). 
        :type effect: list[str]
        :param user: Users is used to filter by host users. 
        :type user: list[str]
        :param os: OS is the image OS distro filter. 
        :type os: list[str]
        :param namespace: Namespaces is the namespaces filter. 
        :type namespace: list[str]
        :param cluster: Clusters is the cluster filter. 
        :type cluster: list[str]
        :param attack_type: AttackTypes is used to filter by runtime audit attack type. 
        :type attack_type: list[str]
        :param hostname: Hostname is the hostname filter. 
        :type hostname: list[str]
        :param msg: Message is the audit message text filter. 
        :type msg: list[str]
        :param interactive: Interactive is the audit interactive filter. 
        :type interactive: list[str]
        :param function: Function is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param app: App is the name constraint of the service that triggered the audit. 
        :type app: list[str]
        :param process_path: ProcessPath is the path constraint of the process that triggered the audit. 
        :type process_path: list[str]
        :param request_id: RequestID is used to filter by request ID. 
        :type request_id: list[str]
        :param function_id: FunctionID is used to filter by function ID. 
        :type function_id: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[SharedRuntimeAudit]
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_runtime_app_embedded_get_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_runtime_app_embedded_get_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_runtime_app_embedded_get  # noqa: E501

        AppEmbeddedRuntimeAudits returns all embedded defender audits according to the query specification   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_runtime_app_embedded_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param profile_id: ProfileIDs are the profile IDs to filter. 
        :type profile_id: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param time: Time is used to filter by audit time. 
        :type time: datetime
        :param image_name: ImageNames is the image name filter. 
        :type image_name: list[str]
        :param container: Containers is the container name filter. 
        :type container: list[str]
        :param container_id: ContainerID is used to filter by container ID. 
        :type container_id: list[str]
        :param rule_name: RuleNames is used to filter by rule name. 
        :type rule_name: list[str]
        :param type: Types is used to filter by runtime audit type. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect (e.g., block/alert). 
        :type effect: list[str]
        :param user: Users is used to filter by host users. 
        :type user: list[str]
        :param os: OS is the image OS distro filter. 
        :type os: list[str]
        :param namespace: Namespaces is the namespaces filter. 
        :type namespace: list[str]
        :param cluster: Clusters is the cluster filter. 
        :type cluster: list[str]
        :param attack_type: AttackTypes is used to filter by runtime audit attack type. 
        :type attack_type: list[str]
        :param hostname: Hostname is the hostname filter. 
        :type hostname: list[str]
        :param msg: Message is the audit message text filter. 
        :type msg: list[str]
        :param interactive: Interactive is the audit interactive filter. 
        :type interactive: list[str]
        :param function: Function is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param app: App is the name constraint of the service that triggered the audit. 
        :type app: list[str]
        :param process_path: ProcessPath is the path constraint of the process that triggered the audit. 
        :type process_path: list[str]
        :param request_id: RequestID is used to filter by request ID. 
        :type request_id: list[str]
        :param function_id: FunctionID is used to filter by function ID. 
        :type function_id: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[SharedRuntimeAudit], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'offset',
            'limit',
            'search',
            'sort',
            'reverse',
            'collections',
            'account_ids',
            'fields',
            'profile_id',
            '_from',
            'to',
            'time',
            'image_name',
            'container',
            'container_id',
            'rule_name',
            'type',
            'effect',
            'user',
            'os',
            'namespace',
            'cluster',
            'attack_type',
            'hostname',
            'msg',
            'interactive',
            'function',
            'region',
            'runtime',
            'attack_techniques',
            'app',
            'process_path',
            'request_id',
            'function_id',
            'aggregate'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_runtime_app_embedded_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'reverse' in local_var_params and local_var_params['reverse'] is not None:  # noqa: E501
            query_params.append(('reverse', local_var_params['reverse']))  # noqa: E501
        if 'collections' in local_var_params and local_var_params['collections'] is not None:  # noqa: E501
            query_params.append(('collections', local_var_params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'account_ids' in local_var_params and local_var_params['account_ids'] is not None:  # noqa: E501
            query_params.append(('accountIDs', local_var_params['account_ids']))  # noqa: E501
            collection_formats['accountIDs'] = 'multi'  # noqa: E501
        if 'fields' in local_var_params and local_var_params['fields'] is not None:  # noqa: E501
            query_params.append(('fields', local_var_params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if 'profile_id' in local_var_params and local_var_params['profile_id'] is not None:  # noqa: E501
            query_params.append(('profileID', local_var_params['profile_id']))  # noqa: E501
            collection_formats['profileID'] = 'multi'  # noqa: E501
        if '_from' in local_var_params and local_var_params['_from'] is not None:  # noqa: E501
            query_params.append(('from', local_var_params['_from']))  # noqa: E501
        if 'to' in local_var_params and local_var_params['to'] is not None:  # noqa: E501
            query_params.append(('to', local_var_params['to']))  # noqa: E501
        if 'time' in local_var_params and local_var_params['time'] is not None:  # noqa: E501
            query_params.append(('time', local_var_params['time']))  # noqa: E501
        if 'image_name' in local_var_params and local_var_params['image_name'] is not None:  # noqa: E501
            query_params.append(('imageName', local_var_params['image_name']))  # noqa: E501
            collection_formats['imageName'] = 'multi'  # noqa: E501
        if 'container' in local_var_params and local_var_params['container'] is not None:  # noqa: E501
            query_params.append(('container', local_var_params['container']))  # noqa: E501
            collection_formats['container'] = 'multi'  # noqa: E501
        if 'container_id' in local_var_params and local_var_params['container_id'] is not None:  # noqa: E501
            query_params.append(('containerID', local_var_params['container_id']))  # noqa: E501
            collection_formats['containerID'] = 'multi'  # noqa: E501
        if 'rule_name' in local_var_params and local_var_params['rule_name'] is not None:  # noqa: E501
            query_params.append(('ruleName', local_var_params['rule_name']))  # noqa: E501
            collection_formats['ruleName'] = 'multi'  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
            collection_formats['type'] = 'multi'  # noqa: E501
        if 'effect' in local_var_params and local_var_params['effect'] is not None:  # noqa: E501
            query_params.append(('effect', local_var_params['effect']))  # noqa: E501
            collection_formats['effect'] = 'multi'  # noqa: E501
        if 'user' in local_var_params and local_var_params['user'] is not None:  # noqa: E501
            query_params.append(('user', local_var_params['user']))  # noqa: E501
            collection_formats['user'] = 'multi'  # noqa: E501
        if 'os' in local_var_params and local_var_params['os'] is not None:  # noqa: E501
            query_params.append(('os', local_var_params['os']))  # noqa: E501
            collection_formats['os'] = 'multi'  # noqa: E501
        if 'namespace' in local_var_params and local_var_params['namespace'] is not None:  # noqa: E501
            query_params.append(('namespace', local_var_params['namespace']))  # noqa: E501
            collection_formats['namespace'] = 'multi'  # noqa: E501
        if 'cluster' in local_var_params and local_var_params['cluster'] is not None:  # noqa: E501
            query_params.append(('cluster', local_var_params['cluster']))  # noqa: E501
            collection_formats['cluster'] = 'multi'  # noqa: E501
        if 'attack_type' in local_var_params and local_var_params['attack_type'] is not None:  # noqa: E501
            query_params.append(('attackType', local_var_params['attack_type']))  # noqa: E501
            collection_formats['attackType'] = 'multi'  # noqa: E501
        if 'hostname' in local_var_params and local_var_params['hostname'] is not None:  # noqa: E501
            query_params.append(('hostname', local_var_params['hostname']))  # noqa: E501
            collection_formats['hostname'] = 'multi'  # noqa: E501
        if 'msg' in local_var_params and local_var_params['msg'] is not None:  # noqa: E501
            query_params.append(('msg', local_var_params['msg']))  # noqa: E501
            collection_formats['msg'] = 'multi'  # noqa: E501
        if 'interactive' in local_var_params and local_var_params['interactive'] is not None:  # noqa: E501
            query_params.append(('interactive', local_var_params['interactive']))  # noqa: E501
            collection_formats['interactive'] = 'multi'  # noqa: E501
        if 'function' in local_var_params and local_var_params['function'] is not None:  # noqa: E501
            query_params.append(('function', local_var_params['function']))  # noqa: E501
            collection_formats['function'] = 'multi'  # noqa: E501
        if 'region' in local_var_params and local_var_params['region'] is not None:  # noqa: E501
            query_params.append(('region', local_var_params['region']))  # noqa: E501
            collection_formats['region'] = 'multi'  # noqa: E501
        if 'runtime' in local_var_params and local_var_params['runtime'] is not None:  # noqa: E501
            query_params.append(('runtime', local_var_params['runtime']))  # noqa: E501
            collection_formats['runtime'] = 'multi'  # noqa: E501
        if 'attack_techniques' in local_var_params and local_var_params['attack_techniques'] is not None:  # noqa: E501
            query_params.append(('attackTechniques', local_var_params['attack_techniques']))  # noqa: E501
            collection_formats['attackTechniques'] = 'multi'  # noqa: E501
        if 'app' in local_var_params and local_var_params['app'] is not None:  # noqa: E501
            query_params.append(('app', local_var_params['app']))  # noqa: E501
            collection_formats['app'] = 'multi'  # noqa: E501
        if 'process_path' in local_var_params and local_var_params['process_path'] is not None:  # noqa: E501
            query_params.append(('processPath', local_var_params['process_path']))  # noqa: E501
            collection_formats['processPath'] = 'multi'  # noqa: E501
        if 'request_id' in local_var_params and local_var_params['request_id'] is not None:  # noqa: E501
            query_params.append(('requestID', local_var_params['request_id']))  # noqa: E501
            collection_formats['requestID'] = 'multi'  # noqa: E501
        if 'function_id' in local_var_params and local_var_params['function_id'] is not None:  # noqa: E501
            query_params.append(('functionID', local_var_params['function_id']))  # noqa: E501
            collection_formats['functionID'] = 'multi'  # noqa: E501
        if 'aggregate' in local_var_params and local_var_params['aggregate'] is not None:  # noqa: E501
            query_params.append(('aggregate', local_var_params['aggregate']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "list[SharedRuntimeAudit]",
        }

        return self.api_client.call_api(
            '/api/v1/audits/runtime/app-embedded', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_runtime_container_download_get(self, **kwargs):  # noqa: E501
        """api_v1_audits_runtime_container_download_get  # noqa: E501

        DownloadContainerRuntimeAudits downloads the runtime audits according to the specified query   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_runtime_container_download_get(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param profile_id: ProfileIDs are the profile IDs to filter. 
        :type profile_id: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param time: Time is used to filter by audit time. 
        :type time: datetime
        :param image_name: ImageNames is the image name filter. 
        :type image_name: list[str]
        :param container: Containers is the container name filter. 
        :type container: list[str]
        :param container_id: ContainerID is used to filter by container ID. 
        :type container_id: list[str]
        :param rule_name: RuleNames is used to filter by rule name. 
        :type rule_name: list[str]
        :param type: Types is used to filter by runtime audit type. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect (e.g., block/alert). 
        :type effect: list[str]
        :param user: Users is used to filter by host users. 
        :type user: list[str]
        :param os: OS is the image OS distro filter. 
        :type os: list[str]
        :param namespace: Namespaces is the namespaces filter. 
        :type namespace: list[str]
        :param cluster: Clusters is the cluster filter. 
        :type cluster: list[str]
        :param attack_type: AttackTypes is used to filter by runtime audit attack type. 
        :type attack_type: list[str]
        :param hostname: Hostname is the hostname filter. 
        :type hostname: list[str]
        :param msg: Message is the audit message text filter. 
        :type msg: list[str]
        :param interactive: Interactive is the audit interactive filter. 
        :type interactive: list[str]
        :param function: Function is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param app: App is the name constraint of the service that triggered the audit. 
        :type app: list[str]
        :param process_path: ProcessPath is the path constraint of the process that triggered the audit. 
        :type process_path: list[str]
        :param request_id: RequestID is used to filter by request ID. 
        :type request_id: list[str]
        :param function_id: FunctionID is used to filter by function ID. 
        :type function_id: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_runtime_container_download_get_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_runtime_container_download_get_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_runtime_container_download_get  # noqa: E501

        DownloadContainerRuntimeAudits downloads the runtime audits according to the specified query   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_runtime_container_download_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param profile_id: ProfileIDs are the profile IDs to filter. 
        :type profile_id: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param time: Time is used to filter by audit time. 
        :type time: datetime
        :param image_name: ImageNames is the image name filter. 
        :type image_name: list[str]
        :param container: Containers is the container name filter. 
        :type container: list[str]
        :param container_id: ContainerID is used to filter by container ID. 
        :type container_id: list[str]
        :param rule_name: RuleNames is used to filter by rule name. 
        :type rule_name: list[str]
        :param type: Types is used to filter by runtime audit type. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect (e.g., block/alert). 
        :type effect: list[str]
        :param user: Users is used to filter by host users. 
        :type user: list[str]
        :param os: OS is the image OS distro filter. 
        :type os: list[str]
        :param namespace: Namespaces is the namespaces filter. 
        :type namespace: list[str]
        :param cluster: Clusters is the cluster filter. 
        :type cluster: list[str]
        :param attack_type: AttackTypes is used to filter by runtime audit attack type. 
        :type attack_type: list[str]
        :param hostname: Hostname is the hostname filter. 
        :type hostname: list[str]
        :param msg: Message is the audit message text filter. 
        :type msg: list[str]
        :param interactive: Interactive is the audit interactive filter. 
        :type interactive: list[str]
        :param function: Function is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param app: App is the name constraint of the service that triggered the audit. 
        :type app: list[str]
        :param process_path: ProcessPath is the path constraint of the process that triggered the audit. 
        :type process_path: list[str]
        :param request_id: RequestID is used to filter by request ID. 
        :type request_id: list[str]
        :param function_id: FunctionID is used to filter by function ID. 
        :type function_id: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'offset',
            'limit',
            'search',
            'sort',
            'reverse',
            'collections',
            'account_ids',
            'fields',
            'profile_id',
            '_from',
            'to',
            'time',
            'image_name',
            'container',
            'container_id',
            'rule_name',
            'type',
            'effect',
            'user',
            'os',
            'namespace',
            'cluster',
            'attack_type',
            'hostname',
            'msg',
            'interactive',
            'function',
            'region',
            'runtime',
            'attack_techniques',
            'app',
            'process_path',
            'request_id',
            'function_id',
            'aggregate'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_runtime_container_download_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'reverse' in local_var_params and local_var_params['reverse'] is not None:  # noqa: E501
            query_params.append(('reverse', local_var_params['reverse']))  # noqa: E501
        if 'collections' in local_var_params and local_var_params['collections'] is not None:  # noqa: E501
            query_params.append(('collections', local_var_params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'account_ids' in local_var_params and local_var_params['account_ids'] is not None:  # noqa: E501
            query_params.append(('accountIDs', local_var_params['account_ids']))  # noqa: E501
            collection_formats['accountIDs'] = 'multi'  # noqa: E501
        if 'fields' in local_var_params and local_var_params['fields'] is not None:  # noqa: E501
            query_params.append(('fields', local_var_params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if 'profile_id' in local_var_params and local_var_params['profile_id'] is not None:  # noqa: E501
            query_params.append(('profileID', local_var_params['profile_id']))  # noqa: E501
            collection_formats['profileID'] = 'multi'  # noqa: E501
        if '_from' in local_var_params and local_var_params['_from'] is not None:  # noqa: E501
            query_params.append(('from', local_var_params['_from']))  # noqa: E501
        if 'to' in local_var_params and local_var_params['to'] is not None:  # noqa: E501
            query_params.append(('to', local_var_params['to']))  # noqa: E501
        if 'time' in local_var_params and local_var_params['time'] is not None:  # noqa: E501
            query_params.append(('time', local_var_params['time']))  # noqa: E501
        if 'image_name' in local_var_params and local_var_params['image_name'] is not None:  # noqa: E501
            query_params.append(('imageName', local_var_params['image_name']))  # noqa: E501
            collection_formats['imageName'] = 'multi'  # noqa: E501
        if 'container' in local_var_params and local_var_params['container'] is not None:  # noqa: E501
            query_params.append(('container', local_var_params['container']))  # noqa: E501
            collection_formats['container'] = 'multi'  # noqa: E501
        if 'container_id' in local_var_params and local_var_params['container_id'] is not None:  # noqa: E501
            query_params.append(('containerID', local_var_params['container_id']))  # noqa: E501
            collection_formats['containerID'] = 'multi'  # noqa: E501
        if 'rule_name' in local_var_params and local_var_params['rule_name'] is not None:  # noqa: E501
            query_params.append(('ruleName', local_var_params['rule_name']))  # noqa: E501
            collection_formats['ruleName'] = 'multi'  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
            collection_formats['type'] = 'multi'  # noqa: E501
        if 'effect' in local_var_params and local_var_params['effect'] is not None:  # noqa: E501
            query_params.append(('effect', local_var_params['effect']))  # noqa: E501
            collection_formats['effect'] = 'multi'  # noqa: E501
        if 'user' in local_var_params and local_var_params['user'] is not None:  # noqa: E501
            query_params.append(('user', local_var_params['user']))  # noqa: E501
            collection_formats['user'] = 'multi'  # noqa: E501
        if 'os' in local_var_params and local_var_params['os'] is not None:  # noqa: E501
            query_params.append(('os', local_var_params['os']))  # noqa: E501
            collection_formats['os'] = 'multi'  # noqa: E501
        if 'namespace' in local_var_params and local_var_params['namespace'] is not None:  # noqa: E501
            query_params.append(('namespace', local_var_params['namespace']))  # noqa: E501
            collection_formats['namespace'] = 'multi'  # noqa: E501
        if 'cluster' in local_var_params and local_var_params['cluster'] is not None:  # noqa: E501
            query_params.append(('cluster', local_var_params['cluster']))  # noqa: E501
            collection_formats['cluster'] = 'multi'  # noqa: E501
        if 'attack_type' in local_var_params and local_var_params['attack_type'] is not None:  # noqa: E501
            query_params.append(('attackType', local_var_params['attack_type']))  # noqa: E501
            collection_formats['attackType'] = 'multi'  # noqa: E501
        if 'hostname' in local_var_params and local_var_params['hostname'] is not None:  # noqa: E501
            query_params.append(('hostname', local_var_params['hostname']))  # noqa: E501
            collection_formats['hostname'] = 'multi'  # noqa: E501
        if 'msg' in local_var_params and local_var_params['msg'] is not None:  # noqa: E501
            query_params.append(('msg', local_var_params['msg']))  # noqa: E501
            collection_formats['msg'] = 'multi'  # noqa: E501
        if 'interactive' in local_var_params and local_var_params['interactive'] is not None:  # noqa: E501
            query_params.append(('interactive', local_var_params['interactive']))  # noqa: E501
            collection_formats['interactive'] = 'multi'  # noqa: E501
        if 'function' in local_var_params and local_var_params['function'] is not None:  # noqa: E501
            query_params.append(('function', local_var_params['function']))  # noqa: E501
            collection_formats['function'] = 'multi'  # noqa: E501
        if 'region' in local_var_params and local_var_params['region'] is not None:  # noqa: E501
            query_params.append(('region', local_var_params['region']))  # noqa: E501
            collection_formats['region'] = 'multi'  # noqa: E501
        if 'runtime' in local_var_params and local_var_params['runtime'] is not None:  # noqa: E501
            query_params.append(('runtime', local_var_params['runtime']))  # noqa: E501
            collection_formats['runtime'] = 'multi'  # noqa: E501
        if 'attack_techniques' in local_var_params and local_var_params['attack_techniques'] is not None:  # noqa: E501
            query_params.append(('attackTechniques', local_var_params['attack_techniques']))  # noqa: E501
            collection_formats['attackTechniques'] = 'multi'  # noqa: E501
        if 'app' in local_var_params and local_var_params['app'] is not None:  # noqa: E501
            query_params.append(('app', local_var_params['app']))  # noqa: E501
            collection_formats['app'] = 'multi'  # noqa: E501
        if 'process_path' in local_var_params and local_var_params['process_path'] is not None:  # noqa: E501
            query_params.append(('processPath', local_var_params['process_path']))  # noqa: E501
            collection_formats['processPath'] = 'multi'  # noqa: E501
        if 'request_id' in local_var_params and local_var_params['request_id'] is not None:  # noqa: E501
            query_params.append(('requestID', local_var_params['request_id']))  # noqa: E501
            collection_formats['requestID'] = 'multi'  # noqa: E501
        if 'function_id' in local_var_params and local_var_params['function_id'] is not None:  # noqa: E501
            query_params.append(('functionID', local_var_params['function_id']))  # noqa: E501
            collection_formats['functionID'] = 'multi'  # noqa: E501
        if 'aggregate' in local_var_params and local_var_params['aggregate'] is not None:  # noqa: E501
            query_params.append(('aggregate', local_var_params['aggregate']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/audits/runtime/container/download', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_runtime_container_get(self, **kwargs):  # noqa: E501
        """api_v1_audits_runtime_container_get  # noqa: E501

        ContainerRuntimeAudits returns container runtime audits   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_runtime_container_get(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param profile_id: ProfileIDs are the profile IDs to filter. 
        :type profile_id: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param time: Time is used to filter by audit time. 
        :type time: datetime
        :param image_name: ImageNames is the image name filter. 
        :type image_name: list[str]
        :param container: Containers is the container name filter. 
        :type container: list[str]
        :param container_id: ContainerID is used to filter by container ID. 
        :type container_id: list[str]
        :param rule_name: RuleNames is used to filter by rule name. 
        :type rule_name: list[str]
        :param type: Types is used to filter by runtime audit type. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect (e.g., block/alert). 
        :type effect: list[str]
        :param user: Users is used to filter by host users. 
        :type user: list[str]
        :param os: OS is the image OS distro filter. 
        :type os: list[str]
        :param namespace: Namespaces is the namespaces filter. 
        :type namespace: list[str]
        :param cluster: Clusters is the cluster filter. 
        :type cluster: list[str]
        :param attack_type: AttackTypes is used to filter by runtime audit attack type. 
        :type attack_type: list[str]
        :param hostname: Hostname is the hostname filter. 
        :type hostname: list[str]
        :param msg: Message is the audit message text filter. 
        :type msg: list[str]
        :param interactive: Interactive is the audit interactive filter. 
        :type interactive: list[str]
        :param function: Function is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param app: App is the name constraint of the service that triggered the audit. 
        :type app: list[str]
        :param process_path: ProcessPath is the path constraint of the process that triggered the audit. 
        :type process_path: list[str]
        :param request_id: RequestID is used to filter by request ID. 
        :type request_id: list[str]
        :param function_id: FunctionID is used to filter by function ID. 
        :type function_id: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[SharedRuntimeAudit]
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_runtime_container_get_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_runtime_container_get_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_runtime_container_get  # noqa: E501

        ContainerRuntimeAudits returns container runtime audits   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_runtime_container_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param profile_id: ProfileIDs are the profile IDs to filter. 
        :type profile_id: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param time: Time is used to filter by audit time. 
        :type time: datetime
        :param image_name: ImageNames is the image name filter. 
        :type image_name: list[str]
        :param container: Containers is the container name filter. 
        :type container: list[str]
        :param container_id: ContainerID is used to filter by container ID. 
        :type container_id: list[str]
        :param rule_name: RuleNames is used to filter by rule name. 
        :type rule_name: list[str]
        :param type: Types is used to filter by runtime audit type. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect (e.g., block/alert). 
        :type effect: list[str]
        :param user: Users is used to filter by host users. 
        :type user: list[str]
        :param os: OS is the image OS distro filter. 
        :type os: list[str]
        :param namespace: Namespaces is the namespaces filter. 
        :type namespace: list[str]
        :param cluster: Clusters is the cluster filter. 
        :type cluster: list[str]
        :param attack_type: AttackTypes is used to filter by runtime audit attack type. 
        :type attack_type: list[str]
        :param hostname: Hostname is the hostname filter. 
        :type hostname: list[str]
        :param msg: Message is the audit message text filter. 
        :type msg: list[str]
        :param interactive: Interactive is the audit interactive filter. 
        :type interactive: list[str]
        :param function: Function is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param app: App is the name constraint of the service that triggered the audit. 
        :type app: list[str]
        :param process_path: ProcessPath is the path constraint of the process that triggered the audit. 
        :type process_path: list[str]
        :param request_id: RequestID is used to filter by request ID. 
        :type request_id: list[str]
        :param function_id: FunctionID is used to filter by function ID. 
        :type function_id: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[SharedRuntimeAudit], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'offset',
            'limit',
            'search',
            'sort',
            'reverse',
            'collections',
            'account_ids',
            'fields',
            'profile_id',
            '_from',
            'to',
            'time',
            'image_name',
            'container',
            'container_id',
            'rule_name',
            'type',
            'effect',
            'user',
            'os',
            'namespace',
            'cluster',
            'attack_type',
            'hostname',
            'msg',
            'interactive',
            'function',
            'region',
            'runtime',
            'attack_techniques',
            'app',
            'process_path',
            'request_id',
            'function_id',
            'aggregate'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_runtime_container_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'reverse' in local_var_params and local_var_params['reverse'] is not None:  # noqa: E501
            query_params.append(('reverse', local_var_params['reverse']))  # noqa: E501
        if 'collections' in local_var_params and local_var_params['collections'] is not None:  # noqa: E501
            query_params.append(('collections', local_var_params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'account_ids' in local_var_params and local_var_params['account_ids'] is not None:  # noqa: E501
            query_params.append(('accountIDs', local_var_params['account_ids']))  # noqa: E501
            collection_formats['accountIDs'] = 'multi'  # noqa: E501
        if 'fields' in local_var_params and local_var_params['fields'] is not None:  # noqa: E501
            query_params.append(('fields', local_var_params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if 'profile_id' in local_var_params and local_var_params['profile_id'] is not None:  # noqa: E501
            query_params.append(('profileID', local_var_params['profile_id']))  # noqa: E501
            collection_formats['profileID'] = 'multi'  # noqa: E501
        if '_from' in local_var_params and local_var_params['_from'] is not None:  # noqa: E501
            query_params.append(('from', local_var_params['_from']))  # noqa: E501
        if 'to' in local_var_params and local_var_params['to'] is not None:  # noqa: E501
            query_params.append(('to', local_var_params['to']))  # noqa: E501
        if 'time' in local_var_params and local_var_params['time'] is not None:  # noqa: E501
            query_params.append(('time', local_var_params['time']))  # noqa: E501
        if 'image_name' in local_var_params and local_var_params['image_name'] is not None:  # noqa: E501
            query_params.append(('imageName', local_var_params['image_name']))  # noqa: E501
            collection_formats['imageName'] = 'multi'  # noqa: E501
        if 'container' in local_var_params and local_var_params['container'] is not None:  # noqa: E501
            query_params.append(('container', local_var_params['container']))  # noqa: E501
            collection_formats['container'] = 'multi'  # noqa: E501
        if 'container_id' in local_var_params and local_var_params['container_id'] is not None:  # noqa: E501
            query_params.append(('containerID', local_var_params['container_id']))  # noqa: E501
            collection_formats['containerID'] = 'multi'  # noqa: E501
        if 'rule_name' in local_var_params and local_var_params['rule_name'] is not None:  # noqa: E501
            query_params.append(('ruleName', local_var_params['rule_name']))  # noqa: E501
            collection_formats['ruleName'] = 'multi'  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
            collection_formats['type'] = 'multi'  # noqa: E501
        if 'effect' in local_var_params and local_var_params['effect'] is not None:  # noqa: E501
            query_params.append(('effect', local_var_params['effect']))  # noqa: E501
            collection_formats['effect'] = 'multi'  # noqa: E501
        if 'user' in local_var_params and local_var_params['user'] is not None:  # noqa: E501
            query_params.append(('user', local_var_params['user']))  # noqa: E501
            collection_formats['user'] = 'multi'  # noqa: E501
        if 'os' in local_var_params and local_var_params['os'] is not None:  # noqa: E501
            query_params.append(('os', local_var_params['os']))  # noqa: E501
            collection_formats['os'] = 'multi'  # noqa: E501
        if 'namespace' in local_var_params and local_var_params['namespace'] is not None:  # noqa: E501
            query_params.append(('namespace', local_var_params['namespace']))  # noqa: E501
            collection_formats['namespace'] = 'multi'  # noqa: E501
        if 'cluster' in local_var_params and local_var_params['cluster'] is not None:  # noqa: E501
            query_params.append(('cluster', local_var_params['cluster']))  # noqa: E501
            collection_formats['cluster'] = 'multi'  # noqa: E501
        if 'attack_type' in local_var_params and local_var_params['attack_type'] is not None:  # noqa: E501
            query_params.append(('attackType', local_var_params['attack_type']))  # noqa: E501
            collection_formats['attackType'] = 'multi'  # noqa: E501
        if 'hostname' in local_var_params and local_var_params['hostname'] is not None:  # noqa: E501
            query_params.append(('hostname', local_var_params['hostname']))  # noqa: E501
            collection_formats['hostname'] = 'multi'  # noqa: E501
        if 'msg' in local_var_params and local_var_params['msg'] is not None:  # noqa: E501
            query_params.append(('msg', local_var_params['msg']))  # noqa: E501
            collection_formats['msg'] = 'multi'  # noqa: E501
        if 'interactive' in local_var_params and local_var_params['interactive'] is not None:  # noqa: E501
            query_params.append(('interactive', local_var_params['interactive']))  # noqa: E501
            collection_formats['interactive'] = 'multi'  # noqa: E501
        if 'function' in local_var_params and local_var_params['function'] is not None:  # noqa: E501
            query_params.append(('function', local_var_params['function']))  # noqa: E501
            collection_formats['function'] = 'multi'  # noqa: E501
        if 'region' in local_var_params and local_var_params['region'] is not None:  # noqa: E501
            query_params.append(('region', local_var_params['region']))  # noqa: E501
            collection_formats['region'] = 'multi'  # noqa: E501
        if 'runtime' in local_var_params and local_var_params['runtime'] is not None:  # noqa: E501
            query_params.append(('runtime', local_var_params['runtime']))  # noqa: E501
            collection_formats['runtime'] = 'multi'  # noqa: E501
        if 'attack_techniques' in local_var_params and local_var_params['attack_techniques'] is not None:  # noqa: E501
            query_params.append(('attackTechniques', local_var_params['attack_techniques']))  # noqa: E501
            collection_formats['attackTechniques'] = 'multi'  # noqa: E501
        if 'app' in local_var_params and local_var_params['app'] is not None:  # noqa: E501
            query_params.append(('app', local_var_params['app']))  # noqa: E501
            collection_formats['app'] = 'multi'  # noqa: E501
        if 'process_path' in local_var_params and local_var_params['process_path'] is not None:  # noqa: E501
            query_params.append(('processPath', local_var_params['process_path']))  # noqa: E501
            collection_formats['processPath'] = 'multi'  # noqa: E501
        if 'request_id' in local_var_params and local_var_params['request_id'] is not None:  # noqa: E501
            query_params.append(('requestID', local_var_params['request_id']))  # noqa: E501
            collection_formats['requestID'] = 'multi'  # noqa: E501
        if 'function_id' in local_var_params and local_var_params['function_id'] is not None:  # noqa: E501
            query_params.append(('functionID', local_var_params['function_id']))  # noqa: E501
            collection_formats['functionID'] = 'multi'  # noqa: E501
        if 'aggregate' in local_var_params and local_var_params['aggregate'] is not None:  # noqa: E501
            query_params.append(('aggregate', local_var_params['aggregate']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "list[SharedRuntimeAudit]",
        }

        return self.api_client.call_api(
            '/api/v1/audits/runtime/container', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_runtime_container_timeslice_get(self, **kwargs):  # noqa: E501
        """api_v1_audits_runtime_container_timeslice_get  # noqa: E501

        ContainerRuntimeAuditsTimeslice returns container runtime audit buckets according to the query timeframe   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_runtime_container_timeslice_get(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param profile_id: ProfileIDs are the profile IDs to filter. 
        :type profile_id: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param time: Time is used to filter by audit time. 
        :type time: datetime
        :param image_name: ImageNames is the image name filter. 
        :type image_name: list[str]
        :param container: Containers is the container name filter. 
        :type container: list[str]
        :param container_id: ContainerID is used to filter by container ID. 
        :type container_id: list[str]
        :param rule_name: RuleNames is used to filter by rule name. 
        :type rule_name: list[str]
        :param type: Types is used to filter by runtime audit type. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect (e.g., block/alert). 
        :type effect: list[str]
        :param user: Users is used to filter by host users. 
        :type user: list[str]
        :param os: OS is the image OS distro filter. 
        :type os: list[str]
        :param namespace: Namespaces is the namespaces filter. 
        :type namespace: list[str]
        :param cluster: Clusters is the cluster filter. 
        :type cluster: list[str]
        :param attack_type: AttackTypes is used to filter by runtime audit attack type. 
        :type attack_type: list[str]
        :param hostname: Hostname is the hostname filter. 
        :type hostname: list[str]
        :param msg: Message is the audit message text filter. 
        :type msg: list[str]
        :param interactive: Interactive is the audit interactive filter. 
        :type interactive: list[str]
        :param function: Function is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param app: App is the name constraint of the service that triggered the audit. 
        :type app: list[str]
        :param process_path: ProcessPath is the path constraint of the process that triggered the audit. 
        :type process_path: list[str]
        :param request_id: RequestID is used to filter by request ID. 
        :type request_id: list[str]
        :param function_id: FunctionID is used to filter by function ID. 
        :type function_id: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param buckets: Buckets is the number of buckets to return. 
        :type buckets: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[TypesAuditTimeslice]
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_runtime_container_timeslice_get_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_runtime_container_timeslice_get_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_runtime_container_timeslice_get  # noqa: E501

        ContainerRuntimeAuditsTimeslice returns container runtime audit buckets according to the query timeframe   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_runtime_container_timeslice_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param profile_id: ProfileIDs are the profile IDs to filter. 
        :type profile_id: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param time: Time is used to filter by audit time. 
        :type time: datetime
        :param image_name: ImageNames is the image name filter. 
        :type image_name: list[str]
        :param container: Containers is the container name filter. 
        :type container: list[str]
        :param container_id: ContainerID is used to filter by container ID. 
        :type container_id: list[str]
        :param rule_name: RuleNames is used to filter by rule name. 
        :type rule_name: list[str]
        :param type: Types is used to filter by runtime audit type. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect (e.g., block/alert). 
        :type effect: list[str]
        :param user: Users is used to filter by host users. 
        :type user: list[str]
        :param os: OS is the image OS distro filter. 
        :type os: list[str]
        :param namespace: Namespaces is the namespaces filter. 
        :type namespace: list[str]
        :param cluster: Clusters is the cluster filter. 
        :type cluster: list[str]
        :param attack_type: AttackTypes is used to filter by runtime audit attack type. 
        :type attack_type: list[str]
        :param hostname: Hostname is the hostname filter. 
        :type hostname: list[str]
        :param msg: Message is the audit message text filter. 
        :type msg: list[str]
        :param interactive: Interactive is the audit interactive filter. 
        :type interactive: list[str]
        :param function: Function is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param app: App is the name constraint of the service that triggered the audit. 
        :type app: list[str]
        :param process_path: ProcessPath is the path constraint of the process that triggered the audit. 
        :type process_path: list[str]
        :param request_id: RequestID is used to filter by request ID. 
        :type request_id: list[str]
        :param function_id: FunctionID is used to filter by function ID. 
        :type function_id: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param buckets: Buckets is the number of buckets to return. 
        :type buckets: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[TypesAuditTimeslice], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'offset',
            'limit',
            'search',
            'sort',
            'reverse',
            'collections',
            'account_ids',
            'fields',
            'profile_id',
            '_from',
            'to',
            'time',
            'image_name',
            'container',
            'container_id',
            'rule_name',
            'type',
            'effect',
            'user',
            'os',
            'namespace',
            'cluster',
            'attack_type',
            'hostname',
            'msg',
            'interactive',
            'function',
            'region',
            'runtime',
            'attack_techniques',
            'app',
            'process_path',
            'request_id',
            'function_id',
            'aggregate',
            'buckets'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_runtime_container_timeslice_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'reverse' in local_var_params and local_var_params['reverse'] is not None:  # noqa: E501
            query_params.append(('reverse', local_var_params['reverse']))  # noqa: E501
        if 'collections' in local_var_params and local_var_params['collections'] is not None:  # noqa: E501
            query_params.append(('collections', local_var_params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'account_ids' in local_var_params and local_var_params['account_ids'] is not None:  # noqa: E501
            query_params.append(('accountIDs', local_var_params['account_ids']))  # noqa: E501
            collection_formats['accountIDs'] = 'multi'  # noqa: E501
        if 'fields' in local_var_params and local_var_params['fields'] is not None:  # noqa: E501
            query_params.append(('fields', local_var_params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if 'profile_id' in local_var_params and local_var_params['profile_id'] is not None:  # noqa: E501
            query_params.append(('profileID', local_var_params['profile_id']))  # noqa: E501
            collection_formats['profileID'] = 'multi'  # noqa: E501
        if '_from' in local_var_params and local_var_params['_from'] is not None:  # noqa: E501
            query_params.append(('from', local_var_params['_from']))  # noqa: E501
        if 'to' in local_var_params and local_var_params['to'] is not None:  # noqa: E501
            query_params.append(('to', local_var_params['to']))  # noqa: E501
        if 'time' in local_var_params and local_var_params['time'] is not None:  # noqa: E501
            query_params.append(('time', local_var_params['time']))  # noqa: E501
        if 'image_name' in local_var_params and local_var_params['image_name'] is not None:  # noqa: E501
            query_params.append(('imageName', local_var_params['image_name']))  # noqa: E501
            collection_formats['imageName'] = 'multi'  # noqa: E501
        if 'container' in local_var_params and local_var_params['container'] is not None:  # noqa: E501
            query_params.append(('container', local_var_params['container']))  # noqa: E501
            collection_formats['container'] = 'multi'  # noqa: E501
        if 'container_id' in local_var_params and local_var_params['container_id'] is not None:  # noqa: E501
            query_params.append(('containerID', local_var_params['container_id']))  # noqa: E501
            collection_formats['containerID'] = 'multi'  # noqa: E501
        if 'rule_name' in local_var_params and local_var_params['rule_name'] is not None:  # noqa: E501
            query_params.append(('ruleName', local_var_params['rule_name']))  # noqa: E501
            collection_formats['ruleName'] = 'multi'  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
            collection_formats['type'] = 'multi'  # noqa: E501
        if 'effect' in local_var_params and local_var_params['effect'] is not None:  # noqa: E501
            query_params.append(('effect', local_var_params['effect']))  # noqa: E501
            collection_formats['effect'] = 'multi'  # noqa: E501
        if 'user' in local_var_params and local_var_params['user'] is not None:  # noqa: E501
            query_params.append(('user', local_var_params['user']))  # noqa: E501
            collection_formats['user'] = 'multi'  # noqa: E501
        if 'os' in local_var_params and local_var_params['os'] is not None:  # noqa: E501
            query_params.append(('os', local_var_params['os']))  # noqa: E501
            collection_formats['os'] = 'multi'  # noqa: E501
        if 'namespace' in local_var_params and local_var_params['namespace'] is not None:  # noqa: E501
            query_params.append(('namespace', local_var_params['namespace']))  # noqa: E501
            collection_formats['namespace'] = 'multi'  # noqa: E501
        if 'cluster' in local_var_params and local_var_params['cluster'] is not None:  # noqa: E501
            query_params.append(('cluster', local_var_params['cluster']))  # noqa: E501
            collection_formats['cluster'] = 'multi'  # noqa: E501
        if 'attack_type' in local_var_params and local_var_params['attack_type'] is not None:  # noqa: E501
            query_params.append(('attackType', local_var_params['attack_type']))  # noqa: E501
            collection_formats['attackType'] = 'multi'  # noqa: E501
        if 'hostname' in local_var_params and local_var_params['hostname'] is not None:  # noqa: E501
            query_params.append(('hostname', local_var_params['hostname']))  # noqa: E501
            collection_formats['hostname'] = 'multi'  # noqa: E501
        if 'msg' in local_var_params and local_var_params['msg'] is not None:  # noqa: E501
            query_params.append(('msg', local_var_params['msg']))  # noqa: E501
            collection_formats['msg'] = 'multi'  # noqa: E501
        if 'interactive' in local_var_params and local_var_params['interactive'] is not None:  # noqa: E501
            query_params.append(('interactive', local_var_params['interactive']))  # noqa: E501
            collection_formats['interactive'] = 'multi'  # noqa: E501
        if 'function' in local_var_params and local_var_params['function'] is not None:  # noqa: E501
            query_params.append(('function', local_var_params['function']))  # noqa: E501
            collection_formats['function'] = 'multi'  # noqa: E501
        if 'region' in local_var_params and local_var_params['region'] is not None:  # noqa: E501
            query_params.append(('region', local_var_params['region']))  # noqa: E501
            collection_formats['region'] = 'multi'  # noqa: E501
        if 'runtime' in local_var_params and local_var_params['runtime'] is not None:  # noqa: E501
            query_params.append(('runtime', local_var_params['runtime']))  # noqa: E501
            collection_formats['runtime'] = 'multi'  # noqa: E501
        if 'attack_techniques' in local_var_params and local_var_params['attack_techniques'] is not None:  # noqa: E501
            query_params.append(('attackTechniques', local_var_params['attack_techniques']))  # noqa: E501
            collection_formats['attackTechniques'] = 'multi'  # noqa: E501
        if 'app' in local_var_params and local_var_params['app'] is not None:  # noqa: E501
            query_params.append(('app', local_var_params['app']))  # noqa: E501
            collection_formats['app'] = 'multi'  # noqa: E501
        if 'process_path' in local_var_params and local_var_params['process_path'] is not None:  # noqa: E501
            query_params.append(('processPath', local_var_params['process_path']))  # noqa: E501
            collection_formats['processPath'] = 'multi'  # noqa: E501
        if 'request_id' in local_var_params and local_var_params['request_id'] is not None:  # noqa: E501
            query_params.append(('requestID', local_var_params['request_id']))  # noqa: E501
            collection_formats['requestID'] = 'multi'  # noqa: E501
        if 'function_id' in local_var_params and local_var_params['function_id'] is not None:  # noqa: E501
            query_params.append(('functionID', local_var_params['function_id']))  # noqa: E501
            collection_formats['functionID'] = 'multi'  # noqa: E501
        if 'aggregate' in local_var_params and local_var_params['aggregate'] is not None:  # noqa: E501
            query_params.append(('aggregate', local_var_params['aggregate']))  # noqa: E501
        if 'buckets' in local_var_params and local_var_params['buckets'] is not None:  # noqa: E501
            query_params.append(('buckets', local_var_params['buckets']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "list[TypesAuditTimeslice]",
        }

        return self.api_client.call_api(
            '/api/v1/audits/runtime/container/timeslice', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_runtime_file_integrity_download_get(self, **kwargs):  # noqa: E501
        """api_v1_audits_runtime_file_integrity_download_get  # noqa: E501

        DownloadFileIntegrityEvents downloads the file integrity events according to the specified query   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_runtime_file_integrity_download_get(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the event. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the event. 
        :type to: datetime
        :param hostname: Hosts is the list of hosts to use for filtering. 
        :type hostname: list[str]
        :param path: Paths is the list of paths to use for filtering. 
        :type path: list[str]
        :param event_type: EventTypes is the list of file intergrity events to use for filtering. 
        :type event_type: list[str]
        :param cluster: Clusters is the cluster filter. 
        :type cluster: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_runtime_file_integrity_download_get_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_runtime_file_integrity_download_get_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_runtime_file_integrity_download_get  # noqa: E501

        DownloadFileIntegrityEvents downloads the file integrity events according to the specified query   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_runtime_file_integrity_download_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the event. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the event. 
        :type to: datetime
        :param hostname: Hosts is the list of hosts to use for filtering. 
        :type hostname: list[str]
        :param path: Paths is the list of paths to use for filtering. 
        :type path: list[str]
        :param event_type: EventTypes is the list of file intergrity events to use for filtering. 
        :type event_type: list[str]
        :param cluster: Clusters is the cluster filter. 
        :type cluster: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'offset',
            'limit',
            'search',
            'sort',
            'reverse',
            'collections',
            'account_ids',
            'fields',
            '_from',
            'to',
            'hostname',
            'path',
            'event_type',
            'cluster'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_runtime_file_integrity_download_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'reverse' in local_var_params and local_var_params['reverse'] is not None:  # noqa: E501
            query_params.append(('reverse', local_var_params['reverse']))  # noqa: E501
        if 'collections' in local_var_params and local_var_params['collections'] is not None:  # noqa: E501
            query_params.append(('collections', local_var_params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'account_ids' in local_var_params and local_var_params['account_ids'] is not None:  # noqa: E501
            query_params.append(('accountIDs', local_var_params['account_ids']))  # noqa: E501
            collection_formats['accountIDs'] = 'multi'  # noqa: E501
        if 'fields' in local_var_params and local_var_params['fields'] is not None:  # noqa: E501
            query_params.append(('fields', local_var_params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if '_from' in local_var_params and local_var_params['_from'] is not None:  # noqa: E501
            query_params.append(('from', local_var_params['_from']))  # noqa: E501
        if 'to' in local_var_params and local_var_params['to'] is not None:  # noqa: E501
            query_params.append(('to', local_var_params['to']))  # noqa: E501
        if 'hostname' in local_var_params and local_var_params['hostname'] is not None:  # noqa: E501
            query_params.append(('hostname', local_var_params['hostname']))  # noqa: E501
            collection_formats['hostname'] = 'multi'  # noqa: E501
        if 'path' in local_var_params and local_var_params['path'] is not None:  # noqa: E501
            query_params.append(('path', local_var_params['path']))  # noqa: E501
            collection_formats['path'] = 'multi'  # noqa: E501
        if 'event_type' in local_var_params and local_var_params['event_type'] is not None:  # noqa: E501
            query_params.append(('eventType', local_var_params['event_type']))  # noqa: E501
            collection_formats['eventType'] = 'multi'  # noqa: E501
        if 'cluster' in local_var_params and local_var_params['cluster'] is not None:  # noqa: E501
            query_params.append(('cluster', local_var_params['cluster']))  # noqa: E501
            collection_formats['cluster'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/audits/runtime/file-integrity/download', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_runtime_file_integrity_get(self, **kwargs):  # noqa: E501
        """api_v1_audits_runtime_file_integrity_get  # noqa: E501

        FileIntegrityEvents returns the file integrity events   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_runtime_file_integrity_get(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the event. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the event. 
        :type to: datetime
        :param hostname: Hosts is the list of hosts to use for filtering. 
        :type hostname: list[str]
        :param path: Paths is the list of paths to use for filtering. 
        :type path: list[str]
        :param event_type: EventTypes is the list of file intergrity events to use for filtering. 
        :type event_type: list[str]
        :param cluster: Clusters is the cluster filter. 
        :type cluster: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[SharedFileIntegrityEvent]
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_runtime_file_integrity_get_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_runtime_file_integrity_get_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_runtime_file_integrity_get  # noqa: E501

        FileIntegrityEvents returns the file integrity events   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_runtime_file_integrity_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the event. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the event. 
        :type to: datetime
        :param hostname: Hosts is the list of hosts to use for filtering. 
        :type hostname: list[str]
        :param path: Paths is the list of paths to use for filtering. 
        :type path: list[str]
        :param event_type: EventTypes is the list of file intergrity events to use for filtering. 
        :type event_type: list[str]
        :param cluster: Clusters is the cluster filter. 
        :type cluster: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[SharedFileIntegrityEvent], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'offset',
            'limit',
            'search',
            'sort',
            'reverse',
            'collections',
            'account_ids',
            'fields',
            '_from',
            'to',
            'hostname',
            'path',
            'event_type',
            'cluster'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_runtime_file_integrity_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'reverse' in local_var_params and local_var_params['reverse'] is not None:  # noqa: E501
            query_params.append(('reverse', local_var_params['reverse']))  # noqa: E501
        if 'collections' in local_var_params and local_var_params['collections'] is not None:  # noqa: E501
            query_params.append(('collections', local_var_params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'account_ids' in local_var_params and local_var_params['account_ids'] is not None:  # noqa: E501
            query_params.append(('accountIDs', local_var_params['account_ids']))  # noqa: E501
            collection_formats['accountIDs'] = 'multi'  # noqa: E501
        if 'fields' in local_var_params and local_var_params['fields'] is not None:  # noqa: E501
            query_params.append(('fields', local_var_params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if '_from' in local_var_params and local_var_params['_from'] is not None:  # noqa: E501
            query_params.append(('from', local_var_params['_from']))  # noqa: E501
        if 'to' in local_var_params and local_var_params['to'] is not None:  # noqa: E501
            query_params.append(('to', local_var_params['to']))  # noqa: E501
        if 'hostname' in local_var_params and local_var_params['hostname'] is not None:  # noqa: E501
            query_params.append(('hostname', local_var_params['hostname']))  # noqa: E501
            collection_formats['hostname'] = 'multi'  # noqa: E501
        if 'path' in local_var_params and local_var_params['path'] is not None:  # noqa: E501
            query_params.append(('path', local_var_params['path']))  # noqa: E501
            collection_formats['path'] = 'multi'  # noqa: E501
        if 'event_type' in local_var_params and local_var_params['event_type'] is not None:  # noqa: E501
            query_params.append(('eventType', local_var_params['event_type']))  # noqa: E501
            collection_formats['eventType'] = 'multi'  # noqa: E501
        if 'cluster' in local_var_params and local_var_params['cluster'] is not None:  # noqa: E501
            query_params.append(('cluster', local_var_params['cluster']))  # noqa: E501
            collection_formats['cluster'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "list[SharedFileIntegrityEvent]",
        }

        return self.api_client.call_api(
            '/api/v1/audits/runtime/file-integrity', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_runtime_host_download_get(self, **kwargs):  # noqa: E501
        """api_v1_audits_runtime_host_download_get  # noqa: E501

        DownloadHostRuntimeAudits downloads the host audits according to the specified query   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_runtime_host_download_get(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param profile_id: ProfileIDs are the profile IDs to filter. 
        :type profile_id: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param time: Time is used to filter by audit time. 
        :type time: datetime
        :param image_name: ImageNames is the image name filter. 
        :type image_name: list[str]
        :param container: Containers is the container name filter. 
        :type container: list[str]
        :param container_id: ContainerID is used to filter by container ID. 
        :type container_id: list[str]
        :param rule_name: RuleNames is used to filter by rule name. 
        :type rule_name: list[str]
        :param type: Types is used to filter by runtime audit type. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect (e.g., block/alert). 
        :type effect: list[str]
        :param user: Users is used to filter by host users. 
        :type user: list[str]
        :param os: OS is the image OS distro filter. 
        :type os: list[str]
        :param namespace: Namespaces is the namespaces filter. 
        :type namespace: list[str]
        :param cluster: Clusters is the cluster filter. 
        :type cluster: list[str]
        :param attack_type: AttackTypes is used to filter by runtime audit attack type. 
        :type attack_type: list[str]
        :param hostname: Hostname is the hostname filter. 
        :type hostname: list[str]
        :param msg: Message is the audit message text filter. 
        :type msg: list[str]
        :param interactive: Interactive is the audit interactive filter. 
        :type interactive: list[str]
        :param function: Function is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param app: App is the name constraint of the service that triggered the audit. 
        :type app: list[str]
        :param process_path: ProcessPath is the path constraint of the process that triggered the audit. 
        :type process_path: list[str]
        :param request_id: RequestID is used to filter by request ID. 
        :type request_id: list[str]
        :param function_id: FunctionID is used to filter by function ID. 
        :type function_id: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_runtime_host_download_get_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_runtime_host_download_get_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_runtime_host_download_get  # noqa: E501

        DownloadHostRuntimeAudits downloads the host audits according to the specified query   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_runtime_host_download_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param profile_id: ProfileIDs are the profile IDs to filter. 
        :type profile_id: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param time: Time is used to filter by audit time. 
        :type time: datetime
        :param image_name: ImageNames is the image name filter. 
        :type image_name: list[str]
        :param container: Containers is the container name filter. 
        :type container: list[str]
        :param container_id: ContainerID is used to filter by container ID. 
        :type container_id: list[str]
        :param rule_name: RuleNames is used to filter by rule name. 
        :type rule_name: list[str]
        :param type: Types is used to filter by runtime audit type. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect (e.g., block/alert). 
        :type effect: list[str]
        :param user: Users is used to filter by host users. 
        :type user: list[str]
        :param os: OS is the image OS distro filter. 
        :type os: list[str]
        :param namespace: Namespaces is the namespaces filter. 
        :type namespace: list[str]
        :param cluster: Clusters is the cluster filter. 
        :type cluster: list[str]
        :param attack_type: AttackTypes is used to filter by runtime audit attack type. 
        :type attack_type: list[str]
        :param hostname: Hostname is the hostname filter. 
        :type hostname: list[str]
        :param msg: Message is the audit message text filter. 
        :type msg: list[str]
        :param interactive: Interactive is the audit interactive filter. 
        :type interactive: list[str]
        :param function: Function is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param app: App is the name constraint of the service that triggered the audit. 
        :type app: list[str]
        :param process_path: ProcessPath is the path constraint of the process that triggered the audit. 
        :type process_path: list[str]
        :param request_id: RequestID is used to filter by request ID. 
        :type request_id: list[str]
        :param function_id: FunctionID is used to filter by function ID. 
        :type function_id: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'offset',
            'limit',
            'search',
            'sort',
            'reverse',
            'collections',
            'account_ids',
            'fields',
            'profile_id',
            '_from',
            'to',
            'time',
            'image_name',
            'container',
            'container_id',
            'rule_name',
            'type',
            'effect',
            'user',
            'os',
            'namespace',
            'cluster',
            'attack_type',
            'hostname',
            'msg',
            'interactive',
            'function',
            'region',
            'runtime',
            'attack_techniques',
            'app',
            'process_path',
            'request_id',
            'function_id',
            'aggregate'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_runtime_host_download_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'reverse' in local_var_params and local_var_params['reverse'] is not None:  # noqa: E501
            query_params.append(('reverse', local_var_params['reverse']))  # noqa: E501
        if 'collections' in local_var_params and local_var_params['collections'] is not None:  # noqa: E501
            query_params.append(('collections', local_var_params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'account_ids' in local_var_params and local_var_params['account_ids'] is not None:  # noqa: E501
            query_params.append(('accountIDs', local_var_params['account_ids']))  # noqa: E501
            collection_formats['accountIDs'] = 'multi'  # noqa: E501
        if 'fields' in local_var_params and local_var_params['fields'] is not None:  # noqa: E501
            query_params.append(('fields', local_var_params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if 'profile_id' in local_var_params and local_var_params['profile_id'] is not None:  # noqa: E501
            query_params.append(('profileID', local_var_params['profile_id']))  # noqa: E501
            collection_formats['profileID'] = 'multi'  # noqa: E501
        if '_from' in local_var_params and local_var_params['_from'] is not None:  # noqa: E501
            query_params.append(('from', local_var_params['_from']))  # noqa: E501
        if 'to' in local_var_params and local_var_params['to'] is not None:  # noqa: E501
            query_params.append(('to', local_var_params['to']))  # noqa: E501
        if 'time' in local_var_params and local_var_params['time'] is not None:  # noqa: E501
            query_params.append(('time', local_var_params['time']))  # noqa: E501
        if 'image_name' in local_var_params and local_var_params['image_name'] is not None:  # noqa: E501
            query_params.append(('imageName', local_var_params['image_name']))  # noqa: E501
            collection_formats['imageName'] = 'multi'  # noqa: E501
        if 'container' in local_var_params and local_var_params['container'] is not None:  # noqa: E501
            query_params.append(('container', local_var_params['container']))  # noqa: E501
            collection_formats['container'] = 'multi'  # noqa: E501
        if 'container_id' in local_var_params and local_var_params['container_id'] is not None:  # noqa: E501
            query_params.append(('containerID', local_var_params['container_id']))  # noqa: E501
            collection_formats['containerID'] = 'multi'  # noqa: E501
        if 'rule_name' in local_var_params and local_var_params['rule_name'] is not None:  # noqa: E501
            query_params.append(('ruleName', local_var_params['rule_name']))  # noqa: E501
            collection_formats['ruleName'] = 'multi'  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
            collection_formats['type'] = 'multi'  # noqa: E501
        if 'effect' in local_var_params and local_var_params['effect'] is not None:  # noqa: E501
            query_params.append(('effect', local_var_params['effect']))  # noqa: E501
            collection_formats['effect'] = 'multi'  # noqa: E501
        if 'user' in local_var_params and local_var_params['user'] is not None:  # noqa: E501
            query_params.append(('user', local_var_params['user']))  # noqa: E501
            collection_formats['user'] = 'multi'  # noqa: E501
        if 'os' in local_var_params and local_var_params['os'] is not None:  # noqa: E501
            query_params.append(('os', local_var_params['os']))  # noqa: E501
            collection_formats['os'] = 'multi'  # noqa: E501
        if 'namespace' in local_var_params and local_var_params['namespace'] is not None:  # noqa: E501
            query_params.append(('namespace', local_var_params['namespace']))  # noqa: E501
            collection_formats['namespace'] = 'multi'  # noqa: E501
        if 'cluster' in local_var_params and local_var_params['cluster'] is not None:  # noqa: E501
            query_params.append(('cluster', local_var_params['cluster']))  # noqa: E501
            collection_formats['cluster'] = 'multi'  # noqa: E501
        if 'attack_type' in local_var_params and local_var_params['attack_type'] is not None:  # noqa: E501
            query_params.append(('attackType', local_var_params['attack_type']))  # noqa: E501
            collection_formats['attackType'] = 'multi'  # noqa: E501
        if 'hostname' in local_var_params and local_var_params['hostname'] is not None:  # noqa: E501
            query_params.append(('hostname', local_var_params['hostname']))  # noqa: E501
            collection_formats['hostname'] = 'multi'  # noqa: E501
        if 'msg' in local_var_params and local_var_params['msg'] is not None:  # noqa: E501
            query_params.append(('msg', local_var_params['msg']))  # noqa: E501
            collection_formats['msg'] = 'multi'  # noqa: E501
        if 'interactive' in local_var_params and local_var_params['interactive'] is not None:  # noqa: E501
            query_params.append(('interactive', local_var_params['interactive']))  # noqa: E501
            collection_formats['interactive'] = 'multi'  # noqa: E501
        if 'function' in local_var_params and local_var_params['function'] is not None:  # noqa: E501
            query_params.append(('function', local_var_params['function']))  # noqa: E501
            collection_formats['function'] = 'multi'  # noqa: E501
        if 'region' in local_var_params and local_var_params['region'] is not None:  # noqa: E501
            query_params.append(('region', local_var_params['region']))  # noqa: E501
            collection_formats['region'] = 'multi'  # noqa: E501
        if 'runtime' in local_var_params and local_var_params['runtime'] is not None:  # noqa: E501
            query_params.append(('runtime', local_var_params['runtime']))  # noqa: E501
            collection_formats['runtime'] = 'multi'  # noqa: E501
        if 'attack_techniques' in local_var_params and local_var_params['attack_techniques'] is not None:  # noqa: E501
            query_params.append(('attackTechniques', local_var_params['attack_techniques']))  # noqa: E501
            collection_formats['attackTechniques'] = 'multi'  # noqa: E501
        if 'app' in local_var_params and local_var_params['app'] is not None:  # noqa: E501
            query_params.append(('app', local_var_params['app']))  # noqa: E501
            collection_formats['app'] = 'multi'  # noqa: E501
        if 'process_path' in local_var_params and local_var_params['process_path'] is not None:  # noqa: E501
            query_params.append(('processPath', local_var_params['process_path']))  # noqa: E501
            collection_formats['processPath'] = 'multi'  # noqa: E501
        if 'request_id' in local_var_params and local_var_params['request_id'] is not None:  # noqa: E501
            query_params.append(('requestID', local_var_params['request_id']))  # noqa: E501
            collection_formats['requestID'] = 'multi'  # noqa: E501
        if 'function_id' in local_var_params and local_var_params['function_id'] is not None:  # noqa: E501
            query_params.append(('functionID', local_var_params['function_id']))  # noqa: E501
            collection_formats['functionID'] = 'multi'  # noqa: E501
        if 'aggregate' in local_var_params and local_var_params['aggregate'] is not None:  # noqa: E501
            query_params.append(('aggregate', local_var_params['aggregate']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/audits/runtime/host/download', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_runtime_host_get(self, **kwargs):  # noqa: E501
        """api_v1_audits_runtime_host_get  # noqa: E501

        HostRuntimeAudits returns all host audits according to the matched profile and query specification   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_runtime_host_get(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param profile_id: ProfileIDs are the profile IDs to filter. 
        :type profile_id: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param time: Time is used to filter by audit time. 
        :type time: datetime
        :param image_name: ImageNames is the image name filter. 
        :type image_name: list[str]
        :param container: Containers is the container name filter. 
        :type container: list[str]
        :param container_id: ContainerID is used to filter by container ID. 
        :type container_id: list[str]
        :param rule_name: RuleNames is used to filter by rule name. 
        :type rule_name: list[str]
        :param type: Types is used to filter by runtime audit type. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect (e.g., block/alert). 
        :type effect: list[str]
        :param user: Users is used to filter by host users. 
        :type user: list[str]
        :param os: OS is the image OS distro filter. 
        :type os: list[str]
        :param namespace: Namespaces is the namespaces filter. 
        :type namespace: list[str]
        :param cluster: Clusters is the cluster filter. 
        :type cluster: list[str]
        :param attack_type: AttackTypes is used to filter by runtime audit attack type. 
        :type attack_type: list[str]
        :param hostname: Hostname is the hostname filter. 
        :type hostname: list[str]
        :param msg: Message is the audit message text filter. 
        :type msg: list[str]
        :param interactive: Interactive is the audit interactive filter. 
        :type interactive: list[str]
        :param function: Function is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param app: App is the name constraint of the service that triggered the audit. 
        :type app: list[str]
        :param process_path: ProcessPath is the path constraint of the process that triggered the audit. 
        :type process_path: list[str]
        :param request_id: RequestID is used to filter by request ID. 
        :type request_id: list[str]
        :param function_id: FunctionID is used to filter by function ID. 
        :type function_id: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[SharedRuntimeAudit]
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_runtime_host_get_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_runtime_host_get_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_runtime_host_get  # noqa: E501

        HostRuntimeAudits returns all host audits according to the matched profile and query specification   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_runtime_host_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param profile_id: ProfileIDs are the profile IDs to filter. 
        :type profile_id: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param time: Time is used to filter by audit time. 
        :type time: datetime
        :param image_name: ImageNames is the image name filter. 
        :type image_name: list[str]
        :param container: Containers is the container name filter. 
        :type container: list[str]
        :param container_id: ContainerID is used to filter by container ID. 
        :type container_id: list[str]
        :param rule_name: RuleNames is used to filter by rule name. 
        :type rule_name: list[str]
        :param type: Types is used to filter by runtime audit type. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect (e.g., block/alert). 
        :type effect: list[str]
        :param user: Users is used to filter by host users. 
        :type user: list[str]
        :param os: OS is the image OS distro filter. 
        :type os: list[str]
        :param namespace: Namespaces is the namespaces filter. 
        :type namespace: list[str]
        :param cluster: Clusters is the cluster filter. 
        :type cluster: list[str]
        :param attack_type: AttackTypes is used to filter by runtime audit attack type. 
        :type attack_type: list[str]
        :param hostname: Hostname is the hostname filter. 
        :type hostname: list[str]
        :param msg: Message is the audit message text filter. 
        :type msg: list[str]
        :param interactive: Interactive is the audit interactive filter. 
        :type interactive: list[str]
        :param function: Function is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param app: App is the name constraint of the service that triggered the audit. 
        :type app: list[str]
        :param process_path: ProcessPath is the path constraint of the process that triggered the audit. 
        :type process_path: list[str]
        :param request_id: RequestID is used to filter by request ID. 
        :type request_id: list[str]
        :param function_id: FunctionID is used to filter by function ID. 
        :type function_id: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[SharedRuntimeAudit], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'offset',
            'limit',
            'search',
            'sort',
            'reverse',
            'collections',
            'account_ids',
            'fields',
            'profile_id',
            '_from',
            'to',
            'time',
            'image_name',
            'container',
            'container_id',
            'rule_name',
            'type',
            'effect',
            'user',
            'os',
            'namespace',
            'cluster',
            'attack_type',
            'hostname',
            'msg',
            'interactive',
            'function',
            'region',
            'runtime',
            'attack_techniques',
            'app',
            'process_path',
            'request_id',
            'function_id',
            'aggregate'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_runtime_host_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'reverse' in local_var_params and local_var_params['reverse'] is not None:  # noqa: E501
            query_params.append(('reverse', local_var_params['reverse']))  # noqa: E501
        if 'collections' in local_var_params and local_var_params['collections'] is not None:  # noqa: E501
            query_params.append(('collections', local_var_params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'account_ids' in local_var_params and local_var_params['account_ids'] is not None:  # noqa: E501
            query_params.append(('accountIDs', local_var_params['account_ids']))  # noqa: E501
            collection_formats['accountIDs'] = 'multi'  # noqa: E501
        if 'fields' in local_var_params and local_var_params['fields'] is not None:  # noqa: E501
            query_params.append(('fields', local_var_params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if 'profile_id' in local_var_params and local_var_params['profile_id'] is not None:  # noqa: E501
            query_params.append(('profileID', local_var_params['profile_id']))  # noqa: E501
            collection_formats['profileID'] = 'multi'  # noqa: E501
        if '_from' in local_var_params and local_var_params['_from'] is not None:  # noqa: E501
            query_params.append(('from', local_var_params['_from']))  # noqa: E501
        if 'to' in local_var_params and local_var_params['to'] is not None:  # noqa: E501
            query_params.append(('to', local_var_params['to']))  # noqa: E501
        if 'time' in local_var_params and local_var_params['time'] is not None:  # noqa: E501
            query_params.append(('time', local_var_params['time']))  # noqa: E501
        if 'image_name' in local_var_params and local_var_params['image_name'] is not None:  # noqa: E501
            query_params.append(('imageName', local_var_params['image_name']))  # noqa: E501
            collection_formats['imageName'] = 'multi'  # noqa: E501
        if 'container' in local_var_params and local_var_params['container'] is not None:  # noqa: E501
            query_params.append(('container', local_var_params['container']))  # noqa: E501
            collection_formats['container'] = 'multi'  # noqa: E501
        if 'container_id' in local_var_params and local_var_params['container_id'] is not None:  # noqa: E501
            query_params.append(('containerID', local_var_params['container_id']))  # noqa: E501
            collection_formats['containerID'] = 'multi'  # noqa: E501
        if 'rule_name' in local_var_params and local_var_params['rule_name'] is not None:  # noqa: E501
            query_params.append(('ruleName', local_var_params['rule_name']))  # noqa: E501
            collection_formats['ruleName'] = 'multi'  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
            collection_formats['type'] = 'multi'  # noqa: E501
        if 'effect' in local_var_params and local_var_params['effect'] is not None:  # noqa: E501
            query_params.append(('effect', local_var_params['effect']))  # noqa: E501
            collection_formats['effect'] = 'multi'  # noqa: E501
        if 'user' in local_var_params and local_var_params['user'] is not None:  # noqa: E501
            query_params.append(('user', local_var_params['user']))  # noqa: E501
            collection_formats['user'] = 'multi'  # noqa: E501
        if 'os' in local_var_params and local_var_params['os'] is not None:  # noqa: E501
            query_params.append(('os', local_var_params['os']))  # noqa: E501
            collection_formats['os'] = 'multi'  # noqa: E501
        if 'namespace' in local_var_params and local_var_params['namespace'] is not None:  # noqa: E501
            query_params.append(('namespace', local_var_params['namespace']))  # noqa: E501
            collection_formats['namespace'] = 'multi'  # noqa: E501
        if 'cluster' in local_var_params and local_var_params['cluster'] is not None:  # noqa: E501
            query_params.append(('cluster', local_var_params['cluster']))  # noqa: E501
            collection_formats['cluster'] = 'multi'  # noqa: E501
        if 'attack_type' in local_var_params and local_var_params['attack_type'] is not None:  # noqa: E501
            query_params.append(('attackType', local_var_params['attack_type']))  # noqa: E501
            collection_formats['attackType'] = 'multi'  # noqa: E501
        if 'hostname' in local_var_params and local_var_params['hostname'] is not None:  # noqa: E501
            query_params.append(('hostname', local_var_params['hostname']))  # noqa: E501
            collection_formats['hostname'] = 'multi'  # noqa: E501
        if 'msg' in local_var_params and local_var_params['msg'] is not None:  # noqa: E501
            query_params.append(('msg', local_var_params['msg']))  # noqa: E501
            collection_formats['msg'] = 'multi'  # noqa: E501
        if 'interactive' in local_var_params and local_var_params['interactive'] is not None:  # noqa: E501
            query_params.append(('interactive', local_var_params['interactive']))  # noqa: E501
            collection_formats['interactive'] = 'multi'  # noqa: E501
        if 'function' in local_var_params and local_var_params['function'] is not None:  # noqa: E501
            query_params.append(('function', local_var_params['function']))  # noqa: E501
            collection_formats['function'] = 'multi'  # noqa: E501
        if 'region' in local_var_params and local_var_params['region'] is not None:  # noqa: E501
            query_params.append(('region', local_var_params['region']))  # noqa: E501
            collection_formats['region'] = 'multi'  # noqa: E501
        if 'runtime' in local_var_params and local_var_params['runtime'] is not None:  # noqa: E501
            query_params.append(('runtime', local_var_params['runtime']))  # noqa: E501
            collection_formats['runtime'] = 'multi'  # noqa: E501
        if 'attack_techniques' in local_var_params and local_var_params['attack_techniques'] is not None:  # noqa: E501
            query_params.append(('attackTechniques', local_var_params['attack_techniques']))  # noqa: E501
            collection_formats['attackTechniques'] = 'multi'  # noqa: E501
        if 'app' in local_var_params and local_var_params['app'] is not None:  # noqa: E501
            query_params.append(('app', local_var_params['app']))  # noqa: E501
            collection_formats['app'] = 'multi'  # noqa: E501
        if 'process_path' in local_var_params and local_var_params['process_path'] is not None:  # noqa: E501
            query_params.append(('processPath', local_var_params['process_path']))  # noqa: E501
            collection_formats['processPath'] = 'multi'  # noqa: E501
        if 'request_id' in local_var_params and local_var_params['request_id'] is not None:  # noqa: E501
            query_params.append(('requestID', local_var_params['request_id']))  # noqa: E501
            collection_formats['requestID'] = 'multi'  # noqa: E501
        if 'function_id' in local_var_params and local_var_params['function_id'] is not None:  # noqa: E501
            query_params.append(('functionID', local_var_params['function_id']))  # noqa: E501
            collection_formats['functionID'] = 'multi'  # noqa: E501
        if 'aggregate' in local_var_params and local_var_params['aggregate'] is not None:  # noqa: E501
            query_params.append(('aggregate', local_var_params['aggregate']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "list[SharedRuntimeAudit]",
        }

        return self.api_client.call_api(
            '/api/v1/audits/runtime/host', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_runtime_host_timeslice_get(self, **kwargs):  # noqa: E501
        """api_v1_audits_runtime_host_timeslice_get  # noqa: E501

        HostRuntimeAuditsTimeslice returns host runtime audit buckets according to the query timeframe   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_runtime_host_timeslice_get(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param profile_id: ProfileIDs are the profile IDs to filter. 
        :type profile_id: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param time: Time is used to filter by audit time. 
        :type time: datetime
        :param image_name: ImageNames is the image name filter. 
        :type image_name: list[str]
        :param container: Containers is the container name filter. 
        :type container: list[str]
        :param container_id: ContainerID is used to filter by container ID. 
        :type container_id: list[str]
        :param rule_name: RuleNames is used to filter by rule name. 
        :type rule_name: list[str]
        :param type: Types is used to filter by runtime audit type. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect (e.g., block/alert). 
        :type effect: list[str]
        :param user: Users is used to filter by host users. 
        :type user: list[str]
        :param os: OS is the image OS distro filter. 
        :type os: list[str]
        :param namespace: Namespaces is the namespaces filter. 
        :type namespace: list[str]
        :param cluster: Clusters is the cluster filter. 
        :type cluster: list[str]
        :param attack_type: AttackTypes is used to filter by runtime audit attack type. 
        :type attack_type: list[str]
        :param hostname: Hostname is the hostname filter. 
        :type hostname: list[str]
        :param msg: Message is the audit message text filter. 
        :type msg: list[str]
        :param interactive: Interactive is the audit interactive filter. 
        :type interactive: list[str]
        :param function: Function is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param app: App is the name constraint of the service that triggered the audit. 
        :type app: list[str]
        :param process_path: ProcessPath is the path constraint of the process that triggered the audit. 
        :type process_path: list[str]
        :param request_id: RequestID is used to filter by request ID. 
        :type request_id: list[str]
        :param function_id: FunctionID is used to filter by function ID. 
        :type function_id: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param buckets: Buckets is the number of buckets to return. 
        :type buckets: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[TypesAuditTimeslice]
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_runtime_host_timeslice_get_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_runtime_host_timeslice_get_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_runtime_host_timeslice_get  # noqa: E501

        HostRuntimeAuditsTimeslice returns host runtime audit buckets according to the query timeframe   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_runtime_host_timeslice_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param profile_id: ProfileIDs are the profile IDs to filter. 
        :type profile_id: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param time: Time is used to filter by audit time. 
        :type time: datetime
        :param image_name: ImageNames is the image name filter. 
        :type image_name: list[str]
        :param container: Containers is the container name filter. 
        :type container: list[str]
        :param container_id: ContainerID is used to filter by container ID. 
        :type container_id: list[str]
        :param rule_name: RuleNames is used to filter by rule name. 
        :type rule_name: list[str]
        :param type: Types is used to filter by runtime audit type. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect (e.g., block/alert). 
        :type effect: list[str]
        :param user: Users is used to filter by host users. 
        :type user: list[str]
        :param os: OS is the image OS distro filter. 
        :type os: list[str]
        :param namespace: Namespaces is the namespaces filter. 
        :type namespace: list[str]
        :param cluster: Clusters is the cluster filter. 
        :type cluster: list[str]
        :param attack_type: AttackTypes is used to filter by runtime audit attack type. 
        :type attack_type: list[str]
        :param hostname: Hostname is the hostname filter. 
        :type hostname: list[str]
        :param msg: Message is the audit message text filter. 
        :type msg: list[str]
        :param interactive: Interactive is the audit interactive filter. 
        :type interactive: list[str]
        :param function: Function is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param app: App is the name constraint of the service that triggered the audit. 
        :type app: list[str]
        :param process_path: ProcessPath is the path constraint of the process that triggered the audit. 
        :type process_path: list[str]
        :param request_id: RequestID is used to filter by request ID. 
        :type request_id: list[str]
        :param function_id: FunctionID is used to filter by function ID. 
        :type function_id: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param buckets: Buckets is the number of buckets to return. 
        :type buckets: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[TypesAuditTimeslice], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'offset',
            'limit',
            'search',
            'sort',
            'reverse',
            'collections',
            'account_ids',
            'fields',
            'profile_id',
            '_from',
            'to',
            'time',
            'image_name',
            'container',
            'container_id',
            'rule_name',
            'type',
            'effect',
            'user',
            'os',
            'namespace',
            'cluster',
            'attack_type',
            'hostname',
            'msg',
            'interactive',
            'function',
            'region',
            'runtime',
            'attack_techniques',
            'app',
            'process_path',
            'request_id',
            'function_id',
            'aggregate',
            'buckets'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_runtime_host_timeslice_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'reverse' in local_var_params and local_var_params['reverse'] is not None:  # noqa: E501
            query_params.append(('reverse', local_var_params['reverse']))  # noqa: E501
        if 'collections' in local_var_params and local_var_params['collections'] is not None:  # noqa: E501
            query_params.append(('collections', local_var_params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'account_ids' in local_var_params and local_var_params['account_ids'] is not None:  # noqa: E501
            query_params.append(('accountIDs', local_var_params['account_ids']))  # noqa: E501
            collection_formats['accountIDs'] = 'multi'  # noqa: E501
        if 'fields' in local_var_params and local_var_params['fields'] is not None:  # noqa: E501
            query_params.append(('fields', local_var_params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if 'profile_id' in local_var_params and local_var_params['profile_id'] is not None:  # noqa: E501
            query_params.append(('profileID', local_var_params['profile_id']))  # noqa: E501
            collection_formats['profileID'] = 'multi'  # noqa: E501
        if '_from' in local_var_params and local_var_params['_from'] is not None:  # noqa: E501
            query_params.append(('from', local_var_params['_from']))  # noqa: E501
        if 'to' in local_var_params and local_var_params['to'] is not None:  # noqa: E501
            query_params.append(('to', local_var_params['to']))  # noqa: E501
        if 'time' in local_var_params and local_var_params['time'] is not None:  # noqa: E501
            query_params.append(('time', local_var_params['time']))  # noqa: E501
        if 'image_name' in local_var_params and local_var_params['image_name'] is not None:  # noqa: E501
            query_params.append(('imageName', local_var_params['image_name']))  # noqa: E501
            collection_formats['imageName'] = 'multi'  # noqa: E501
        if 'container' in local_var_params and local_var_params['container'] is not None:  # noqa: E501
            query_params.append(('container', local_var_params['container']))  # noqa: E501
            collection_formats['container'] = 'multi'  # noqa: E501
        if 'container_id' in local_var_params and local_var_params['container_id'] is not None:  # noqa: E501
            query_params.append(('containerID', local_var_params['container_id']))  # noqa: E501
            collection_formats['containerID'] = 'multi'  # noqa: E501
        if 'rule_name' in local_var_params and local_var_params['rule_name'] is not None:  # noqa: E501
            query_params.append(('ruleName', local_var_params['rule_name']))  # noqa: E501
            collection_formats['ruleName'] = 'multi'  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
            collection_formats['type'] = 'multi'  # noqa: E501
        if 'effect' in local_var_params and local_var_params['effect'] is not None:  # noqa: E501
            query_params.append(('effect', local_var_params['effect']))  # noqa: E501
            collection_formats['effect'] = 'multi'  # noqa: E501
        if 'user' in local_var_params and local_var_params['user'] is not None:  # noqa: E501
            query_params.append(('user', local_var_params['user']))  # noqa: E501
            collection_formats['user'] = 'multi'  # noqa: E501
        if 'os' in local_var_params and local_var_params['os'] is not None:  # noqa: E501
            query_params.append(('os', local_var_params['os']))  # noqa: E501
            collection_formats['os'] = 'multi'  # noqa: E501
        if 'namespace' in local_var_params and local_var_params['namespace'] is not None:  # noqa: E501
            query_params.append(('namespace', local_var_params['namespace']))  # noqa: E501
            collection_formats['namespace'] = 'multi'  # noqa: E501
        if 'cluster' in local_var_params and local_var_params['cluster'] is not None:  # noqa: E501
            query_params.append(('cluster', local_var_params['cluster']))  # noqa: E501
            collection_formats['cluster'] = 'multi'  # noqa: E501
        if 'attack_type' in local_var_params and local_var_params['attack_type'] is not None:  # noqa: E501
            query_params.append(('attackType', local_var_params['attack_type']))  # noqa: E501
            collection_formats['attackType'] = 'multi'  # noqa: E501
        if 'hostname' in local_var_params and local_var_params['hostname'] is not None:  # noqa: E501
            query_params.append(('hostname', local_var_params['hostname']))  # noqa: E501
            collection_formats['hostname'] = 'multi'  # noqa: E501
        if 'msg' in local_var_params and local_var_params['msg'] is not None:  # noqa: E501
            query_params.append(('msg', local_var_params['msg']))  # noqa: E501
            collection_formats['msg'] = 'multi'  # noqa: E501
        if 'interactive' in local_var_params and local_var_params['interactive'] is not None:  # noqa: E501
            query_params.append(('interactive', local_var_params['interactive']))  # noqa: E501
            collection_formats['interactive'] = 'multi'  # noqa: E501
        if 'function' in local_var_params and local_var_params['function'] is not None:  # noqa: E501
            query_params.append(('function', local_var_params['function']))  # noqa: E501
            collection_formats['function'] = 'multi'  # noqa: E501
        if 'region' in local_var_params and local_var_params['region'] is not None:  # noqa: E501
            query_params.append(('region', local_var_params['region']))  # noqa: E501
            collection_formats['region'] = 'multi'  # noqa: E501
        if 'runtime' in local_var_params and local_var_params['runtime'] is not None:  # noqa: E501
            query_params.append(('runtime', local_var_params['runtime']))  # noqa: E501
            collection_formats['runtime'] = 'multi'  # noqa: E501
        if 'attack_techniques' in local_var_params and local_var_params['attack_techniques'] is not None:  # noqa: E501
            query_params.append(('attackTechniques', local_var_params['attack_techniques']))  # noqa: E501
            collection_formats['attackTechniques'] = 'multi'  # noqa: E501
        if 'app' in local_var_params and local_var_params['app'] is not None:  # noqa: E501
            query_params.append(('app', local_var_params['app']))  # noqa: E501
            collection_formats['app'] = 'multi'  # noqa: E501
        if 'process_path' in local_var_params and local_var_params['process_path'] is not None:  # noqa: E501
            query_params.append(('processPath', local_var_params['process_path']))  # noqa: E501
            collection_formats['processPath'] = 'multi'  # noqa: E501
        if 'request_id' in local_var_params and local_var_params['request_id'] is not None:  # noqa: E501
            query_params.append(('requestID', local_var_params['request_id']))  # noqa: E501
            collection_formats['requestID'] = 'multi'  # noqa: E501
        if 'function_id' in local_var_params and local_var_params['function_id'] is not None:  # noqa: E501
            query_params.append(('functionID', local_var_params['function_id']))  # noqa: E501
            collection_formats['functionID'] = 'multi'  # noqa: E501
        if 'aggregate' in local_var_params and local_var_params['aggregate'] is not None:  # noqa: E501
            query_params.append(('aggregate', local_var_params['aggregate']))  # noqa: E501
        if 'buckets' in local_var_params and local_var_params['buckets'] is not None:  # noqa: E501
            query_params.append(('buckets', local_var_params['buckets']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "list[TypesAuditTimeslice]",
        }

        return self.api_client.call_api(
            '/api/v1/audits/runtime/host/timeslice', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_runtime_log_inspection_download_get(self, **kwargs):  # noqa: E501
        """api_v1_audits_runtime_log_inspection_download_get  # noqa: E501

        DownloadLogInspectionEvents downloads the log inspection events according to the specified query   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_runtime_log_inspection_download_get(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the event. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the event. 
        :type to: datetime
        :param hostname: Hosts is the list of hosts to use for filtering. 
        :type hostname: list[str]
        :param logfile: Logfiles is the list of log files to use for filtering. 
        :type logfile: list[str]
        :param cluster: Clusters is the cluster filter. 
        :type cluster: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_runtime_log_inspection_download_get_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_runtime_log_inspection_download_get_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_runtime_log_inspection_download_get  # noqa: E501

        DownloadLogInspectionEvents downloads the log inspection events according to the specified query   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_runtime_log_inspection_download_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the event. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the event. 
        :type to: datetime
        :param hostname: Hosts is the list of hosts to use for filtering. 
        :type hostname: list[str]
        :param logfile: Logfiles is the list of log files to use for filtering. 
        :type logfile: list[str]
        :param cluster: Clusters is the cluster filter. 
        :type cluster: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'offset',
            'limit',
            'search',
            'sort',
            'reverse',
            'collections',
            'account_ids',
            'fields',
            '_from',
            'to',
            'hostname',
            'logfile',
            'cluster'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_runtime_log_inspection_download_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'reverse' in local_var_params and local_var_params['reverse'] is not None:  # noqa: E501
            query_params.append(('reverse', local_var_params['reverse']))  # noqa: E501
        if 'collections' in local_var_params and local_var_params['collections'] is not None:  # noqa: E501
            query_params.append(('collections', local_var_params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'account_ids' in local_var_params and local_var_params['account_ids'] is not None:  # noqa: E501
            query_params.append(('accountIDs', local_var_params['account_ids']))  # noqa: E501
            collection_formats['accountIDs'] = 'multi'  # noqa: E501
        if 'fields' in local_var_params and local_var_params['fields'] is not None:  # noqa: E501
            query_params.append(('fields', local_var_params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if '_from' in local_var_params and local_var_params['_from'] is not None:  # noqa: E501
            query_params.append(('from', local_var_params['_from']))  # noqa: E501
        if 'to' in local_var_params and local_var_params['to'] is not None:  # noqa: E501
            query_params.append(('to', local_var_params['to']))  # noqa: E501
        if 'hostname' in local_var_params and local_var_params['hostname'] is not None:  # noqa: E501
            query_params.append(('hostname', local_var_params['hostname']))  # noqa: E501
            collection_formats['hostname'] = 'multi'  # noqa: E501
        if 'logfile' in local_var_params and local_var_params['logfile'] is not None:  # noqa: E501
            query_params.append(('logfile', local_var_params['logfile']))  # noqa: E501
            collection_formats['logfile'] = 'multi'  # noqa: E501
        if 'cluster' in local_var_params and local_var_params['cluster'] is not None:  # noqa: E501
            query_params.append(('cluster', local_var_params['cluster']))  # noqa: E501
            collection_formats['cluster'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/audits/runtime/log-inspection/download', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_runtime_log_inspection_get(self, **kwargs):  # noqa: E501
        """api_v1_audits_runtime_log_inspection_get  # noqa: E501

        LogInspectionEvents returns the log inspection events   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_runtime_log_inspection_get(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the event. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the event. 
        :type to: datetime
        :param hostname: Hosts is the list of hosts to use for filtering. 
        :type hostname: list[str]
        :param logfile: Logfiles is the list of log files to use for filtering. 
        :type logfile: list[str]
        :param cluster: Clusters is the cluster filter. 
        :type cluster: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[SharedLogInspectionEvent]
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_runtime_log_inspection_get_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_runtime_log_inspection_get_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_runtime_log_inspection_get  # noqa: E501

        LogInspectionEvents returns the log inspection events   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_runtime_log_inspection_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the event. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the event. 
        :type to: datetime
        :param hostname: Hosts is the list of hosts to use for filtering. 
        :type hostname: list[str]
        :param logfile: Logfiles is the list of log files to use for filtering. 
        :type logfile: list[str]
        :param cluster: Clusters is the cluster filter. 
        :type cluster: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[SharedLogInspectionEvent], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'offset',
            'limit',
            'search',
            'sort',
            'reverse',
            'collections',
            'account_ids',
            'fields',
            '_from',
            'to',
            'hostname',
            'logfile',
            'cluster'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_runtime_log_inspection_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'reverse' in local_var_params and local_var_params['reverse'] is not None:  # noqa: E501
            query_params.append(('reverse', local_var_params['reverse']))  # noqa: E501
        if 'collections' in local_var_params and local_var_params['collections'] is not None:  # noqa: E501
            query_params.append(('collections', local_var_params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'account_ids' in local_var_params and local_var_params['account_ids'] is not None:  # noqa: E501
            query_params.append(('accountIDs', local_var_params['account_ids']))  # noqa: E501
            collection_formats['accountIDs'] = 'multi'  # noqa: E501
        if 'fields' in local_var_params and local_var_params['fields'] is not None:  # noqa: E501
            query_params.append(('fields', local_var_params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if '_from' in local_var_params and local_var_params['_from'] is not None:  # noqa: E501
            query_params.append(('from', local_var_params['_from']))  # noqa: E501
        if 'to' in local_var_params and local_var_params['to'] is not None:  # noqa: E501
            query_params.append(('to', local_var_params['to']))  # noqa: E501
        if 'hostname' in local_var_params and local_var_params['hostname'] is not None:  # noqa: E501
            query_params.append(('hostname', local_var_params['hostname']))  # noqa: E501
            collection_formats['hostname'] = 'multi'  # noqa: E501
        if 'logfile' in local_var_params and local_var_params['logfile'] is not None:  # noqa: E501
            query_params.append(('logfile', local_var_params['logfile']))  # noqa: E501
            collection_formats['logfile'] = 'multi'  # noqa: E501
        if 'cluster' in local_var_params and local_var_params['cluster'] is not None:  # noqa: E501
            query_params.append(('cluster', local_var_params['cluster']))  # noqa: E501
            collection_formats['cluster'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "list[SharedLogInspectionEvent]",
        }

        return self.api_client.call_api(
            '/api/v1/audits/runtime/log-inspection', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_runtime_serverless_download_get(self, **kwargs):  # noqa: E501
        """api_v1_audits_runtime_serverless_download_get  # noqa: E501

        DownloadServerlessRuntimeAudits downloads the serverless audits according to the specified query   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_runtime_serverless_download_get(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param profile_id: ProfileIDs are the profile IDs to filter. 
        :type profile_id: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param time: Time is used to filter by audit time. 
        :type time: datetime
        :param image_name: ImageNames is the image name filter. 
        :type image_name: list[str]
        :param container: Containers is the container name filter. 
        :type container: list[str]
        :param container_id: ContainerID is used to filter by container ID. 
        :type container_id: list[str]
        :param rule_name: RuleNames is used to filter by rule name. 
        :type rule_name: list[str]
        :param type: Types is used to filter by runtime audit type. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect (e.g., block/alert). 
        :type effect: list[str]
        :param user: Users is used to filter by host users. 
        :type user: list[str]
        :param os: OS is the image OS distro filter. 
        :type os: list[str]
        :param namespace: Namespaces is the namespaces filter. 
        :type namespace: list[str]
        :param cluster: Clusters is the cluster filter. 
        :type cluster: list[str]
        :param attack_type: AttackTypes is used to filter by runtime audit attack type. 
        :type attack_type: list[str]
        :param hostname: Hostname is the hostname filter. 
        :type hostname: list[str]
        :param msg: Message is the audit message text filter. 
        :type msg: list[str]
        :param interactive: Interactive is the audit interactive filter. 
        :type interactive: list[str]
        :param function: Function is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param app: App is the name constraint of the service that triggered the audit. 
        :type app: list[str]
        :param process_path: ProcessPath is the path constraint of the process that triggered the audit. 
        :type process_path: list[str]
        :param request_id: RequestID is used to filter by request ID. 
        :type request_id: list[str]
        :param function_id: FunctionID is used to filter by function ID. 
        :type function_id: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_runtime_serverless_download_get_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_runtime_serverless_download_get_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_runtime_serverless_download_get  # noqa: E501

        DownloadServerlessRuntimeAudits downloads the serverless audits according to the specified query   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_runtime_serverless_download_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param profile_id: ProfileIDs are the profile IDs to filter. 
        :type profile_id: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param time: Time is used to filter by audit time. 
        :type time: datetime
        :param image_name: ImageNames is the image name filter. 
        :type image_name: list[str]
        :param container: Containers is the container name filter. 
        :type container: list[str]
        :param container_id: ContainerID is used to filter by container ID. 
        :type container_id: list[str]
        :param rule_name: RuleNames is used to filter by rule name. 
        :type rule_name: list[str]
        :param type: Types is used to filter by runtime audit type. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect (e.g., block/alert). 
        :type effect: list[str]
        :param user: Users is used to filter by host users. 
        :type user: list[str]
        :param os: OS is the image OS distro filter. 
        :type os: list[str]
        :param namespace: Namespaces is the namespaces filter. 
        :type namespace: list[str]
        :param cluster: Clusters is the cluster filter. 
        :type cluster: list[str]
        :param attack_type: AttackTypes is used to filter by runtime audit attack type. 
        :type attack_type: list[str]
        :param hostname: Hostname is the hostname filter. 
        :type hostname: list[str]
        :param msg: Message is the audit message text filter. 
        :type msg: list[str]
        :param interactive: Interactive is the audit interactive filter. 
        :type interactive: list[str]
        :param function: Function is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param app: App is the name constraint of the service that triggered the audit. 
        :type app: list[str]
        :param process_path: ProcessPath is the path constraint of the process that triggered the audit. 
        :type process_path: list[str]
        :param request_id: RequestID is used to filter by request ID. 
        :type request_id: list[str]
        :param function_id: FunctionID is used to filter by function ID. 
        :type function_id: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'offset',
            'limit',
            'search',
            'sort',
            'reverse',
            'collections',
            'account_ids',
            'fields',
            'profile_id',
            '_from',
            'to',
            'time',
            'image_name',
            'container',
            'container_id',
            'rule_name',
            'type',
            'effect',
            'user',
            'os',
            'namespace',
            'cluster',
            'attack_type',
            'hostname',
            'msg',
            'interactive',
            'function',
            'region',
            'runtime',
            'attack_techniques',
            'app',
            'process_path',
            'request_id',
            'function_id',
            'aggregate'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_runtime_serverless_download_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'reverse' in local_var_params and local_var_params['reverse'] is not None:  # noqa: E501
            query_params.append(('reverse', local_var_params['reverse']))  # noqa: E501
        if 'collections' in local_var_params and local_var_params['collections'] is not None:  # noqa: E501
            query_params.append(('collections', local_var_params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'account_ids' in local_var_params and local_var_params['account_ids'] is not None:  # noqa: E501
            query_params.append(('accountIDs', local_var_params['account_ids']))  # noqa: E501
            collection_formats['accountIDs'] = 'multi'  # noqa: E501
        if 'fields' in local_var_params and local_var_params['fields'] is not None:  # noqa: E501
            query_params.append(('fields', local_var_params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if 'profile_id' in local_var_params and local_var_params['profile_id'] is not None:  # noqa: E501
            query_params.append(('profileID', local_var_params['profile_id']))  # noqa: E501
            collection_formats['profileID'] = 'multi'  # noqa: E501
        if '_from' in local_var_params and local_var_params['_from'] is not None:  # noqa: E501
            query_params.append(('from', local_var_params['_from']))  # noqa: E501
        if 'to' in local_var_params and local_var_params['to'] is not None:  # noqa: E501
            query_params.append(('to', local_var_params['to']))  # noqa: E501
        if 'time' in local_var_params and local_var_params['time'] is not None:  # noqa: E501
            query_params.append(('time', local_var_params['time']))  # noqa: E501
        if 'image_name' in local_var_params and local_var_params['image_name'] is not None:  # noqa: E501
            query_params.append(('imageName', local_var_params['image_name']))  # noqa: E501
            collection_formats['imageName'] = 'multi'  # noqa: E501
        if 'container' in local_var_params and local_var_params['container'] is not None:  # noqa: E501
            query_params.append(('container', local_var_params['container']))  # noqa: E501
            collection_formats['container'] = 'multi'  # noqa: E501
        if 'container_id' in local_var_params and local_var_params['container_id'] is not None:  # noqa: E501
            query_params.append(('containerID', local_var_params['container_id']))  # noqa: E501
            collection_formats['containerID'] = 'multi'  # noqa: E501
        if 'rule_name' in local_var_params and local_var_params['rule_name'] is not None:  # noqa: E501
            query_params.append(('ruleName', local_var_params['rule_name']))  # noqa: E501
            collection_formats['ruleName'] = 'multi'  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
            collection_formats['type'] = 'multi'  # noqa: E501
        if 'effect' in local_var_params and local_var_params['effect'] is not None:  # noqa: E501
            query_params.append(('effect', local_var_params['effect']))  # noqa: E501
            collection_formats['effect'] = 'multi'  # noqa: E501
        if 'user' in local_var_params and local_var_params['user'] is not None:  # noqa: E501
            query_params.append(('user', local_var_params['user']))  # noqa: E501
            collection_formats['user'] = 'multi'  # noqa: E501
        if 'os' in local_var_params and local_var_params['os'] is not None:  # noqa: E501
            query_params.append(('os', local_var_params['os']))  # noqa: E501
            collection_formats['os'] = 'multi'  # noqa: E501
        if 'namespace' in local_var_params and local_var_params['namespace'] is not None:  # noqa: E501
            query_params.append(('namespace', local_var_params['namespace']))  # noqa: E501
            collection_formats['namespace'] = 'multi'  # noqa: E501
        if 'cluster' in local_var_params and local_var_params['cluster'] is not None:  # noqa: E501
            query_params.append(('cluster', local_var_params['cluster']))  # noqa: E501
            collection_formats['cluster'] = 'multi'  # noqa: E501
        if 'attack_type' in local_var_params and local_var_params['attack_type'] is not None:  # noqa: E501
            query_params.append(('attackType', local_var_params['attack_type']))  # noqa: E501
            collection_formats['attackType'] = 'multi'  # noqa: E501
        if 'hostname' in local_var_params and local_var_params['hostname'] is not None:  # noqa: E501
            query_params.append(('hostname', local_var_params['hostname']))  # noqa: E501
            collection_formats['hostname'] = 'multi'  # noqa: E501
        if 'msg' in local_var_params and local_var_params['msg'] is not None:  # noqa: E501
            query_params.append(('msg', local_var_params['msg']))  # noqa: E501
            collection_formats['msg'] = 'multi'  # noqa: E501
        if 'interactive' in local_var_params and local_var_params['interactive'] is not None:  # noqa: E501
            query_params.append(('interactive', local_var_params['interactive']))  # noqa: E501
            collection_formats['interactive'] = 'multi'  # noqa: E501
        if 'function' in local_var_params and local_var_params['function'] is not None:  # noqa: E501
            query_params.append(('function', local_var_params['function']))  # noqa: E501
            collection_formats['function'] = 'multi'  # noqa: E501
        if 'region' in local_var_params and local_var_params['region'] is not None:  # noqa: E501
            query_params.append(('region', local_var_params['region']))  # noqa: E501
            collection_formats['region'] = 'multi'  # noqa: E501
        if 'runtime' in local_var_params and local_var_params['runtime'] is not None:  # noqa: E501
            query_params.append(('runtime', local_var_params['runtime']))  # noqa: E501
            collection_formats['runtime'] = 'multi'  # noqa: E501
        if 'attack_techniques' in local_var_params and local_var_params['attack_techniques'] is not None:  # noqa: E501
            query_params.append(('attackTechniques', local_var_params['attack_techniques']))  # noqa: E501
            collection_formats['attackTechniques'] = 'multi'  # noqa: E501
        if 'app' in local_var_params and local_var_params['app'] is not None:  # noqa: E501
            query_params.append(('app', local_var_params['app']))  # noqa: E501
            collection_formats['app'] = 'multi'  # noqa: E501
        if 'process_path' in local_var_params and local_var_params['process_path'] is not None:  # noqa: E501
            query_params.append(('processPath', local_var_params['process_path']))  # noqa: E501
            collection_formats['processPath'] = 'multi'  # noqa: E501
        if 'request_id' in local_var_params and local_var_params['request_id'] is not None:  # noqa: E501
            query_params.append(('requestID', local_var_params['request_id']))  # noqa: E501
            collection_formats['requestID'] = 'multi'  # noqa: E501
        if 'function_id' in local_var_params and local_var_params['function_id'] is not None:  # noqa: E501
            query_params.append(('functionID', local_var_params['function_id']))  # noqa: E501
            collection_formats['functionID'] = 'multi'  # noqa: E501
        if 'aggregate' in local_var_params and local_var_params['aggregate'] is not None:  # noqa: E501
            query_params.append(('aggregate', local_var_params['aggregate']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/audits/runtime/serverless/download', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_runtime_serverless_get(self, **kwargs):  # noqa: E501
        """api_v1_audits_runtime_serverless_get  # noqa: E501

        ServerlessRuntimeAudits returns all host audits according to the query specification   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_runtime_serverless_get(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param profile_id: ProfileIDs are the profile ids to filter. 
        :type profile_id: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param time: Time is an optional exact time constraint for the audit. 
        :type time: datetime
        :param rule_name: RuleNames is used to filter by rule name. 
        :type rule_name: list[str]
        :param type: Types is a filter by runtime audit type. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect (block/alert). 
        :type effect: list[str]
        :param function: Function is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param request_id: RequestID is used to filter by request id. 
        :type request_id: list[str]
        :param msg: Message is the audit message text filter. 
        :type msg: list[str]
        :param attack_type: AttackTypes is used to filter by runtime audit attack type. 
        :type attack_type: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[SharedRuntimeAudit]
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_runtime_serverless_get_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_runtime_serverless_get_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_runtime_serverless_get  # noqa: E501

        ServerlessRuntimeAudits returns all host audits according to the query specification   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_runtime_serverless_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param profile_id: ProfileIDs are the profile ids to filter. 
        :type profile_id: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param time: Time is an optional exact time constraint for the audit. 
        :type time: datetime
        :param rule_name: RuleNames is used to filter by rule name. 
        :type rule_name: list[str]
        :param type: Types is a filter by runtime audit type. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect (block/alert). 
        :type effect: list[str]
        :param function: Function is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param request_id: RequestID is used to filter by request id. 
        :type request_id: list[str]
        :param msg: Message is the audit message text filter. 
        :type msg: list[str]
        :param attack_type: AttackTypes is used to filter by runtime audit attack type. 
        :type attack_type: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[SharedRuntimeAudit], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'offset',
            'limit',
            'search',
            'sort',
            'reverse',
            'collections',
            'account_ids',
            'fields',
            'profile_id',
            '_from',
            'to',
            'time',
            'rule_name',
            'type',
            'effect',
            'function',
            'region',
            'runtime',
            'attack_techniques',
            'request_id',
            'msg',
            'attack_type',
            'aggregate'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_runtime_serverless_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'reverse' in local_var_params and local_var_params['reverse'] is not None:  # noqa: E501
            query_params.append(('reverse', local_var_params['reverse']))  # noqa: E501
        if 'collections' in local_var_params and local_var_params['collections'] is not None:  # noqa: E501
            query_params.append(('collections', local_var_params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'account_ids' in local_var_params and local_var_params['account_ids'] is not None:  # noqa: E501
            query_params.append(('accountIDs', local_var_params['account_ids']))  # noqa: E501
            collection_formats['accountIDs'] = 'multi'  # noqa: E501
        if 'fields' in local_var_params and local_var_params['fields'] is not None:  # noqa: E501
            query_params.append(('fields', local_var_params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if 'profile_id' in local_var_params and local_var_params['profile_id'] is not None:  # noqa: E501
            query_params.append(('profileID', local_var_params['profile_id']))  # noqa: E501
            collection_formats['profileID'] = 'multi'  # noqa: E501
        if '_from' in local_var_params and local_var_params['_from'] is not None:  # noqa: E501
            query_params.append(('from', local_var_params['_from']))  # noqa: E501
        if 'to' in local_var_params and local_var_params['to'] is not None:  # noqa: E501
            query_params.append(('to', local_var_params['to']))  # noqa: E501
        if 'time' in local_var_params and local_var_params['time'] is not None:  # noqa: E501
            query_params.append(('time', local_var_params['time']))  # noqa: E501
        if 'rule_name' in local_var_params and local_var_params['rule_name'] is not None:  # noqa: E501
            query_params.append(('ruleName', local_var_params['rule_name']))  # noqa: E501
            collection_formats['ruleName'] = 'multi'  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
            collection_formats['type'] = 'multi'  # noqa: E501
        if 'effect' in local_var_params and local_var_params['effect'] is not None:  # noqa: E501
            query_params.append(('effect', local_var_params['effect']))  # noqa: E501
            collection_formats['effect'] = 'multi'  # noqa: E501
        if 'function' in local_var_params and local_var_params['function'] is not None:  # noqa: E501
            query_params.append(('function', local_var_params['function']))  # noqa: E501
            collection_formats['function'] = 'multi'  # noqa: E501
        if 'region' in local_var_params and local_var_params['region'] is not None:  # noqa: E501
            query_params.append(('region', local_var_params['region']))  # noqa: E501
            collection_formats['region'] = 'multi'  # noqa: E501
        if 'runtime' in local_var_params and local_var_params['runtime'] is not None:  # noqa: E501
            query_params.append(('runtime', local_var_params['runtime']))  # noqa: E501
            collection_formats['runtime'] = 'multi'  # noqa: E501
        if 'attack_techniques' in local_var_params and local_var_params['attack_techniques'] is not None:  # noqa: E501
            query_params.append(('attackTechniques', local_var_params['attack_techniques']))  # noqa: E501
            collection_formats['attackTechniques'] = 'multi'  # noqa: E501
        if 'request_id' in local_var_params and local_var_params['request_id'] is not None:  # noqa: E501
            query_params.append(('requestID', local_var_params['request_id']))  # noqa: E501
            collection_formats['requestID'] = 'multi'  # noqa: E501
        if 'msg' in local_var_params and local_var_params['msg'] is not None:  # noqa: E501
            query_params.append(('msg', local_var_params['msg']))  # noqa: E501
            collection_formats['msg'] = 'multi'  # noqa: E501
        if 'attack_type' in local_var_params and local_var_params['attack_type'] is not None:  # noqa: E501
            query_params.append(('attackType', local_var_params['attack_type']))  # noqa: E501
            collection_formats['attackType'] = 'multi'  # noqa: E501
        if 'aggregate' in local_var_params and local_var_params['aggregate'] is not None:  # noqa: E501
            query_params.append(('aggregate', local_var_params['aggregate']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "list[SharedRuntimeAudit]",
        }

        return self.api_client.call_api(
            '/api/v1/audits/runtime/serverless', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_runtime_serverless_timeslice_get(self, **kwargs):  # noqa: E501
        """api_v1_audits_runtime_serverless_timeslice_get  # noqa: E501

        ServerlessRuntimeAuditTimeslice returns serverless runtime audit buckets according to the query timeframe   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_runtime_serverless_timeslice_get(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param profile_id: ProfileIDs are the profile IDs to filter. 
        :type profile_id: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param time: Time is used to filter by audit time. 
        :type time: datetime
        :param image_name: ImageNames is the image name filter. 
        :type image_name: list[str]
        :param container: Containers is the container name filter. 
        :type container: list[str]
        :param container_id: ContainerID is used to filter by container ID. 
        :type container_id: list[str]
        :param rule_name: RuleNames is used to filter by rule name. 
        :type rule_name: list[str]
        :param type: Types is used to filter by runtime audit type. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect (e.g., block/alert). 
        :type effect: list[str]
        :param user: Users is used to filter by host users. 
        :type user: list[str]
        :param os: OS is the image OS distro filter. 
        :type os: list[str]
        :param namespace: Namespaces is the namespaces filter. 
        :type namespace: list[str]
        :param cluster: Clusters is the cluster filter. 
        :type cluster: list[str]
        :param attack_type: AttackTypes is used to filter by runtime audit attack type. 
        :type attack_type: list[str]
        :param hostname: Hostname is the hostname filter. 
        :type hostname: list[str]
        :param msg: Message is the audit message text filter. 
        :type msg: list[str]
        :param interactive: Interactive is the audit interactive filter. 
        :type interactive: list[str]
        :param function: Function is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param app: App is the name constraint of the service that triggered the audit. 
        :type app: list[str]
        :param process_path: ProcessPath is the path constraint of the process that triggered the audit. 
        :type process_path: list[str]
        :param request_id: RequestID is used to filter by request ID. 
        :type request_id: list[str]
        :param function_id: FunctionID is used to filter by function ID. 
        :type function_id: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param buckets: Buckets is the number of buckets to return. 
        :type buckets: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[TypesAuditTimeslice]
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_runtime_serverless_timeslice_get_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_runtime_serverless_timeslice_get_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_runtime_serverless_timeslice_get  # noqa: E501

        ServerlessRuntimeAuditTimeslice returns serverless runtime audit buckets according to the query timeframe   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_runtime_serverless_timeslice_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param profile_id: ProfileIDs are the profile IDs to filter. 
        :type profile_id: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param time: Time is used to filter by audit time. 
        :type time: datetime
        :param image_name: ImageNames is the image name filter. 
        :type image_name: list[str]
        :param container: Containers is the container name filter. 
        :type container: list[str]
        :param container_id: ContainerID is used to filter by container ID. 
        :type container_id: list[str]
        :param rule_name: RuleNames is used to filter by rule name. 
        :type rule_name: list[str]
        :param type: Types is used to filter by runtime audit type. 
        :type type: list[str]
        :param effect: Effect is used to filter by runtime audit effect (e.g., block/alert). 
        :type effect: list[str]
        :param user: Users is used to filter by host users. 
        :type user: list[str]
        :param os: OS is the image OS distro filter. 
        :type os: list[str]
        :param namespace: Namespaces is the namespaces filter. 
        :type namespace: list[str]
        :param cluster: Clusters is the cluster filter. 
        :type cluster: list[str]
        :param attack_type: AttackTypes is used to filter by runtime audit attack type. 
        :type attack_type: list[str]
        :param hostname: Hostname is the hostname filter. 
        :type hostname: list[str]
        :param msg: Message is the audit message text filter. 
        :type msg: list[str]
        :param interactive: Interactive is the audit interactive filter. 
        :type interactive: list[str]
        :param function: Function is used to filter by function name. 
        :type function: list[str]
        :param region: Region is used to filter by region. 
        :type region: list[str]
        :param runtime: Runtime is used to filter by runtime. 
        :type runtime: list[str]
        :param attack_techniques: AttackTechniques are the MITRE attack techniques. 
        :type attack_techniques: list[str]
        :param app: App is the name constraint of the service that triggered the audit. 
        :type app: list[str]
        :param process_path: ProcessPath is the path constraint of the process that triggered the audit. 
        :type process_path: list[str]
        :param request_id: RequestID is used to filter by request ID. 
        :type request_id: list[str]
        :param function_id: FunctionID is used to filter by function ID. 
        :type function_id: list[str]
        :param aggregate: Aggregate indicates whether the result audits should be aggregated according to the Select field. 
        :type aggregate: bool
        :param buckets: Buckets is the number of buckets to return. 
        :type buckets: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[TypesAuditTimeslice], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'offset',
            'limit',
            'search',
            'sort',
            'reverse',
            'collections',
            'account_ids',
            'fields',
            'profile_id',
            '_from',
            'to',
            'time',
            'image_name',
            'container',
            'container_id',
            'rule_name',
            'type',
            'effect',
            'user',
            'os',
            'namespace',
            'cluster',
            'attack_type',
            'hostname',
            'msg',
            'interactive',
            'function',
            'region',
            'runtime',
            'attack_techniques',
            'app',
            'process_path',
            'request_id',
            'function_id',
            'aggregate',
            'buckets'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_runtime_serverless_timeslice_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'reverse' in local_var_params and local_var_params['reverse'] is not None:  # noqa: E501
            query_params.append(('reverse', local_var_params['reverse']))  # noqa: E501
        if 'collections' in local_var_params and local_var_params['collections'] is not None:  # noqa: E501
            query_params.append(('collections', local_var_params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'account_ids' in local_var_params and local_var_params['account_ids'] is not None:  # noqa: E501
            query_params.append(('accountIDs', local_var_params['account_ids']))  # noqa: E501
            collection_formats['accountIDs'] = 'multi'  # noqa: E501
        if 'fields' in local_var_params and local_var_params['fields'] is not None:  # noqa: E501
            query_params.append(('fields', local_var_params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if 'profile_id' in local_var_params and local_var_params['profile_id'] is not None:  # noqa: E501
            query_params.append(('profileID', local_var_params['profile_id']))  # noqa: E501
            collection_formats['profileID'] = 'multi'  # noqa: E501
        if '_from' in local_var_params and local_var_params['_from'] is not None:  # noqa: E501
            query_params.append(('from', local_var_params['_from']))  # noqa: E501
        if 'to' in local_var_params and local_var_params['to'] is not None:  # noqa: E501
            query_params.append(('to', local_var_params['to']))  # noqa: E501
        if 'time' in local_var_params and local_var_params['time'] is not None:  # noqa: E501
            query_params.append(('time', local_var_params['time']))  # noqa: E501
        if 'image_name' in local_var_params and local_var_params['image_name'] is not None:  # noqa: E501
            query_params.append(('imageName', local_var_params['image_name']))  # noqa: E501
            collection_formats['imageName'] = 'multi'  # noqa: E501
        if 'container' in local_var_params and local_var_params['container'] is not None:  # noqa: E501
            query_params.append(('container', local_var_params['container']))  # noqa: E501
            collection_formats['container'] = 'multi'  # noqa: E501
        if 'container_id' in local_var_params and local_var_params['container_id'] is not None:  # noqa: E501
            query_params.append(('containerID', local_var_params['container_id']))  # noqa: E501
            collection_formats['containerID'] = 'multi'  # noqa: E501
        if 'rule_name' in local_var_params and local_var_params['rule_name'] is not None:  # noqa: E501
            query_params.append(('ruleName', local_var_params['rule_name']))  # noqa: E501
            collection_formats['ruleName'] = 'multi'  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
            collection_formats['type'] = 'multi'  # noqa: E501
        if 'effect' in local_var_params and local_var_params['effect'] is not None:  # noqa: E501
            query_params.append(('effect', local_var_params['effect']))  # noqa: E501
            collection_formats['effect'] = 'multi'  # noqa: E501
        if 'user' in local_var_params and local_var_params['user'] is not None:  # noqa: E501
            query_params.append(('user', local_var_params['user']))  # noqa: E501
            collection_formats['user'] = 'multi'  # noqa: E501
        if 'os' in local_var_params and local_var_params['os'] is not None:  # noqa: E501
            query_params.append(('os', local_var_params['os']))  # noqa: E501
            collection_formats['os'] = 'multi'  # noqa: E501
        if 'namespace' in local_var_params and local_var_params['namespace'] is not None:  # noqa: E501
            query_params.append(('namespace', local_var_params['namespace']))  # noqa: E501
            collection_formats['namespace'] = 'multi'  # noqa: E501
        if 'cluster' in local_var_params and local_var_params['cluster'] is not None:  # noqa: E501
            query_params.append(('cluster', local_var_params['cluster']))  # noqa: E501
            collection_formats['cluster'] = 'multi'  # noqa: E501
        if 'attack_type' in local_var_params and local_var_params['attack_type'] is not None:  # noqa: E501
            query_params.append(('attackType', local_var_params['attack_type']))  # noqa: E501
            collection_formats['attackType'] = 'multi'  # noqa: E501
        if 'hostname' in local_var_params and local_var_params['hostname'] is not None:  # noqa: E501
            query_params.append(('hostname', local_var_params['hostname']))  # noqa: E501
            collection_formats['hostname'] = 'multi'  # noqa: E501
        if 'msg' in local_var_params and local_var_params['msg'] is not None:  # noqa: E501
            query_params.append(('msg', local_var_params['msg']))  # noqa: E501
            collection_formats['msg'] = 'multi'  # noqa: E501
        if 'interactive' in local_var_params and local_var_params['interactive'] is not None:  # noqa: E501
            query_params.append(('interactive', local_var_params['interactive']))  # noqa: E501
            collection_formats['interactive'] = 'multi'  # noqa: E501
        if 'function' in local_var_params and local_var_params['function'] is not None:  # noqa: E501
            query_params.append(('function', local_var_params['function']))  # noqa: E501
            collection_formats['function'] = 'multi'  # noqa: E501
        if 'region' in local_var_params and local_var_params['region'] is not None:  # noqa: E501
            query_params.append(('region', local_var_params['region']))  # noqa: E501
            collection_formats['region'] = 'multi'  # noqa: E501
        if 'runtime' in local_var_params and local_var_params['runtime'] is not None:  # noqa: E501
            query_params.append(('runtime', local_var_params['runtime']))  # noqa: E501
            collection_formats['runtime'] = 'multi'  # noqa: E501
        if 'attack_techniques' in local_var_params and local_var_params['attack_techniques'] is not None:  # noqa: E501
            query_params.append(('attackTechniques', local_var_params['attack_techniques']))  # noqa: E501
            collection_formats['attackTechniques'] = 'multi'  # noqa: E501
        if 'app' in local_var_params and local_var_params['app'] is not None:  # noqa: E501
            query_params.append(('app', local_var_params['app']))  # noqa: E501
            collection_formats['app'] = 'multi'  # noqa: E501
        if 'process_path' in local_var_params and local_var_params['process_path'] is not None:  # noqa: E501
            query_params.append(('processPath', local_var_params['process_path']))  # noqa: E501
            collection_formats['processPath'] = 'multi'  # noqa: E501
        if 'request_id' in local_var_params and local_var_params['request_id'] is not None:  # noqa: E501
            query_params.append(('requestID', local_var_params['request_id']))  # noqa: E501
            collection_formats['requestID'] = 'multi'  # noqa: E501
        if 'function_id' in local_var_params and local_var_params['function_id'] is not None:  # noqa: E501
            query_params.append(('functionID', local_var_params['function_id']))  # noqa: E501
            collection_formats['functionID'] = 'multi'  # noqa: E501
        if 'aggregate' in local_var_params and local_var_params['aggregate'] is not None:  # noqa: E501
            query_params.append(('aggregate', local_var_params['aggregate']))  # noqa: E501
        if 'buckets' in local_var_params and local_var_params['buckets'] is not None:  # noqa: E501
            query_params.append(('buckets', local_var_params['buckets']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "list[TypesAuditTimeslice]",
        }

        return self.api_client.call_api(
            '/api/v1/audits/runtime/serverless/timeslice', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_trust_download_get(self, **kwargs):  # noqa: E501
        """api_v1_audits_trust_download_get  # noqa: E501

        DownloadTrustAudits downloads the trust audits according to the specified query   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_trust_download_get(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param rule_name: RuleNames is used to filter by rulename. 
        :type rule_name: list[str]
        :param effect: Effect is used to filter by runtime audit effect (block/alert). 
        :type effect: list[str]
        :param id: IDs is used to filter by registry/repo. 
        :type id: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_trust_download_get_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_trust_download_get_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_trust_download_get  # noqa: E501

        DownloadTrustAudits downloads the trust audits according to the specified query   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_trust_download_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param rule_name: RuleNames is used to filter by rulename. 
        :type rule_name: list[str]
        :param effect: Effect is used to filter by runtime audit effect (block/alert). 
        :type effect: list[str]
        :param id: IDs is used to filter by registry/repo. 
        :type id: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'offset',
            'limit',
            'search',
            'sort',
            'reverse',
            'collections',
            'account_ids',
            'fields',
            '_from',
            'to',
            'rule_name',
            'effect',
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_trust_download_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'reverse' in local_var_params and local_var_params['reverse'] is not None:  # noqa: E501
            query_params.append(('reverse', local_var_params['reverse']))  # noqa: E501
        if 'collections' in local_var_params and local_var_params['collections'] is not None:  # noqa: E501
            query_params.append(('collections', local_var_params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'account_ids' in local_var_params and local_var_params['account_ids'] is not None:  # noqa: E501
            query_params.append(('accountIDs', local_var_params['account_ids']))  # noqa: E501
            collection_formats['accountIDs'] = 'multi'  # noqa: E501
        if 'fields' in local_var_params and local_var_params['fields'] is not None:  # noqa: E501
            query_params.append(('fields', local_var_params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if '_from' in local_var_params and local_var_params['_from'] is not None:  # noqa: E501
            query_params.append(('from', local_var_params['_from']))  # noqa: E501
        if 'to' in local_var_params and local_var_params['to'] is not None:  # noqa: E501
            query_params.append(('to', local_var_params['to']))  # noqa: E501
        if 'rule_name' in local_var_params and local_var_params['rule_name'] is not None:  # noqa: E501
            query_params.append(('ruleName', local_var_params['rule_name']))  # noqa: E501
            collection_formats['ruleName'] = 'multi'  # noqa: E501
        if 'effect' in local_var_params and local_var_params['effect'] is not None:  # noqa: E501
            query_params.append(('effect', local_var_params['effect']))  # noqa: E501
            collection_formats['effect'] = 'multi'  # noqa: E501
        if 'id' in local_var_params and local_var_params['id'] is not None:  # noqa: E501
            query_params.append(('_id', local_var_params['id']))  # noqa: E501
            collection_formats['_id'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/audits/trust/download', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def api_v1_audits_trust_get(self, **kwargs):  # noqa: E501
        """api_v1_audits_trust_get  # noqa: E501

        TrustAudits returns all trust audits according to the query specification   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_trust_get(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param rule_name: RuleNames is used to filter by rulename. 
        :type rule_name: list[str]
        :param effect: Effect is used to filter by runtime audit effect (block/alert). 
        :type effect: list[str]
        :param id: IDs is used to filter by registry/repo. 
        :type id: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[SharedTrustAudits]
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v1_audits_trust_get_with_http_info(**kwargs)  # noqa: E501

    def api_v1_audits_trust_get_with_http_info(self, **kwargs):  # noqa: E501
        """api_v1_audits_trust_get  # noqa: E501

        TrustAudits returns all trust audits according to the query specification   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audits_trust_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param offset: Offset from the start of the list from which to retrieve documents. 
        :type offset: int
        :param limit: Number of documents to return. 
        :type limit: int
        :param search: Search term. 
        :type search: str
        :param sort: Key on which to sort. 
        :type sort: str
        :param reverse: Sort order. 
        :type reverse: bool
        :param collections: Scopes the query by collection. 
        :type collections: list[str]
        :param account_ids: Scopes the query by account ID. 
        :type account_ids: list[str]
        :param fields: List of fields to retrieve. 
        :type fields: list[str]
        :param _from: From is an optional minimum time constraints for the audit. 
        :type _from: datetime
        :param to: To is an optional maximum time constraints for the audit. 
        :type to: datetime
        :param rule_name: RuleNames is used to filter by rulename. 
        :type rule_name: list[str]
        :param effect: Effect is used to filter by runtime audit effect (block/alert). 
        :type effect: list[str]
        :param id: IDs is used to filter by registry/repo. 
        :type id: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[SharedTrustAudits], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'offset',
            'limit',
            'search',
            'sort',
            'reverse',
            'collections',
            'account_ids',
            'fields',
            '_from',
            'to',
            'rule_name',
            'effect',
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audits_trust_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'reverse' in local_var_params and local_var_params['reverse'] is not None:  # noqa: E501
            query_params.append(('reverse', local_var_params['reverse']))  # noqa: E501
        if 'collections' in local_var_params and local_var_params['collections'] is not None:  # noqa: E501
            query_params.append(('collections', local_var_params['collections']))  # noqa: E501
            collection_formats['collections'] = 'multi'  # noqa: E501
        if 'account_ids' in local_var_params and local_var_params['account_ids'] is not None:  # noqa: E501
            query_params.append(('accountIDs', local_var_params['account_ids']))  # noqa: E501
            collection_formats['accountIDs'] = 'multi'  # noqa: E501
        if 'fields' in local_var_params and local_var_params['fields'] is not None:  # noqa: E501
            query_params.append(('fields', local_var_params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if '_from' in local_var_params and local_var_params['_from'] is not None:  # noqa: E501
            query_params.append(('from', local_var_params['_from']))  # noqa: E501
        if 'to' in local_var_params and local_var_params['to'] is not None:  # noqa: E501
            query_params.append(('to', local_var_params['to']))  # noqa: E501
        if 'rule_name' in local_var_params and local_var_params['rule_name'] is not None:  # noqa: E501
            query_params.append(('ruleName', local_var_params['rule_name']))  # noqa: E501
            collection_formats['ruleName'] = 'multi'  # noqa: E501
        if 'effect' in local_var_params and local_var_params['effect'] is not None:  # noqa: E501
            query_params.append(('effect', local_var_params['effect']))  # noqa: E501
            collection_formats['effect'] = 'multi'  # noqa: E501
        if 'id' in local_var_params and local_var_params['id'] is not None:  # noqa: E501
            query_params.append(('_id', local_var_params['id']))  # noqa: E501
            collection_formats['_id'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "list[SharedTrustAudits]",
        }

        return self.api_client.call_api(
            '/api/v1/audits/trust', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))
